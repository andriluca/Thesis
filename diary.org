#+TITLE:    Diario dei Log del progetto
#+AUTHOR:   Luca Andriotto
#+STARTUP:  overview latexpreview entitiespretty
#+CATEGORY: Tesi

Raccolgo in questo file cosa è stato fatto/scoperto ogni giorno.

* 11.10.23
- [X] La funzione =squarewave= è buggata e non può essere utilizzata
  come input del sistema in Julia. Posso riscriverla semplicemente
- Il numero di threads utilizzabile è settabile all'avvio della REPL
  (-t auto).
- La repl, da Emacs, non produce correttamente i grafici quindi è
  sempre meglio avere un terminale sotto mano
- [[file:src/test/test3.jl][test3.jl]] fa il suo dovere

* 12.10.23
- [[file:src/test/test3.jl][test3.jl]] non permette di estrarre i flussi (aka le correnti) dalle
  soluzioni. Passo alla soluzione cosiddetta acausale (circuitale). La
  soluzione sarà riportata in [[file:src/test/test4.jl][test4.jl]].

* 16.10.23                                               :Modello:Componenti:
- La modularità del circuito è realizzata mediante dei modelli
  appositi, chiamati `Block`s:

#+begin_src julia
  @mtkmodel Block begin
      @components begin
          in = Pin()
          out = Pin()
          resistor = Resistor(R = 1.0)
          capacitor = Capacitor(C = 1.0)
          ground = Ground()
      end
      @equations begin
          connect(in, resistor.p)
          connect(resistor.n, capacitor.p)
          connect(out, capacitor.p)
          connect(capacitor.n, ground.g)
      end
  end
#+end_src

Questi blocchi hanno un punto d'ingresso ed uno di uscita, comodi per
effettuare dei collegamenti più complessi con blocchi in cascata.

Il sistema quindi altro non è se non una composizione di blocchi:

#+begin_src julia
  @mtkmodel System begin
      @components begin
          block1 = Block(resistor.R = 2.0)
          block2 = Block(resistor.R = 2.0)
          constant = Constant(k = 1.0)
          source = Voltage()
          ground = Ground()
      end
      @equations begin
          connect(constant.output, source.V)
          connect(source.p, block1.in)
          connect(block1.out, block2.in)
          connect(source.n, ground.g)
      end
  end
#+end_src

Il codice completo è in [[file:src/test/test5.jl][test5.jl]].

- Vi sono altri due problemi ora:
  - [X] Generare diversi blocchi (airway e alveolo) con diverse
    strutture.
  - [ ] Rendere la resistenza `Rtube` variabile e dipendente
    dall'integrale della corrente.

- Nel file ~Albero.cir~, l'ultima riga rappresenta la trachea.
  enable, IN sono due ingressi, NodeAA e TrigAB sono due uscite
  (stando a quello che dice Chiara).

* 17.10.23                                               :Modello:Componenti:
- Per entrambi gli schematici si vedano i fogli stampati.  Queste sono
  le versioni senza resistenza variabile.

#+begin_src julia
  @mtkmodel Airway begin
      @components begin
          in       = Pin()
          out      = Pin()
          r_tube   = Resistor(R = 1.0)
          i_tube   = Inductor(L = 1.0)
          c_g      = Capacitor(C = 1.0)
          r_sw     = Resistor(R = 1.0)
          i_sw     = Inductor(L = 1.0)
          c_sw     = Capacitor(C = 1.0)
          r_tube_1 = Resistor(R = 1.0)
          i_tube_1 = Inductor(L = 1.0)
          ground   = Ground()
      end
      @equations begin
          connect(in, r_tube.p)
          connect(r_tube.n, i_tube.p)
          connect(i_tube.n, c_g.p, i_sw.p, r_tube_1.p)
          connect(i_sw.n, r_sw.p)
          connect(r_sw.n, c_sw.p)
          connect(r_tube_1.n, i_tube_1.p)
          connect(out, i_tube_1.n)
          connect(c_g.n, c_sw.n, ground.g)
      end
  end
#+end_src

#+begin_src julia
  @mtkmodel Alveolo begin
      @components begin
          in     = Pin()
          out    = Pin()
          r_tube = Resistor(R = 1.0)
          i_tube = Inductor(L = 1.0)
          c_ga   = Capacitor(C = 1.0)
          i_t    = Inductor(L = 1.0)
          r_t    = Resistor(R = 1.0)
          c_t    = Capacitor(C = 1.0)
          r_s    = Resistor(R = 1.0)
          c_s    = Resistor(R = 1.0)
          ground   = Ground()
      end
      @equations begin
          connect(in, r_tube.p)
          connect(r_tube.n, i_tube.p)
          connect(i_tube.n, c_ga.p, i_t.p, out)
          connect(i_t.n, r_t.p)
          connect(r_t.n, c_t.p)
          connect(c_t.n, c_s.p, r_s.p)
          connect(c_ga.n, c_s.n, r_s.n, ground.g)
      end
  end
#+end_src

- [X] Lavorare sull'importazione di file CSV in cui ciascuna colonna
  corrisponde ad un array di variabili dello stesso tipo (tutte
  resistenze...).

* 18.10.23                                                            :Input:

Tramite questo codice posso importare un CSV come DataFrame.
#+begin_src julia
  # Read a DataFrame from CSV file
  df = CSV.read("data.csv", DataFrame)
  r = df.x1
#+end_src

- [X] Consulta il materiale fornito da Chiara per messaggio

* 20.10.23                              :Modello:Verilog:Parametri:Variabili:

Devo utilizzare IA{D, E, F, G, H, I}, IB{L, A, B} di `Albero.cir`


#+begin_example
IBB ( TrigBLB NodeBLA NodeBBA TrigBBB Vcharge ) alveolo_completo_luglio La= 5.896531e-03 Lb= 5.236159e+00 Ra= 2.282920e+02 Rb= 1.114955e+04 Chargeth= 5.185713e-07 Ccap= 2.463766e-07 Vin_th= 7.098371e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IBA ( TrigBLB NodeBLA NodeBAA TrigBAB Vcharge ) alveolo_completo_luglio La= 5.687354e-03 Lb= 5.050408e+00 Ra= 2.017423e+02 Rb= 9.852891e+03 Chargeth= 5.958497e-07 Ccap= 2.464514e-07 Vin_th= 6.794462e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IBL ( TrigAHB NodeAHA NodeBLA TrigBLB ) zwall_semplificato_veriloga La= 1.290849e-03 Lb= 1.159971e+00 Ra= 3.097440e+01 Rb= 1.512758e+03 Rws= 1.461035e+07 Lws= 9.016810e-01 Cws= 1.003855e-10 Chargeth= 5.910861e-07 Ccap= 5.722034e-10 Vin_th= 5.588244e+00 Vgravity= 0
IAH ( TrigAFB NodeAFA NodeAHA TrigAHB ) zwall_semplificato_veriloga La= 1.653093e-03 Lb= 1.485488e+00 Ra= 3.554331e+01 Rb= 1.735899e+03 Rws= 8.703449e+06 Lws= 5.994469e-01 Cws= 1.685156e-10 Chargeth= 9.427715e-07 Ccap= 9.126539e-10 Vin_th= 5.289833e+00 Vgravity= 0
IAF ( TrigADB NodeADA NodeAFA TrigAFB ) zwall_semplificato_veriloga La= 1.166141e-03 Lb= 1.047907e+00 Ra= 2.231464e+01 Rb= 1.089824e+03 Rws= 9.257208e+06 Lws= 7.164089e-01 Cws= 1.584351e-10 Chargeth= 8.396596e-07 Ccap= 8.128360e-10 Vin_th= 4.990351e+00 Vgravity= 0
IAD ( TrigACB NodeACA NodeADA TrigADB ) zwall_semplificato_veriloga La= 1.852803e-03 Lb= 1.664949e+00 Ra= 3.100029e+01 Rb= 1.514023e+03 Rws= 4.186147e+06 Lws= 3.705082e-01 Cws= 3.503620e-10 Chargeth= 1.744963e-06 Ccap= 1.689219e-09 Vin_th= 4.666378e+00 Vgravity= 0

[...]

IAE ( TrigADB NodeADA NodeAEA TrigAEB Vcharge ) alveolo_completo_luglio La= 6.440085e-03 Lb= 5.718839e+00 Ra= 3.109214e+02 Rb= 1.518509e+04 Chargeth= 3.642283e-07 Ccap= 2.462271e-07 Vin_th= 7.926677e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IAG ( TrigAFB NodeAFA NodeAGA TrigAGB Vcharge ) alveolo_completo_luglio La= 6.908560e-03 Lb= 6.134848e+00 Ra= 4.012746e+02 Rb= 1.959785e+04 Chargeth= 2.699475e-07 Ccap= 2.461359e-07 Vin_th= 8.694383e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IAI ( TrigAHB NodeAHA NodeAIA TrigAIB Vcharge ) alveolo_completo_luglio La= 7.229610e-03 Lb= 6.419942e+00 Ra= 4.759710e+02 Rb= 2.324594e+04 Chargeth= 2.198790e-07 Ccap= 2.460874e-07 Vin_th= 9.256451e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
#+end_example

** IAD ( TrigACB NodeACA NodeADA TrigADB ) zwall_semplificato_veriloga 
La= 1.852803e-03 -- sarebbe la I
Lb= 1.664949e+00
Ra= 3.100029e+01 -- resistenza in aria
Rb= 1.514023e+03 -- quello da aggiungere per avere quella in acqua (rl - ra)
Rws= 4.186147e+06
Lws= 3.705082e-01
Cws= 3.503620e-10
Chargeth= 1.744963e-06 -- V_FRC
Ccap= 1.689219e-09 -- C_g
Vin_th= 4.666378e+00 -- tensione su primo diodo
Vgravity= 0

** IAE ( TrigADB NodeADA NodeAEA TrigAEB Vcharge ) alveolo_completo_luglio
La= 6.440085e-03
Lb= 5.718839e+00 
Ra= 3.109214e+02 
Rb= 1.518509e+04 
Chargeth= 3.642283e-07 
Ccap= 2.462271e-07 
Vin_th= 7.926677e+00 
Vgravity= 0 
Lti= 5.795540e-04 
Rti= 1200 
Cti= 2.400000e-05 
Rs= 80000 
Cs= 2.100000e-05

** IAF ( TrigADB NodeADA NodeAFA TrigAFB ) zwall_semplificato_veriloga
La= 1.166141e-03
Lb= 1.047907e+00
Ra= 2.231464e+01
Rb= 1.089824e+03
Rws= 9.257208e+06
Lws= 7.164089e-01
Cws= 1.584351e-10
Chargeth= 8.396596e-07
Ccap= 8.128360e-10
Vin_th= 4.990351e+00
Vgravity= 0

** IAG ( TrigAFB NodeAFA NodeAGA TrigAGB Vcharge ) alveolo_completo_luglio
La= 6.908560e-03
Lb= 6.134848e+00
Ra= 4.012746e+02
Rb= 1.959785e+04
Chargeth= 2.699475e-07
Ccap= 2.461359e-07
Vin_th= 8.694383e+00
Vgravity= 0 
Lti= 5.795540e-04
Rti= 1200
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IAH ( TrigAFB NodeAFA NodeAHA TrigAHB ) zwall_semplificato_veriloga
La= 1.653093e-03
Lb= 1.485488e+00
Ra= 3.554331e+01
Rb= 1.735899e+03
Rws= 8.703449e+06
Lws= 5.994469e-01
Cws= 1.685156e-10
Chargeth= 9.427715e-07
Ccap= 9.126539e-10
Vin_th= 5.289833e+00
Vgravity= 0

** IAI ( TrigAHB NodeAHA NodeAIA TrigAIB Vcharge ) alveolo_completo_luglio
La= 7.229610e-03
Lb= 6.419942e+00
Ra= 4.759710e+02
Rb= 2.324594e+04
Chargeth= 2.198790e-07
Ccap= 2.460874e-07
Vin_th= 9.256451e+00
Vgravity= 0
Lti= 5.795540e-04
Rti= 1200 
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IBL ( TrigAHB NodeAHA NodeBLA TrigBLB ) zwall_semplificato_veriloga 
La= 1.290849e-03 
Lb= 1.159971e+00 
Ra= 3.097440e+01 
Rb= 1.512758e+03 
Rws= 1.461035e+07 
Lws= 9.016810e-01 
Cws= 1.003855e-10 
Chargeth= 5.910861e-07 
Ccap= 5.722034e-10 
Vin_th= 5.588244e+00 
Vgravity= 0

** IBB ( TrigBLB NodeBLA NodeBBA TrigBBB Vcharge ) alveolo_completo_luglio
La= 5.896531e-03
Lb= 5.236159e+00
Ra= 2.282920e+02
Rb= 1.114955e+04
Chargeth= 5.185713e-07
Ccap= 2.463766e-07
Vin_th= 7.098371e+00
Vgravity= 0
Lti= 5.795540e-04
Rti= 1200
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IBA ( TrigBLB NodeBLA NodeBAA TrigBAB Vcharge ) alveolo_completo_luglio 
La= 5.687354e-03 
Lb= 5.050408e+00 
Ra= 2.017423e+02 
Rb= 9.852891e+03 
Chargeth= 5.958497e-07 
Ccap= 2.464514e-07 
Vin_th= 6.794462e+00 
Vgravity= 0 
Lti= 5.795540e-04 
Rti= 1200 
Cti= 2.400000e-05 
Rs= 80000 
Cs= 2.100000e-05

Questi sono tutti i dati che ho trovato ma non so interpretare i nomi dei componenti nel file `Albero.cir` con i corrispettivi nel modello.

Penso sia necessario elencare i parametri e le variabili in gioco (dal documento cartaceo fornito da Chiara).

** Parametri
*** Non-terminal units (Airway)

| Parametro                     | Simbolo |   Valore | Unità           |
|-------------------------------+---------+----------+-----------------|
| Air density                   | \rho_a      | 1.132e-2 | cmH_{2}O * s^2 / m^2 |
| Air viscosity                 | \mu_a      | 1.739e-7 | cmH_{2}O * s       |
| Atmospheric pressure          | P_{at}     |     1033 | cmH_{2}O           |
| Fetal fluid density           | \rho_l      |  1.006e1 | cmH_{2}O * s^2 / m^2 |
| Fetal fluid viscosity         | \mu_l      | 8.667e-6 | cmH_{2}O * s       |
| Radius at FRC                 | r_{FRC}    |          | cm              |
| Surface tension               | \gamma       |      .04 | cm * cmH_{2}O      |
| Young modulus of soft tissues | Y_s      |      600 | [N / m^2]        |
| (?) Density                   | \rho_s      |      .88 | [g / mL?]       |
| (?) Viscosity                 | \mu_s      |     1.06 | g / mL          |

Il valore di viscosità non mi convince (nemmeno nell'unità di misura).

*** Terminal units (Alveoli)

| Parametro                                      | Simbolo |        Valore | Unità                                  |
|------------------------------------------------+---------+---------------+----------------------------------------|
| Air density                                    | \rho_a      |      1.132e-2 | cmH_{2}O*s^2/m^2                            |
| Air viscosity                                  | \mu_a      |      1.739e-7 | cmH_{2}O*s                                |
| Atmospheric pressure                           | P_{at}     |          1033 | cmH_{2}O                                  |
| Fetal fluid density                            | \rho_l      |       1.006e1 | cmH_{2}O*s^2/m^2                            |
| Fetal fluid viscosity                          | \mu_l      |      8.667e-6 | cmH_{2}O*s                                |
| Radius at FRC                                  | r_{FRC}    |               | cm                                     |
| Surface tension                                | \gamma       |           .04 | cm*cmH_{2}O                               |
| Young modulus soft tissues                     | Y_s      |           600 |                                        |
| Tissue compliance related to stress relaxation | C_s      |      7e-8 * 3 |                                        |
| Static tissue compliance                       | C_t      |      8e-8 * 3 | L / cmH_{2}O                              |
| Tissue inertance                               | I_t      | .00069/300*NA | cmH_{2}O * s^2 / L                         |
| Tissue resistance related to stress relaxation | R_s      |           8e6 | cmH_{2}O * s / L                          |
| Newtonian tissue resistance                    | R_t      |          12e4 | cmH_{2}O * s / L                          |
| (?) Density                                    | \rho_s      |           .88 |                                        |
| (?) Viscosity                                  | \mu_s      |          1.06 | [g/mL da documento ma non mi convince] |

** Variabili
*** Non-terminal units

| Variabili                                     | Simbolo | Range              | Unità          | Formula                                                                |
|-----------------------------------------------+---------+--------------------+----------------+------------------------------------------------------------------------|
| Capillary pressure due to air-fluid interface | V_{th}     | .2 - 9.1           | cmH_{2}O          | \dfrac{\gamma}{r_{FRC}} in air, 0 otherwise.                                   |
| Airway Resistance                             | R_{tube}   |                    | cmH_{2}O * s / L  | R_a + (R_l - R_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})         |
| Resistance (air-filled)                       | R_{a}      | .64 - 4.50e4       | cmH_{2}O * s / L  | \dfrac{8\mu_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                          |
| Resistance (liquid-filled)                    | R_{l}      | 32 - 2.24e6        | cmH_{2}O * s / L  | \dfrac{8\mu_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                          |
| Volume at FRC                                 | V_{FRC}    |                    | L              | \pi\cdot {r_{FRC}}^2 \cdot l_{FRC}                                                      |
| Flow*                                         | \dot{V} |                    | [L / s]        |                                                                        |
| Airway inertance                              | I_{tube}   |                    | cmH_{2}O * s^2 / L | I_a + (I_l - I_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})         |
| Inertance (air-filled)                        | I_{a}      | .95e-2 - .91       | cmH_{2}O * s^2 / L | \dfrac{8\rho_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                          |
| Inertance (liquid-filled)                     | I_{l}      | 8.58 - 816.22      | cmH_{2}O * s^2 / L | \dfrac{8\rho_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                          |
| Shunt airway compliance due to gas            | C_g      |                    | L / cmH_{2}O      | C_{FRC}\cdot (\dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}}) in air, 0 otherwise. |
| Airway compliance at FRC                      | C_{FRC}    | 2.27e-13 - 4.32e-7 | L / cmH_{2}O      | \dfrac{\pi\cdot {r_{FRC}}^2 \cdot l_{FRC}}{P_{at}}                                         |
| Airway tissue shunt impedance                 | Z_w      |                    | cmH_{2}O * s / L  | R_{ws} + j \cdot (\omega \cdot I_{ws} - \dfrac{1}{\omega \cdot C_{ws}})                               |
| Resistance of the soft tissues**              | R_{sw}     |                    | cmH_{2}O * s / L  | \dfrac{h_k \cdot \mu_{s}}{2\pi {r_{FRC}}^3 \cdot l_{FRC}}                                     |
| Inertance of the soft tissues**               | I_{sw}     |                    | cmH_{2}O * s^2 / L | \dfrac{h_k \cdot \rho_{s}}{2\pi r_{FRC} \cdot l_{FRC}}                                        |
| Compliance of the soft tissues**              | C_{sw}     |                    | L / cmH_{2}O      | \dfrac{2\pi {r_{FRC}}^3 \cdot l_{FRC}}{h_k \cdot \Y_{s}}                                    |
|                                               | h_k      |                    | [cm?]          | \sqrt{{r_k}^2 + \dfrac{w_{ak}}{\pi}} - r_k                                     |
|                                               | w_{ak}     |                    | [?]            | .033(2\pi\cdot r_k \cdot 1000 - .08) + .056                                       |
| Resistance of airway soft tissues**           | R_{ws}     | 1.14e1 - 2.27e7    | cmH_{2}O * s / L  | \dfrac{h_k \cdot \mu_{s}}{2\pi {r_{FRC}}^3 \cdot l_{FRC}}                                     |
| Inertance of airway soft tissues**            | I_{ws}     | 5.77e-4 - 1.13e-1  | cmH_{2}O * s^2 / L | \dfrac{h_k \cdot \rho_{s}}{2\pi r_{FRC} \cdot l_{FRC}}                                        |
| Compliance of airway soft tissues**           | C_{ws}     | 5.64e-11 - 1.28e-4 | L / cmH_{2}O      | \dfrac{2\pi {r_{FRC}}^3 \cdot l_{FRC}}{h_k \cdot \Y_{s}}                                    |


*: Quando facciamo l'integrale nel tempo, gli estremi temporali significano il tempo in cui l'interfaccia aria-liquido entra nella airway e il tempo in cui essa esce.
**: Sono la stessa cosa?? Assumo la loro uguaglianza nel mio ragionamento.

*** Terminal units

| Variabili                                                        | Simbolo | Range         | Unità          | Formula                                                                                                               |
|------------------------------------------------------------------+---------+---------------+----------------+-----------------------------------------------------------------------------------------------------------------------|
| Capillary pressure due to air-fluid interface of the acinar unit | v_{thA}    | 1.2 - 10.3    | cmH_{2}O          | \dfrac{2\gamma}{r_k} at the interface, 0 otherwise.                                                                         |
| Airway Resistance                                                | R_{tube}   |               | cmH_{2}O * s / L  | \dfrac{R_a + (R_l - R_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})}{\frac{V_0 + \int\limits_{t_0}^{t} {\dot{V} dt}}{V_{FRC,A}}} |
| Resistance (air-filled)                                          | R_a      | .64 - 4.50e4  | cmH_{2}O * s / L  | \dfrac{8\mu_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                                                                         |
| Resistance (liquid-filled)                                       | R_l      | 32 - 2.24e6   | cmH_{2}O * s / L  | \dfrac{8\mu_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                                                                         |
| Volume at FRC                                                    | V_{FRC}    |               | L              | \pi\cdot {r_{FRC}}^2 \cdot l_{FRC}                                                                                                     |
| Volume at FRC [acinar?]                                          | V_{FRC,A}  |               | L              | \dfrac{FRC}{N_A}                                                                                                       |
|                                                                  | V_0      |               | L              | \dfrac{\text{initial liquid volume}}{N_A}                                                                              |
| Airway inertance                                                 | I_{tube}   |               | cmH_{2}O * s^2 / L | I_a + (I_l - I_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}}) in air, 0 otherwise.                                   |
| Inertance (air-filled)                                           | I_a      | .95e-2 - .91  | cmH_{2}O * s^2 / L | \dfrac{8\rho_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                                                                         |
| Inertance (liquid-filled)                                        | I_l      | 8.58 - 816.22 | cmH_{2}O * s^2 / L | \dfrac{8\rho_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                                                                         |
| Shunt terminal unit compliance due to gas                        | C_{gA}     |               | L / cmH_{2}O      | C_{FRC,A}\cdot (\dfrac{\int\limits_{t_i}^{t_fA} {\dot{V} dt}}{V_{FRC,A}}) in air, 0 otherwise.                                           |
|                                                                  | C_{FRC,A}  |               | L / cmH_{2}O      | \dfrac{\text{FRC}}{P_{at} N_A} + \dfrac{\pi {r_FRC}^2 l_{FRC}}{P_{at}}                                                              |
| Acinar tissue impedance                                          | Z_{tissue} |               | cmH_{2}O * s / L  | R_t + j \cdot (\omega\cdot I_t - \dfrac{1}{\omega \cdot C_t}) + \dfrac{R_s}{1 + j\omega C_s R_s}                                                       |

** DONE Domande da fare
1. La resistenza `R_{tube}` ha diverse formule per i due modelli distinti (ossia per airway e alveolo)? yes
2. Nel parametro `I_t` il valore NA è il numero di Avogadro? Non saprei, non ci serve però

* 23.10.23                                                          :Verilog:
- Continuo il lavoro del 20.10 per sistemare le variabili ed i
  parametri del modello per capire di più.
- Rivedo il file in Verilog per comprendere le formule implementate.

** Unità non terminali
- [ ] Capire cosa significa `inout`
- [ ] Capire il ruolo di `through`
- [ ] Cosa sono nodeA e nodeC?
- [X] Cosa significa `cross` in Verilog? vedi [[https://verilogams.com/refman/modules/analog-procedural/timing.html#index-8][questa risorsa]]
- [ ] Non capisco perché non considero la caduta di potenziale sulla
  capacità ma quella tra il nodo `through` e `nodeC`.

Crea degli input (pin):
1. enable
2. IN

Crea degli output:
1. triggerOut

Vi sono una serie di variabili, istanziate come intere o reali.

*Intere*:
1. integration_en
2. sw_state: questa flag sembra controllare lo "stato" del programma.

*Reali*:
1. Lvalue
2. Rvalue
3. Cvalue
4. threshold
5. charge
6. trigout
7. thresholdb

Noto che ci sono i parametri "simili" a quelli del file `Albero.cir`
(i.e. stessi nomi).

#+begin_src verilog
  // VerilogA for BIO, cella_zwall, veriloga

  `include "constants.vams"
  `include "disciplines.vams"

  module zwall_semplificato_veriloga_events(enable, IN, OUT, triggerOUT);

     // [Inputs]
     input enable;
     electrical enable;
     inout IN, OUT;
     electrical IN, OUT, through;
     electrical integration;
     // [Outputs]
     output triggerOUT;
     electrical triggerOUT;

     // [Nodi]
     electrical nodeA, nodeC; //, nodeB;

     ground gnd;

     // [Parametri simili ad `Albero.cir`]
     parameter La       = 1e-6;
     parameter Lb       = 10e-6;
     parameter Ra       = 1e-3;
     parameter Rb       = 10e-3;
     parameter Rws      = 1;
     parameter Lws      = 1e-3;
     parameter Cws      = 1e-6;
     parameter Chargeth = 10e-6;
     parameter Ccap     = 1e-6;

     parameter Vin_th   = 1;
     parameter Vgravity = 0;

     // Variabili (intere e reali)
     integer   integration_en = 0, sw_state=1;
     real	  Lvalue = 0, Rvalue = 0, Cvalue = 0;
     real	  threshold = 1, charge = 0, trigout = 0, thresholdb = 0.5;

     analog begin

        @(cross(V(enable, gnd) - 0.5, +1)) begin
           integration_en = 1;
        end

        V(integration, gnd) <+ idt(integration_en * I(through, OUT)) / Chargeth;
        charge = min(V(integration, gnd), 1);

        @(cross(charge - threshold, +1)) begin
           sw_state = 0;
           trigout  = 1;
        end

        V(triggerOUT, gnd) <+ transition(trigout, 0, 10n, 10n);

        // [A seconda del valore di `sw_state` associo diversi valori a {R, L, C}value].
        if (sw_state == 1)
          begin
             Lvalue = La + Lb * max(0, (1 - charge));
             Rvalue = Ra + Rb * max(0, (1 - charge));
             Cvalue = max(1e - 12, Ccap * charge);
          end
        else
          begin
             Lvalue = La;
             Rvalue = Ra;
             Cvalue = Ccap;
          end

        // [Per ora lascio stare]
        V(IN, nodeA)       <+ V(enable, gnd) * transition(sw_state*Vin_th, 0, 10u, 10u) + Vgravity; // *restricted
        // [Lvalue e Rvalue corrispondono a L_{tube}/2 e a R_{tube}/2 rispettivamente]
        V (nodeA, through) <+  Lvalue * ddt(I(nodeA, through)) + (Rvalue) * I(nodeA, through);

        I (through, nodeC) <+ Cws * ddt(V(through, nodeC));
        V (nodeC, gnd)     <+ Rws * I(nodeC, gnd) + Lws * ddt(I(nodeC, gnd));
        // [OUT probabilmente è l'ultimo nodo sulla destra.]
        V(through, OUT)    <+ Rvalue * I(through, OUT) + Lvalue * ddt(I(through, OUT));
        I(through, gnd)    <+ ddt(Cvalue * V(through, gnd));

     end

  endmodule
  #+end_src

** Unità terminali (alveoli)

#+begin_src verilog
  // VerilogA for BIO, alveolo_veriloga, veriloga

  `include "constants.vams"
  `include "disciplines.vams"

  module alveolo_completo_aprventitre(enable, IN, OUT, triggerOUT, Vcharge);

     // [Nodi di Input -- Pin]
     input enable;
     electrical enable;
     input  Vcharge;
     electrical Vcharge;

     // [Porte leggibili?]
     inout IN, OUT;
     electrical IN, OUT;

     // [Nodi di Output -- Port]
     output triggerOUT;
     electrical triggerOUT;

     // [Nodi]
     electrical nodeA, nodeB;

     ground gnd;

     // [Parametri simili ad `Albero.cir`]
     parameter La       = 1e-6;
     parameter Lb       = 10e-6;
     parameter Ra       = 1e-3;
     parameter Rb       = 10e-3;
     parameter Chargeth = 10e-6;
     parameter Ccap     = 1e-6;
     parameter Vin_th   = 1;
     parameter Vgravity = 0;
     parameter Lti      = 1e-3;
     parameter Rti      = 1e-3;
     parameter Cti      = 1e-3;
     parameter Rs       = 1;
     parameter Cs       = 1e-6;

     // [Variabili intere e reali]
     integer integration_en = 0;
     real	Lvalue = 0, Rvalue = 0, Cvalue = 0, Rvalb = 0;
     real	threshold = 1;
     real	Vinteg = 0;
     real	VintegARIA = 0;
     real	charge = 0;
     real	chargeb = 0;
     real	chargec = 0;
     real	aux = 0;
     real	trigout = 0;
     real	temp = 1;
     real	Ctival = Cti, Csval = Cs, mult = 1, sw_state = 1;
     real	Vin_th2 = 0;
     real	th_swap = 0; 

     analog begin
        // la `@` consiste in una tipologia di if specifica per gli eventi, praticamente.
        @(cross(V(enable, gnd) - 0.5, +1)) begin
           integration_en = 1;
        end

        // Faccio l'integrazione quando la tensione su enable ha attraversato lo 0 in rising.
        // Se supero la threshold in modalità rising.
        VintegARIA = idt(integration_en * I(nodeA, OUT));
        // Faccio l'integrazione in ogni caso.
        Vinteg     = idt(I(nodeA, OUT));

        // Prendo il minimo tra 1 e il massimo tra 0 e il rapporto tra
        // l'integrale della corrente con il volume massimo a FRC.
        // Charge rappresenta la percentuale di volume occupata
        // dall'aria.

        charge  = min(1, max(0, VintegARIA / Chargeth));  //serve per R, l e cambio Vin_th e Vin_th2
        // Uso una costante per V_FRC
        chargec = min(1, max(0, VintegARIA / (2.5399e-4)));

        // Uso altre costanti
        chargeb = max(0,((Vinteg - 1.27e-4) / (2.5399e-4 - 1.27e-4)));

        aux  = min(1, (0.06 + chargeb));
        temp = 1;  //modifica del 21 luglio

        @(cross(chargec - threshold, +1)) begin //fine dell'integrazione della carica
           trigout  = 1; 
           sw_state = 0;
        end

        @(cross((charge - 1), +1)) begin
           th_swap = 1;
        end

        V(triggerOUT, gnd) <+ transition (trigout, 0, 10n, 10n);

        Rvalb = (Ra / aux);

        Lvalue = La + Lb * max(0,(1 - charge));
        Rvalue = (Rb / aux) * max(0,(1 - charge));

        Ctival = Cti / (temp); // va da Cti a Cti/15 quando ho raggiunto chargeb/2
        Csval  = Cs / (temp);// come sopra
        Cvalue = max(1e-15, Ccap * chargec);

        Vin_th2 = 0.08 / (pow((3 * max(VintegARIA / 100, 1e-8)) / (12.56), 1/3));

        V(IN, nodeA)   <+ V(enable, gnd) * Vin_th * transition ((1-th_swap), 0, 10u, 10u);
        V (nodeA, OUT) <+ Lvalue * ddt(I(nodeA, OUT)) +(Rvalb + Rvalue) * I(nodeA, OUT) + Vin_th2 * transition (th_swap, 0, 10u, 10u);
        I(OUT, gnd)    <+ Cvalue * ddt(V(OUT, gnd));
        V(OUT, nodeB)  <+ Lti * ddt(I(OUT, nodeB)) + Rti * I(OUT, nodeB) + idt(I(OUT, nodeB)) / (transition(Ctival * mult, 0, 10u, 10u));
        I(nodeB, gnd)  <+ V(nodeB, gnd) / Rs + transition(Csval * mult, 0, 10u, 10u) * ddt(V(nodeB, gnd));

     end
  endmodule
#+end_src

* 24.10.23                                   :Modello:Parametri:Bibliografia:
Riprendo le domande che avevo ieri.
- `inout`: tipo una porta readable.

Considerazioni:
- Una buona risorsa dove iniziare ad imparare il Verilog è [[https://verilogams.com][questa]].

** Colloquio con Chiara
Dice che forse è meglio tentare un approccio iterativo dopo il quale
posso integrare la corrente nel tempo di simulazione per cambiare i
valori di resistenza.  Dice che posso andare avanti con Julia se posso
inserire dei componenti variabili (tempo varianti o in funzione di
altre variabili come V(out) o I(nodeA, out)).  Le faccio qualche
domanda. Ora so a cosa corrispondono i vari componenti nel modello, in
termini di simboli utilizzati nel file `Albero.cir`.

** Non terminali
| ".cir"   | Modello cartaceo                                                   |
|----------+--------------------------------------------------------------------|
| La       | Induttanza in aria                                                 |
| Lb       | Quello da aggiungere per avere l'induttanza nel liquido (I_l - I_a)  |
| Ra       | Resistenza in aria                                                 |
| Rb       | Quello da aggiungere per avere la resistenza nel liquido (rl - ra) |
| Rws      | Resistenza del ramo sotto                                          |
| Lws      | Induttanza del ramo sotto                                          |
| Cws      | capacità del ramo sotto                                            |
| Chargeth | V_{FRC}                                                               |
| Ccap     | C_g                                                                 |
| Vin_th    | Tensione sul primo diodo (aka V_{th})                                 |
| Vgravity |                                                                    |

** Terminali
| ".cir"   | Modello cartaceo                                                   |
|----------+--------------------------------------------------------------------|
| La       | Induttanza in aria                                                 |
| Lb       | Quello da aggiungere per avere l'induttanza nel liquido (I_l - I_a)  |
| Ra       | Resistenza in aria                                                 |
| Rb       | Quello da aggiungere per avere la resistenza nel liquido (rl - ra) |
| Chargeth | V_{FRC}                                                               |
| Ccap     | C_g                                                                 |
| Vin_th    | Tensione sul primo diodo (aka V_{th})                                 |
| Vgravity |                                                                    |
| Lti      | Vedi grafico                                                       |
| Rti      | Vedi grafico                                                       |
| Cti      | Vedi grafico                                                       |
| Rs       | Vedi grafico                                                       |
| Cs       | Vedi grafico                                                       |

* 25.10.23                                               :Modello:Componenti:
** DONE Esiste un componente "Diodo" in Julia                   :Componenti:
Non sembrerebbe esistere un componente "Diodo" nella libreria standard
di `ModelingToolkit`.

** Scrivo tutte le equazioni differenziali in Julia
NodeC non corrisponde alla sua definizione nel modello elettrico: è
come se l'induttanza e la resistenza sopra fossero scambiate di posto
con la capacità che sta sotto (il nodo non è così importante stando a
quello che dice Chiara).

** Quali sono le variabili in funzione del tempo di cui conosciamo l'andamento? :Variabili:
Probabilmente anche quest'informazione la posso ricavare dal Verilog.
Sicuramente la forma d'onda della tensione in ingresso.  Non so se
sappiamo qualcosa del flusso

** DONE Quali sono le equazioni differenziali che devo risolvere in ciascun modulo?
Sicuramente sono contenute nei file Verilog quindi ripartirei da lì.
Il Verilog contiene queste equazioni.
*** Non terminali
#+begin_src verilog
  // 1 -- [tensione tra Rvalue e Lvalue]
  V (nodeA, through) <+ Lvalue * ddt(I(nodeA, through)) + (Rvalue) * I(nodeA, through);
  // 2 -- [corrente attraverso Cws]
  I (through, nodeC) <+ Cws * ddt(V(through, nodeC));
  // 3 -- [tensione sul blocco Rws-Lws]
  V (nodeC, gnd)     <+ Rws * I(nodeC, gnd) + Lws * ddt(I(nodeC, gnd));
  // 4 -- [tensione su Cvalue]
  // [OUT probabilmente è l'ultimo nodo sulla destra.]
  V(through, OUT)    <+ Rvalue * I(through, OUT) + Lvalue * ddt(I(through, OUT));
  // 5 -- [Corrente attraverso Cvalue]
  I(through, gnd)    <+ ddt(Cvalue * V(through, gnd));
#+end_src

*** Terminali
#+begin_src verilog
  // 1 -- [tensione sul blocco vin_th2-Rvalue-Lvalue]
  V (nodeA, OUT) <+ Lvalue * ddt(I(nodeA, OUT)) +(Rvalb + Rvalue) * I(nodeA, OUT) + Vin_th2 * transition (th_swap, 0, 10u, 10u);
  // 2 -- [corrente attraverso Cvalue]
  I(OUT, gnd)    <+ Cvalue * ddt(V(OUT, gnd));
  // 3 -- [tensione sul blocco Lt-Rt-Ct?] [sembrerebbe esclusa la capacità]
  V(OUT, nodeB)  <+ Lti * ddt(I(OUT, nodeB)) + Rti * I(OUT, nodeB) + idt(I(OUT, nodeB)) / (transition(Ctival * mult, 0, 10u, 10u));
  // 4 -- [corrente attraverso il parallelo tra Cs e Rs] 
  I(nodeB, gnd)  <+ V(nodeB, gnd) / Rs + transition(Csval * mult, 0, 10u, 10u) * ddt(V(nodeB, gnd));
#+end_src

** DONE Cosa s'intende per `transition` in Verilog?
Stando a quanto scritto [[https://verilogams.com/refman/basics/expressions.html#transition][qui]]:
#+begin_example
Converts a piecewise constant waveform, operand, into a waveform that has controlled transitions. 
#+end_example

Quindi converte una forma d'onda costante a tratti (immagino una
"spezzata") in una forma d'onda con transizioni controllate.

** A cosa servono tutte le flag del Verilog?                       :Verilog:
Non penso sia per ora necessario
* 27.10.23                                          :Componenti:Bibliografia:
Ho guardato due video del canale di Julia:
- [[https://www.youtube.com/watch?v=q8SzFTtgA60][Cedar: un simulatore di circuito analogico accelerato]]
- [[https://www.youtube.com/watch?v=ZYkojUozeC4][Causal vs. Acausal Modeling]]: spiega la differenza tra i due stili di
  modeling e quanto sia più facile scalare il problema, in termini di
  componenti, in un modello acausale.  Da ciò deduco che l'approccio
  migliore per creare il modello sia quello acausale perché anche più
  efficiente in termine di risoluzione delle equazioni differenziali.
- [[https://www.youtube.com/watch?v=3DfVowNFI2c][Exploring audio circuits with `ModelingToolkit.jl`]]: Posso recuperare
  le equazioni del diodo da qui

#+begin_src julia
  function LinearContinuationShockleyDiode(;name, Is = 1.0e-15, eta = 1.0,
                                           Vt = 26.0e-3, Maxexp = 15.0)
      @named oneport = Oneport()
      @unpack v, i = oneport
      ps = @parameters Is = Is eta = eta, Vt = Vt, Maxexp = Maxexp
      eqs = [
          i ~ IfElse.ifelse(v/Vt > Maxexp,
                            Is ∗ (exp(Maxexp) ∗ (1 + v/Vt - Maxexp) - 1),
                            Is ∗ (exp(v/Vt) - 1))
      ]
      extend(ODESystem(eqs, t, [], ps, name=name), oneport)
  end
#+end_src

#+begin_src julia
  function Diode(;name, Ids=1e-6, Vt=0.04, max_exp=15, R=1e8)
      @named oneport = OnePort()
      @unpack v, i = oneport
      pars = @parameters Ids=Ids Vt=Vt max_exp=max_exp R=R
      eqs = [i ~ Ids*(exlin(v/Vt, max_exp) - 1) + (v/R)]
      extend(ODESystem(eqs, t, [], pars; name=name), oneport)
  end
#+end_src

Esiste una libreria di componenti elettrici/elettronici basata su
`ModelingToolkit.jl` diversa da quella standard? A quanto pare no.

* 28.10.23                                                       :Componenti:
Ho pensato di trasformare l'equazione contenente l'integrale in un
equazione differenziale che poi verrà introdotta all'interno di una
legge di Ohm leggermente modificata.

#+begin_example
Variazione di resistenza nel tempo
d/dt (R(t)) = alpha * I(t)
Legge di Ohm
V(t) = R(t) * I(t)
#+end_example

con:
1. alpha = - (Rl - Ra) / V_FRC

Penso a come tradurlo in Julia.

Riporto per continuità di ragionamento anche uno dei casi errati che
ho provato a risolvere.

#+begin_src julia
  # ERRATO, vedi sotto
  @parameters t
  D = Differential(t)

  @mtkmodel VariableResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra, [description = "Resistance when air-filled"]
          Rl, [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Ra, [description = "Variable resistance"]
      end
      @equations begin
          # Ho trasformato l'equazione integrale della resistenza in una differenziale
          D(R) ~ ((Rl - Ra) / V_FRC) * i
          v ~ R * i
      end
  end
#+end_src

Mi sono reso conto di aver sbagliato l'equazione caratteristica della resistenza variabile e la riscrivo.  La variazione della resistenza nel tempo è negativa, in quanto la resistenza diminuisce con l'integrale della corrente.

#+begin_src julia
  @parameters t
  D = Differential(t)

  @mtkmodel VariableResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra, [description = "Resistance when air-filled"]
          Rl, [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Rl, [description = "Variable resistance"]
      end
      @equations begin
          # Ho trasformato l'equazione integrale della resistenza in una
          # differenziale. In particolare ho considerato che i valori
          # estremi di resistenza siano Rl ed Ra, quindi ho limitato
          # l'incremento.
          D(R) ~ ifelse(R > Ra,
                        - ((Rl - Ra) / V_FRC) * i,
                        0)
          v ~ R * i
      end
  end
#+end_src

Mostro un semplice circuito con generatore di onda quadra (e nel caso costante) e resistenza
variabile a Chiara per capire se la forma d'onda può essere quella
corretta oppure no. (vedi `[[file:src/test/test7.jl][test7.jl]]`)

* 29.10.23                                                       :Componenti:
Noto che si verifica un problema: quando la resistenza variabile
raggiunge il valore minimo, questa indipendentemente dalla tensione
fornita non cambia.  Provo a modificare il codice modificando la legge
di Ohm.

#+begin_src julia
  @parameters t
  D = Differential(t)

  # CID: Current Integral-Dependent.
  @mtkmodel CIDResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra,    [description = "Resistance when air-filled"]
          Rl,    [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Rl, [description = "Variable resistance"]
      end
      @equations begin
          # Trasformo l'equazione integrale della resistenza in una
          # differenziale che ne modella la variazione.
          D(R) ~ - ((Rl - Ra) / V_FRC) * i
          # Ra <= R <= Rl
          v ~ min(Rl, max(Ra, R)) * i
      end
  end
#+end_src

** Migliorare la tolleranza della soluzione        :Suggerimenti:Julia:Must:
L'opzione `reltol` va inserita nella funzione `solve()`. Leggi la
sezione "Controlling the Solver" di [[https://docs.sciml.ai/SciMLTutorialsOutput/html/introduction/01-ode_introduction.html][questa risorsa]].

#+begin_example
[...] However, a good rule of thumb is that the total solution accuracy is 1-2 digits less than the relative tolerances. [...]
#+end_example

** DONE Implementare induttore variabile
Ottenuto a partire dal codice di `CIDResistor`.  Da testare

#+begin_src julia
  @parameters t
  D = Differential(t)

  # CID: Current Integral-Dependent.
  @mtkmodel CIDInductor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ia,    [description = "Inductance when air-filled"]
          Il,    [description = "Inductance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore
          # d'inizializzazione del sistema.
          I(t) = Il, [description = "Variable inductance"]
      end
      @equations begin
          # Trasformo l'equazione integrale dell'induttanza in una
          # differenziale che ne modella la variazione.
          D(I) ~ - ((Il - Ia) / V_FRC) * i
          # Ia <= I <= Il
          # d/dt (i(t)) = 1 / L * v(t), equazione dell'induttore
          D(i) ~ (1 / (min(Il, max(Ia, I)))) * v
         end
  end
#+end_src

* 30.10.23                                                       :Componenti:
In realtà non sono ancora totalmente convinto dalle soluzioni che ho
trovato in questi giorni e che riguardano la resistenza variabile.
Questo perché l'equazione caratteristica non è mai comparsa.  Voglio
presentare a Chiara due soluzioni:
- Quella più corretta dal punto di vista matematico, con le equazioni
  riprese dal paper cartaceo da lei fornitomi.
  #+begin_src julia
    @mtkmodel VariableResistor begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ra,    [description = "Resistance when air-filled"]
            Rl,    [description = "Resistance when liquid-filled"]
            V_FRC, [description = "Airway Volume at FRC"]
        end
        @variables begin
            # Dopo l'uguale ho i valori di inizializzazione delle
            # variabili.
            ∫i(t) = 0, [description = "Current integral"]
            # Dichiaro come variabile d'interesse anche la resistenza.
            R(t) = Rl, [description = "Variable resistance"]
        end
        @equations begin
            # Ho trasformato l'equazione integrale della resistenza in una
            # differenziale. La notazione `∫i` indica il nome di una
            # variabile che rappresenta l'integrale della corrente.
            D(∫i) ~ i
            # Ra <= R <= Rl: suppongo che i valori Ra ed Rl siano estremi da non superare.
            R ~ min(Rl, max(Ra, (Ra + (Rl - Ra) * (1 - ∫i / V_FRC))))
            # R ~ Ra + (Rl - Ra) * (1 - ∫i / V_FRC) # --> non funziona in
            # questa forma.
            # Legge di Ohm per legare la corrente alla
            # tensione sulla resistenza.
            v ~ R * i
        end
    end
  #+end_src
  Fornisco delle immagini raffiguranti grafici delle simulazioni del
  componente (queste hanno nel titolo `*_not_approx`).
  
- Quella meno rigorosa dal punto di vista matematico (con però una
  forma d'onda migliore).

  #+begin_src julia
    @mtkmodel VariableResistor begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ra, [description = "Resistance when air-filled"]
            Rl, [description = "Resistance when liquid-filled"]
            V_FRC, [description = "Airway Volume at FRC"]
        end
        @variables begin
            # Creo una variabile temporanea perché non riesco a salvare la
            # variabile "in place".
            # Dopo l'uguale ho i valori di inizializzazione delle
            # variabili.
            Rtemp(t) = Rl, [description = "Temporary resistance"]
            R(t) = Rl, [description = "Variable resistance"]
        end
        @equations begin
            # Facendo la derivata della resistenza ottengo questo:
            D(Rtemp) ~ - ((Rl - Ra) / V_FRC) * i
            # Ra <= R <= Rl
            # Limito la resistenza tra i due valori estremi.
            R ~ min(Rl, max(Ra, Rtemp))
            v ~ R * i
        end
    end
  #+end_src

  Fornisco delle immagini raffiguranti grafici delle simulazioni del
  componente (queste hanno nel titolo `*_approx`).

Per me la soluzione approssimata potrebbe essere migliore in quanto le
forme d'onda sono continue.

Un altro problema che ho è quello di non sapere quanto valga
l'ampiezza dell'onda quadra che si vuole utilizzare nelle simulazioni,
per cui mando più grafici.

* 31.10.23                                                          :Modello:
Chiara ha risposto dicendo che il componente si comporta come
dovrebbe, quindi inizio ad abbozzare il modello della sottorete.

Mi è stato chiesto di farlo prima con resistenze e condensatori fissi
e poi le rendo variabili in un altro test.

|                 |          IAD |          IAE |          IAF |          IAG |          IAH |          IAI |          IBL |          IBA |          IBB |
|-----------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------|
| Tipo            |       Airway |     Alveolus |       Airway |     Alveolus |       Airway |     Alveolus |       Airway |     Alveolus |     Alveolus |
| Ra              | 3.100029e+01 | 3.109214e+02 | 2.231464e+01 | 4.012746e+02 | 3.554331e+01 | 4.759710e+02 | 3.097440e+01 | 2.017423e+02 | 2.282920e+02 |
| Rb              | 1.514023e+03 | 1.518509e+04 | 1.089824e+03 | 1.959785e+04 | 1.735899e+03 | 2.324594e+04 | 1.512758e+03 | 9.852891e+03 | 1.114955e+04 |
| La              | 1.852803e-03 | 6.440085e-03 | 1.166141e-03 | 6.908560e-03 | 1.653093e-03 | 7.229610e-03 | 1.290849e-03 | 5.687354e-03 | 5.896531e-03 |
| Lb              | 1.664949e+00 | 5.718839e+00 | 1.047907e+00 | 6.134848e+00 | 1.485488e+00 | 6.419942e+00 | 1.159971e+00 | 5.050408e+00 | 5.236159e+00 |
| Ccap (C_g)       | 1.689219e-09 | 2.462271e-07 | 8.128360e-10 | 2.461359e-07 | 9.126539e-10 | 2.460874e-07 | 5.722034e-10 | 2.464514e-07 | 2.463766e-07 |
| Rti             |            - |         1200 |            - |         1200 |            - |         1200 |            - |         1200 |         1200 |
| Lti             |            - | 5.795540e-04 |            - | 5.795540e-04 |            - | 5.795540e-04 |            - | 5.795540e-04 | 5.795540e-04 |
| Cti             |            - | 2.400000e-05 |            - | 2.400000e-05 |            - | 2.400000e-05 |            - | 2.400000e-05 | 2.400000e-05 |
| Rs              |            - |        80000 |            - |        80000 |            - |        80000 |            - |        80000 |        80000 |
| Cs              |            - | 2.100000e-05 |            - | 2.100000e-05 |            - | 2.100000e-05 |            - | 2.100000e-05 | 2.100000e-05 |
| Rws             | 4.186147e+06 |            - | 9.257208e+06 |            - | 8.703449e+06 |            - | 1.461035e+07 |            - |            - |
| Lws             | 3.705082e-01 |            - | 7.164089e-01 |            - | 5.994469e-01 |            - | 9.016810e-01 |            - |            - |
| Cws             | 3.503620e-10 |            - | 1.584351e-10 |            - | 1.685156e-10 |            - | 1.003855e-10 |            - |            - |
| Chargeth (V_FRC) | 1.744963e-06 | 3.642283e-07 | 8.396596e-07 | 2.699475e-07 | 9.427715e-07 | 2.198790e-07 | 5.910861e-07 | 5.958497e-07 | 5.185713e-07 |
| Vin_th           | 4.666378e+00 | 7.926677e+00 | 4.990351e+00 | 8.694383e+00 | 5.289833e+00 | 9.256451e+00 | 5.588244e+00 | 6.794462e+00 | 7.098371e+00 |
| Vgravity        |            0 |            0 |            0 |            0 |            0 |            0 |            0 |            0 |            0 |
| STATUS          |           OK |           OK |           OK |           OK |           OK |           OK |           OK |           OK |           OK |

Tutti i componenti instanziati nel modello sottostanti sono stati
ricontrollati con la precedente tabella riassuntiva.  Noto che alcuni
valori si ripetono ({R, L, C}ti, {R, C}s).

#+begin_src julia
  # Dichiaro la struttura circuitale (i.e. serie tra il generatore e la resistenza variabile).
  @mtkmodel System begin
      @components begin
          # Sorgenti del segnale e ground
          gen = Square(frequency = 0.5, amplitude = 1.0e-3, smooth = true)
          source = Voltage()
          ground = Ground()

          # IAD
          # Per ora ignoro questa parte.
          # Chargeth= 1.744963e-06 # -- V_FRC
          # Vin_th= 4.666378e+00 # -- tensione su primo diodo
          # Vgravity= 0
          IAD = Airway(
              r_tube.R = (3.100029e+01 + 1.514023e+03) / 2,
              i_tube.L = (1.852803e-03 + 1.664949e+00) / 2,
              c_g.C    = 1.689219e-09,
              r_sw.R   = 4.186147e+06,
              i_sw.L   = 3.705082e-01,
              c_sw.C   = 3.503620e-10,
              r_tube_1.R = (3.100029e+01 + 1.514023e+03) / 2,
              i_tube_1.L = (1.852803e-03 + 1.664949e+00) / 2
          )

          # IAE
          # Chargeth= 3.642283e-07 
          # Vin_th= 7.926677e+00 
          # Vgravity= 0 
          IAE = Alveolus(
              r_tube.R = 3.109214e+02 + 1.518509e+04,
              i_tube.L = 6.440085e-03 + 5.718839e+00,
              c_ga.C   = 2.462271e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IAF
          # Per ora ignoro questa parte.
          # Chargeth= 8.396596e-07
          # Vin_th= 4.990351e+00
          # Vgravity= 0 
          IAF = Airway(
              r_tube.R = (2.231464e+01 + 1.089824e+03) / 2,
              i_tube.L = (1.166141e-03 + 1.047907e+00) / 2,
              c_g.C    = 8.128360e-10,
              r_sw.R   = 9.257208e+06,
              i_sw.L   = 7.164089e-01,
              c_sw.C   = 1.584351e-10,
              r_tube_1.R = (2.231464e+01 + 1.089824e+03) / 2,
              i_tube_1.L = (2.231464e+01 + 1.089824e+03) / 2
          )

          # IAG
          # Chargeth= 2.699475e-07
          # Vin_th= 8.694383e+00
          # Vgravity= 0 
          IAG = Alveolus(
              r_tube.R = 4.012746e+02 + 1.959785e+04,
              i_tube.L = 6.908560e-03 + 6.134848e+00,
              c_ga.C   = 2.461359e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IAH
          # Per ora ignoro questa parte.
          # Chargeth= 9.427715e-07
          # Vin_th= 5.289833e+00
          # Vgravity= 0
          IAH = Airway(
              r_tube.R = (3.554331e+01 + 1.735899e+03) / 2,
              i_tube.L = (1.653093e-03 + 1.485488e+00) / 2,
              c_g.C    = 9.126539e-10,
              r_sw.R   = 8.703449e+06,
              i_sw.L   = 5.994469e-01,
              c_sw.C   = 1.685156e-10,
              r_tube_1.R = (3.554331e+01 + 1.735899e+03) / 2,
              i_tube_1.L = (1.653093e-03 + 1.485488e+00) / 2
          )

          # IAI
          # Chargeth= 2.198790e-07
          # Vin_th= 9.256451e+00
          # Vgravity= 0
          IAI = Alveolus(
              r_tube.R = 4.759710e+02 + 2.324594e+04,
              i_tube.L = 7.229610e-03 + 6.419942e+00,
              c_ga.C   = 2.460874e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IBL
          # Per ora ignoro questa parte.
          # Chargeth= 5.910861e-07 
          # Vin_th= 5.588244e+00 
          # Vgravity= 0
          IBL = Airway(
              r_tube.R = (3.097440e+01 + 1.512758e+03) / 2,
              i_tube.L = (1.290849e-03 + 1.159971e+00) / 2,
              c_g.C    = 5.722034e-10,
              r_sw.R   = 1.461035e+07,
              i_sw.L   = 9.016810e-01,
              c_sw.C   = 1.003855e-10,
              r_tube_1.R = (3.097440e+01 + 1.512758e+03) / 2,
              i_tube_1.L = (1.290849e-03 + 1.159971e+00) / 2
          )

          # IBA
          # Chargeth= 5.958497e-07 
          # Vin_th= 6.794462e+00 
          # Vgravity= 0 
          IBA = Alveolus(
              r_tube.R = 2.017423e+02 + 9.852891e+03,
              i_tube.L = 5.687354e-03 + 5.050408e+00,
              c_ga.C   = 2.464514e-07,
              r_t.R    = 1200 ,
              i_t.L    = 5.795540e-04 ,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000 ,
              c_s.C    = 2.100000e-05
          )

          # IBB        
          # Chargeth= 5.185713e-07
          # Vin_th= 7.098371e+00
          # Vgravity= 0
          IBB = Alveolus(
              r_tube.R = 2.282920e+02 + 1.114955e+04,
              i_tube.L = 5.896531e-03 + 5.236159e+00,
              c_ga.C   = 2.463766e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )
      end

      @equations begin
          connect(gen.output, source.V)
          connect(source.p, IAD.in)
          connect(IAD.out, IAE.in, IAF.in)
          connect(IAF.out, IAH.in, IAG.in)
          connect(IAH.out, IBL.in, IAI.in)
          connect(IBL.out, IBA.in, IBB.in)
          connect(source.n, ground.g)
      end
  end
#+end_src

Noto che vi erano degli errori nella definizione della capacità `c_s`
nel modello alveolare.  Questi sono stati sistemati in `[[file:src/test/test8.jl][test8.jl]]`.

Ho sistemato il modello di stamattina isolando il parametri del
sistema per rendere il tutto maggiormente modificabile. (si veda
`[[file:src/test/test9.jl][test9.jl]]`).

** DONE Capire come graficare meglio i risultati
** DONE Implementare il modello con componenti variabili.          :Modello:

* 01.11.23                                                       :Componenti:
Implemento il diodo in Julia rimanipolando del codice trovato online
il 27.10.

#+begin_src julia
  function Diode(;name, Ids=1e-6, Vt=0.04, max_exp=15, R=1e8)
      @named oneport = OnePort()
      @unpack v, i = oneport
      pars = @parameters Ids=Ids Vt=Vt max_exp=max_exp R=R
      eqs = [i ~ Ids*(exlin(v/Vt, max_exp) - 1) + (v/R)]
      extend(ODESystem(eqs, t, [], pars; name=name), oneport)
  end

  exlin(x, max_x) = ifelse(x > max_x, exp(max_x)*(1 + x - max_x), exp(x))

  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          # Parametri che costituiscono il componente.
          Ids, [description = "Current flowing in the component"]
          Vt, [description = "Threshold"]
          max_exp
          R
      end
      @equations begin
          i ~ Ids * (exlin(v / Vt, max_exp) - 1) + (v / R)
      end
  end

  function Diode(::Ideal; name)
      @named(p = Pin()); @named(n = Pin())
      @variables v(t) i(t)
      eqs = [
          v ~ p.v - n.v #Convenience
          0 ~ p.i + n.i #in = -out
          i ~ p.i #Positive current flows *into* p terminal
          0 ~ IfElse.ifelse(v<0, i, v)
      ]

      ODESystem(eqs, t, [v, i], [], systems=[p, n], defaults=Dict(), name=name)
  end

  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          # Parametri che costituiscono il componente.
          V_th, [description = "Resistance when liquid-filled"]
      end
      @equations begin
          0 ~ ifelse(v < v_th, i, v - v_th)
      end
  end

#+end_src

Ho provato un po' di alternative ma nessuna di queste è valida per il
mio utilizzo.  Ho migliorato la leggibilità del codice di `[[file:src/test/test9.jl][test9.jl]]`.

* 02.11.23
** DONE Mostro `[[file:src/test/test9.jl][test9.jl]]` ed il grafico risultante.
Ok, va bene ma vedi sotto.

** DONE Domande da fare
- Per ora non riesco ad implementare un diodo.  Volevo chiedere quale
  equazione caratteristica posso utilizzare per implementarlo e come
  devo interpertare il valore `v_th` dei vari blocchi.
Il diodo compare solo nell'interfaccia aria/acqua. quando ho solo aria
o solo acqua questo non c'è.
- Il modello con componenti variabili deve considerare solo resistenze
  `Rtube` o anche altri componenti variabili?  Anche Ltube.
- Il modello di via respiratoria deve considerare solo `Rtube` come
  variabile, non `Rtube1`, giusto?
Le resistenze devono essere uguali, quindi variabile.

** DONE Implementare il modello con componenti variabili
** Colloquio con Chiara                                       :Suggerimenti:
L'integrale nella via aerea "media" (quindi via respiratoria ed
alveolo) non deve essere effettuato dall'inizio della simulazione ma
da quando arriva l'aria all'interno della via aerea.  Ho bisogno di
trovare un modo per passare una variabile da un modulo all'altro
(passerei l'integrale della corrente nel precedente modulo?).

** DONE Vedi come posso passare una variabile da un modulo all'altro :Componenti:
** DONE Modificare l'onda quadra così che abbia 40ns di rise e 400ns di HIGH.

* 03.11.23                                                 :Input:Componenti:
Inizierei considerando il problema più semplice: l'onda quadra.  Leggo
la sua implementazione per capire da quali parametri dipende.

Guardando in `.../Blocks/sources.jl`, noto delle funzioni
differenziabili per evitare il fenomeno di Gibbs.  L'equazione di
`Square` viene modificata dal parametro `smooth=true`.  In
particolare, se lo eguaglio ad un valore numerico, questo diventa lo
smoothing factor dell'onda quadra.

Cosa s'intende per smoothing factor?  Lo scoprirò empiricamente.  È
legato alla pendenza dell'onda quadra, la cui implementazione
"smoothed" è un'artan(x) (vedi `[[file:src/test/test11.jl][test11.jl]]`).

Mi dedico ora al diodo.  Credo che spostando la variabile `∫i` nei
modelli ad alto livello (i.e. `Airway` e `Alveolus`) dovrei avere modo
di calcolarla una volta sola e poi sfruttarla in ciascun componente.
Altre due variabili potrebbero essere interessanti da implementare:
trigger_in e trigger_out. La prima indica lo stato di riempimento della
via aerea in input a quella del modulo.  La seconda indica lo stato di
riempimento della via aerea del modulo corrente.  L'integrale della
corrente deve essere valutato a partire dal momento in cui arriva
l'aria nella via aerea corrente, quindi ipotizzo che lo stato di
`trigger_in` sarà true mentre quello di `trigger_out` sarà `false`.  Lo
stato sarà mantenuto fino a quando l'integrale sarà uguale a `V_FRC`,
valore che rappresenta il volume massimo.  Quando `∫i / V_FRC = 1`,
cambio stato: trigger_in = 1, trigger_out = 1.

| trigger_in | trigger_out | stato      | integrazione     |
|-----------+------------+------------+------------------|
| false     | false      | Full water | no --> D(∫i) = 0 |
| false     | true       | ---        | ---              |
| true      | false      | Interface  | sì --> D(∫i) = i |
| true      | true       | Full air   | no --> D(∫i) = 0 |

#+begin_src julia
  # Nel modulo gestisco solo trigger_out.
  trigger_out = ifelse(∫i / V_FRC >= 1,
                       true,
                       false)
  # Integro solo quando sono nello stato "interface"
  D(∫i) = ifelse(trigger_in == true && trigger_out == false,
                 0,
                 i)
#+end_src

La variabile `∫i` dovrà esistere anche nei componenti variabili per
interagire con quella del modello ad alto livello.  Devo quindi
effettuare una connessione alto-basso livello.

#+begin_src julia
  r_tube.v.∫i   = ∫i
  i_tube.v.∫i   = ∫i
  r_tube_1.v.∫i = ∫i
  i_tube_1.v.∫i = ∫i
#+end_src

Devo riscrivere la configurazione dei parametri che non avrà più
sdoppiata la V_FRC.

* 04.11.23                                          :Modello:Parametri:Input:
Voglio semplificare la gestione dei parametri di sistema, in quanto vi
sono molti duplicati delle stesse variabili/parametri.

Ho scritto un semplice codice di prova per testare l'isolamento dei
parametri in un modello ad alto livello.

#+begin_src julia
  @mtkmodel System begin
      @parameters begin
          A
          R
          C
      end
      @components begin
          # Sorgenti del segnale e ground.
          gen = Square(amplitude = A,
                       frequency = 0.1,
                       smooth    = 1.0e-3)
          source = Voltage()
          ground = Ground()
          R1 = Resistor(R = R)
          C1 = Capacitor(C = C)
      end
      @equations begin
          connect(gen.output, source.V)
          connect(source.p, R1.p)
          connect(R1.n, C1.p)
          connect(C1.n, source.n, ground.g)
      end
  end

  # Istanzio il modello (parametri esclusi).
  @mtkbuild system = System()

  sys_ps = [
      system.A => 2
      system.R => 4.0
      system.C => 1.0e-1
  ]

#+end_src

- Alcuni parametri devono necessariamente essere scritti all'interno
  della funzione che genera quel componente (e.g. `frequency` e
  `smooth` per `Square()`).
- I nomi dei parametri nel modello superiore (alias per "ad alto
  livello") possono essere gli stessi di quelli dei modelli inferiori,
  senza interferire tra loro.

* 04.11.23                                          :Modello:Parametri:Input:
Ieri pomeriggio ho provato ad implementare un parametro ereditabile
all'interno del modello superiore ma a quanto pare non ha funzionato:
i parametri inferiori devono comunque essere inizializzati in qualche
modo.

Sto leggendo la documentazione di `ModelingToolkit.jl` per capirne
meglio il funzionamento, dato che molte delle cose che vorrei
implementare dipendono da ciò.

** TODO [#C] Associare unità di misura e input/output alle variabili :Componenti:

Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/ContextualVariables/#Variable-metadata][`Variable Metadata`]].
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Variable_metadata/#Input-or-output][`Input or output`]].

#+begin_src julia
  # Per esempio questo
  @variables x[1:2, 1:2] [connect = Flow; unit = u"m^3/s"]
#+end_src

** TODO [#C] Aiutare il futuro sviluppatore del sistema mediante `getdescription(var)` :Futuro:Manuale:
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Variable_metadata/#Variable-descriptions][`Variables descriptions`]].  Inserire nella documentazione finale.

** DONE [#B] Leggere manuale di `ModelingToolkit`               :Julia:Must:
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#components][`Composing Models and Building Reusable Components`]].
- [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#Numerics-with-Composed-Models][`Numerics with Composed Models`]] tratta di come estrarre le serie
  temporali dalla soluzione del sistema.

#+begin_src julia
  sol[x,1:5] # Dove x è variabile, 1..5 è l'intervallo d'interesse
#+end_src

- [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#Variable-scope-and-parameter-expressions][`Variable scope and parameter expressions`]] tratta di come
  condividere i parametri appartenenti a sistemi a diversi livelli.
  (Per "comporre" i livelli, il codice d'esempio utilizza `\circ`).
  Esiste una funzione `ParentScope()` che dovrebbe permettere di avere
  la visibilità dei parametri del modello superiore ma per ora non
  funziona correttamente.

Leggi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/MTKModel_Connector/#mtkmodel_connector][`Components and Connectors`]]: Include le informazioni essenziali
sulla gestione dei modelli costituiti da componenti.

* 05.11.23
** DONE Dubbi sulle unità di misura                       :Domande:Risposte:
Le unità di misura di ciascuna variabile devono essere quelle
elettriche oppure quelle meccaniche?  R: Quelle elettriche

* 07.11.23                                            :Bash:Input:Repository:
** Conversione dati di input                             :Conversione:Input:
Sto lavorando su uno script per effettuare una conversione dei dati
contenuti in `Albero.cir` in un formato che sia leggibile dal main di
Julia.

L'idea sarebbe quella di convertire ciascuna riga nella dichiarazione
del componente superiore dell'apposito tipo.
*** DONE I parametri `C_g` e `C_ga` verranno chiamati entrambi `C_g` :Conversione:Parametri:
** Sistemazione del tree della repository              :Pulizia:Repository:
I file sorgenti erano troppo caotici nella directory, quindi ho deciso
di creare delle posizioni più sensate.

* 08.11.23
** DONE Sistemare nome parametri per corrispondere a quelli di `cir2jl` :Parametri:Julia:
C'è un problema che devo risolvere, ossia che il file del modello che
voglio importare è troppo grande per essere importato da Julia...

** DONE [#A] Come posso importare un così gran numero di dati?    :Problema:
* 09.11.23                                                       :Componenti:
Il problema della gestione dell'input di 50k moduli è da risolversi
suddividendo, per forza di cose, in sottoreti minori.  Fosse esso
gestibile da diversi threads sarebbe ancora meglio.

Come potrei gestire queste sottoreti?

Ho parlato con Chiara: mi ha fornito dell'albero completo senza {R, C,
I}_sw per capire se lo StackOverflowError si può risolvere.  Devo per
forza di cose ora ritornare al problema del diodo, di `trigger_out` e
`trigger_in`.  Dice inoltre che si possono utilizzare le unità
elettriche per il nostro modello e non quelle fisiche/meccaniche.

** DONE Sistemare lo script per includere anche i trigger{in, out}    :Bash:
L'ho fatto in treno.  Basta un `echo` ed un `sed`.

* 10.11.23                                                       :Componenti:
Ho sistemato lo script e il `main.jl` così da calcolare l'integrale
della corrente a partire da quando arriva il flusso.  Ho aggiunto
`src/util/graphs_trigger.jl`: crea i grafici di quello che avviene a
livello di `trigger_in`, `trigger_out` e integrale della corrente nei
vari moduli.

** DONE Convenzioni delle correnti                                 :Domande:
La corrente negativa indica una corrente entrante nella via aerea?
contrario.  Risposta completa nei giorni seguenti.

* 13.11.23                                                 :Componenti:Input:
** DONE Segno dell' integrale di corrente                 :Domande:Proposta:
Ho dei dubbi relativi all'integrale della corrente.  Se questo deve
modificare i componenti variabili, non avrebbe senso andare ad
utilizzare solamente la corrente entrante nell'integrale?  Il grafico
che ho generato mostra chiaramente che, nel momento in cui la flag
`trigger_in = 1` e `trigger_out = 0`, il sistema continuerà a valutare
l'integrale di corrente per quel particolare modulo.  Si noti però
che, ad esempio, IBL ha un andamento oscillatorio ma raggiunge anche
dei livelli negativi di integrale.  Penso si possa utilizzare anche
un'opzione `bounds` delle variabili di ModelingToolkit, applicata alla
variabile integrale.  Dalla documentazione, l'utilizzo di questo
metadato è utile solo al tuning dei parametri, quindi non me ne faccio
nulla.

Ho provato anche una soluzione di questo tipo:
#+begin_src julia
  @equations begin
      0 ~ ifelse(∫i > 0,
                 D(∫i) - trigger_in * (1.0 - trigger_out) * in.i,
                 ∫i)
  end
#+end_src

I controlli nei componenti variabili dovrebbero limitare i valori di
resistenza ed induttanza nel seguente modo:

#+begin_src julia
  @equations begin
      # Ra <= R <= Rl: suppongo che i valori Ra ed Rl siano estremi da
      # non superare.
      R ~ min((Ra + Rb), max(Ra, (Ra + Rb * (1 - ∫i / V_FRC))))
      v ~ R * i
  end
#+end_src

La risposta è che non è fattibile perchè poi vogliamo che l'integrale
vari quando ho solo aria.

** DONE Devo valutare il comportamento in presenza di una tensione costante :Input:Componenti:
Ho riscontrato un problema relativo a `MaxIters`, il massimo numero di
iterazioni e ho risolto andando a modificare la tolleranza, rendendo
la soluzione più approssimata.
* 14.11.23                                                       :Repository:
Devo mostrare i risultati a tensione costante a Chiara.
** Package management
Quali sono le guidelines per scrivere codice in julia correttamente?
Il pacchetto julia `Pkg`, già preinstallato, crea in automatico due
file toml: `Manifest.toml` e `Project.toml`. Si veda la [[https://docs.julialang.org/en/v1/stdlib/Pkg/][documentazione]]
di Pkg.

* 15.11.23
** Risultati test con step function (alias tensione costante) :Input:Variabili:
I risultati mostrati ieri sono abbastanza coerenti con quello che ci
si aspetta ma alcuni versi delle correnti e picchi non convincono.  Ho
voluto "smussare" la tensione costante che stavo fornendo in quanto
credevo fosse il solito fenomeno di Gibbs, così ho sistemato il picco.
Per quanto riguarda le correnti e i loro versi è bastato prendere come
riferimento un componente e non il nodo d'uscita.
** Convenzione correnti                                           :Risposte:
Se la corrente è positiva, allora è anche entrante (viceversa).

** Segno dell'integrale di corrente                               :Risposte:
La risposta è che non è fattibile perchè poi vogliamo che l'integrale
vari quando ho solo aria.

** DONE Diodo                                    :Proposta:Domande:Risposte:
La soluzione per il diodo è stata trovata sul [[https://discourse.julialang.org/t/diode-model-not-working-as-expected-with-modelingtoolkit/95125/2][forum online]].
#+begin_src julia
  exlin(x, max_x) = ifelse(x > max_x, exp(max_x)*(1 + x - max_x), exp(x))
  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ids     = 1e-6,
          [description = "Reverse-bias current"]
          Vt      = 0.04,
          [description = "Threshold in voltage"]
          max_exp = 15,
          [description = "Value after which linearization is applied"]
          R       = 1e8,
          [description = "Diode Resistance"]
      end
      @equations begin
          i ~ Ids * (exlin(v / Vt, max_exp) - 1) + (v / R)
      end
  end
#+end_src

Basterebbe quindi rimaneggiare questa forma per poter usufruire del
componente.  Dovrei renderlo dipendente dall'integrale di corrente
della via aerea e, a denominatore dell'esponenziale cosa dovrebbe
esserci?  Qual è il ruolo di `Vin_th`? Solo la "disabilitazione" del
diodo oppure svolge un ruolo all'interno del diodo?

Creo del codice di test per il diodo.
#+begin_src julia
    using ModelingToolkit
    using ModelingToolkitStandardLibrary.Blocks
    using ModelingToolkitStandardLibrary.Electrical
    using OrdinaryDiffEq
    using Plots

    @parameters t

    exlin(x, max_x) = ifelse(x > max_x,
                             exp(max_x)*(1 + x - max_x),
                             exp(x))
    @mtkmodel Diode begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ids     = 1e-6,
            [description = "Reverse-bias current"]
            Vt      = 0.04,
            [description = "Threshold in voltage"]
            max_exp = 15,
            [description = "Value after which linearization is applied"]
            R       = 1e8,
            [description = "Diode Resistance"]
        end
        @equations begin
            i ~ Ids * (exlin(v / Vt, max_exp) - 1) + (v / R)
        end
    end

    @mtkmodel System begin
        @components begin
            V = Voltage()
            D = Diode()
            R = Resistor(R = 100)
            Gnd = Ground()
        end
        @equations begin
            V.V.u ~ 15 * sin(2*π*50*t)
            connect(V.p, D.p)
            connect(D.n, R.p)
            connect(V.n, R.n, Gnd.g)
        end
    end

  @mtkbuild system = System()
  prob = ODEProblem(system, Pair[], (0/50, 1/50), saveat=1/50e2);
  sol = solve(prob, Rodas4(), dtmax = 1.0e-3);

#+end_src

`Vin_th` rappresenta la soglia in tensione che esercita il diodo.  Ciò
significa che il parametro `Vt` del diodo sarà da essere modificato in
ogni componente.  L'esclusione del diodo la si effettua quando
`trigger_in = 1` e `trigger_out = 0` (situazione di interfaccia
aria-acqua).

* 16.11.23
** Diodo di Shockley                                                :Teoria:
Il diodo si comporta come dovrebbe ma devo capire ora come gestire al
meglio i vari parametri.  Per poterlo fare devo innanzitutto sapere a
cosa si riferiscono tali parametri però, per cui mi riferisco alla
pagina wiki del [[https://it.wikipedia.org/wiki/Equazione_del_diodo_ideale_di_Shockley][diodo ideale di Shockley]].

\begin{equation}
i_D = I_s\cdot \left(e^{\frac{v_D}{\eta v_T}} - 1\right)
\end{equation}

- Vt :: tensione termica
- Vd :: tensione applicata ai capi
- \eta :: fattore di idealità (dipendente dal materiale)

** Diodo                                                            :Teoria:
Riporto l'equazione del [[https://it.wikipedia.org/wiki/Diodo#Diodo_ideale][diodo ideale]].  Il mio scopo è quello di
implementare questa soluzione ma per ora ho solo trovato online del
materiale per la precedente.

\begin{equation}
I = I_0 \cdot e^{\frac{V_D}{V_T}}
\end{equation}

I parametri sono i medesimi, considerato I_0 = I_s.  La vera domanda è
se esiste un modo per determinare inserire il valore di tensione di
soglia (e.g. 0.6, 0.7V dei diodi visti ad Elettronica) all'interno
dell'equazione caratteristica, dato che la tensione termica
sembrerebbe essere diversa da questa.

- Tensione di soglia (V_s, V_{th}) :: la minima differenza di potenziale
  applicabile tra gate e source del transistore per formare il canale;
  nei diodi è la minima tensione necessaria per attivare la conduzione
  in polarizzazione diretta. [[[https://it.wikipedia.org/wiki/Tensione_di_soglia][Wikipedia]]]
- Tensione termica (V_T, in engl. "Thermal voltage") :: è definita come
  $V_T = \frac{k_B T}{q}$ Dove:
  - k_B :: Costante di Boltzmann [J K^{-1}]
  - T :: Temperatura [K]
  - q :: Carica dell'elettrone [C]
  In `Modia.jl` viene descritta nel seguente modo:
  #+begin_quote
  Voltage equivalent of temperature
  #+end_quote


  In condizioni fisiologiche: $V_T \approx 26.7 mV$. [[[https://www.edutecnica.it/elettronica/diodo/diodo.htm][Fonte]]]

** Altre soluzioni                                :Componenti:Julia:Proposta:
Leggendo degli esempi di `Modia.jl`, ho trovato anche questa
formulazione che sembra interessante:
#+begin_src julia
  # Ideal diode
  IdealDiode = OnePort | Model(
      Ron   = 1e-5u"Ω",
      Goff  = 1e-5u"1/Ω",
      s = Var(start = 0.0),
      equations = :[              
          closed = positive(s)   # closed = s > 0  
          v = s*u"V"*(if closed; Ron*u"1/Ω" else 1         end)
          i = s*u"A"*(if closed; 1          else Goff*u"Ω" end)
      ]
  )
#+end_src

** Riflessioni                                           :Problema:Proposta:
Il modello di diodo deve fare in modo che, superata la tensione di
soglia, chiamata nel nostro problema `Vin_th`, la corrente `i_D` possa
scorrere e la tensione `V_D = Vin_th` ai capi.  Se la tensione misurata
dovesse essere inferiore alla soglia Vin_th, allora `i_D = 0` e la
tensione sul diodo (`V_D`) seguirà quella del generatore.

*** Misurazione e sovrascrittura della differenza di potenziale :Problema:Domande:Proposta:
Come faccio a gestire il fatto che devo sia misurare una differenza di
potenziale che imporla?  Potrei utilizzare il sensore di tensione
(i.e. VoltageSensor) presente nella libreria standard.

#+begin_src julia
  @mtkmodel VoltageSensor begin
      @components begin
          # Sfrutta due pin, positivo e negativo
          p = Pin()
          n = Pin()
      end
      @variables begin
          # L'unica variabile in uscita
          v(t)
      end
      @equations begin
          # Misura la tensione senza introdurre corrente
          p.i ~ 0
          n.i ~ 0
          v   ~ p.v - n.v
      end
  end
#+end_src
Segue una soluzione che vuole sfruttare questo componente. non resta
che testarla nel circuito diodo-resistenza.

#+begin_src julia
  @mtkmodel Diode begin
      @parameters begin
          Vin_th, [description = "Diode threshold"]
      end
      @extend v, i = oneport = OnePort()
      @components begin
          VS = VoltageSensor()
      end
      @equations begin
          connect(oneport.p, VS.p)
          connect(oneport.n, VS.n)
          v ~ (if VS.v >= Vin_th; 
                   Vin_th
               else
                   VS.v)
          i ~ (if VS.v < Vin_th;
                   0)
      end
  end
#+end_src

Non sono riuscito per ora ad instanziarlo.  I risultati sono riportati in `[[file:src/test/test13.jl][test13.jl]]`

* 17.11.23
** Diodo                                          :Componenti:Julia:Modello:
Esiste, nella libreria standard, anche un [[file:~/.julia/packages/ModelingToolkitStandardLibrary/sOsqv/src/Electrical/Analog/sensors.jl][sensore multiplo]] che
incorpora due sensori: uno di corrente ed uno di tensione.  Mi
riferisco a `MultiSensor`.  Potrei collegare i poli per la misurazione
della corrente al generatore di tensione e i poli per la misurazione
della tensione ai due rami del circuito, quello a monte del generatore
e quello a valle del resto del modulo.  Consulto ora come è fatto il
[[file:~/.julia/packages/ModelingToolkitStandardLibrary/sOsqv/src/Electrical/Analog/sources.jl][generatore di tensione]].  Devo ora capire esattamente quali sono i
valori delle tensioni e delle correnti del due poli del diodo.

| Stato       | Corrente_p | Corrente_n | Tensione_p | Tensione_n |
|-------------+-----------+-----------+-----------+-----------|
| VS.v >= V_th | CS.i      | CS.i      | V_th       | V_th       |
| VS.v < V_th  | 0         | 0         | VS.v      | 0         |


#+begin_src julia
  #=
  Proverei ad implementare queste equazioni.
  p.i ~ n.i ~ CS.i
  p.v ~ VS.v
  n.v ~ V_th

  p.i ~ CS.i
  n.i ~ 0
  p.v ~ VS.v
  n.v ~ 0
  =#
  n.i ~ ifelse(VS.v >= V_th, CS.i, 0)
  n.v ~ ifelse(VS.v >= V_th, V_th, 0)
#+end_src

Se mettessi la differenza di tensione ai capi uguale a zero avrei un
corto circuito ma la tensione sul catodo seguirebbe l'andamento di
quella dell'anodo, non rimanendo fissa.  Sperimento il codice su
[[file:src/test/test14.jl][test14.jl]].  Il risultato sembrerebbe essere instabile.

*** Alternativa: `Modia.jl`
Guardando sulla libreria di `Modia.jl`, il diodo non è implementato se
non con una funzione commentata, la si veda nei giorni passati.

#+begin_src julia
  IdealDiode = OnePort | Model(
      Ron   = 1e-5u"Ω",
      Goff  = 1e-5u"1/Ω",
      s = Var(start = 0.0),
      equations = :[
          closed = positive(s)   # closed = s > 0
          v = s*u"V"*(if closed; Ron*u"1/Ω" else 1         end)
          i = s*u"A"*(if closed; 1          else Goff*u"Ω" end)
      ]
  )
#+end_src

Non si capisce molto la logica del componente.

* 20.11.23
** Albero                                   :Input:Proposta:Julia:Parametri:
L'altro giorno ho visto un [[https://www.youtube.com/watch?v=iwFMg-rCWNg][video]] che parlava di `DataFrames.jl`, un
pacchetto per la gestione di dati tabulari su Julia.  In particolare
si interfaccerebbe con uno standard open-source, Apache Arrow, che
renderebbe istantanea l'importazione dell'albero.  Esiste un [[https://www.youtube.com/watch?v=SXF4BawX-hs][guida
completa]] a `DataFrame.jl`, oltre alla documentazione sul [[https://dataframes.juliadata.org/stable/][sito
ufficiale]].

** Diodo
Penso sia meglio impostare un messaggio per discourse, così da trovare
una soluzione del diodo lì.

* 21.11.23
Creo una tabella con i dati della sottorete e provo ad importarli in
Julia.

#+begin_src CSV
Name,Type,Ra,Rb,La,Lb,C_g/C_ga,V_FRC,Vin_th,Rti/Rws,Lti/Lws,Cti/Cws,Rs,Cs,From
IAD,airway,3.100029e+01,1.514023e+03,1.852803e-03,1.664949e+00,1.689219e-09,1.744963e-06,4.666378e+00,4.186147e+06,3.705082e-01,3.503620e-10,,,
IAE,alveolus,3.109214e+02,1.518509e+04,6.440085e-03,5.718839e+00,2.462271e-07,3.642283e-07,7.926677e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IAD
IAF,airway,2.231464e+01,1.089824e+03,1.166141e-03,1.047907e+00,8.128360e-10,8.396596e-07,4.990351e+00,9.257208e+06,7.164089e-01,1.584351e-10,,,IAD
IAG,alveolus,4.012746e+02,1.959785e+04,6.908560e-03,6.134848e+00,2.461359e-07,2.699475e-07,8.694383e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IAF
IAH,airway,3.554331e+01,1.735899e+03,1.653093e-03,1.485488e+00,9.126539e-10,9.427715e-07,5.289833e+00,8.703449e+06,5.994469e-01,1.685156e-10,,,IAF
IAI,alveolus,4.759710e+02,2.324594e+04,7.229610e-03,6.419942e+00,2.460874e-07,2.198790e-07,9.256451e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IAH
IBL,airway,3.097440e+01,1.512758e+03,1.290849e-03,1.159971e+00,5.722034e-10,5.910861e-07,5.588244e+00,1.461035e+07,9.016810e-01,1.003855e-10,,,IAH
IBA,alveolus,2.017423e+02,9.852891e+03,5.687354e-03,5.050408e+00,2.464514e-07,5.958497e-07,6.794462e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IBL
IBB,alveolus,2.282920e+02,1.114955e+04,5.896531e-03,5.236159e+00,2.463766e-07,5.185713e-07,7.098371e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IBL
#+end_src

* 22.11.23
** Diodi, ruolo delle callbacks                :Componenti:Modello:Proposta:
Le Callbacks sarebbero d'aiuto nella fase di solving, sostituendo la
`transition` di Verilog, come documentato [[https://discourse.julialang.org/t/ideal-diode-mtk-callbacks-to-mimic-verilog-a-events/62528][qui]].

* 23.11.23
Il problema di queste callbacks è che si rifanno alla modalità senza
macro, precedente a quella utilizzata attualmente.  Dovrei quindi
capire se fosse possibile scrivere le callbacks pur mantenendo la
struttura del codice che ho già, senza quindi rifare di nuovo tutto.

** Test callbacks con sintassi obsoleta             :Modello:Julia:Proposta:
Testo sul solito circuito D-R con vecchia sintassi (si veda
`[[file:src/test/test14b.jl][test14b]]`).

La sintassi utilizzata nella [[file:~/.julia/packages/ModelingToolkitStandardLibrary/sOsqv/src/Electrical/Analog/ideal_components.jl][libreria standard dei componenti]].
Raccolgo le domande che sorgono durante la scrittura di questo
sorgente.  Dalla [[~/.julia/packages/ModelingToolkit/66mEN/docs/src/basics/Events.md][documentazione]] (in locale), sembrerebbe che la
necessità sia più quella di stabilire

* 24.11.23
** ModelingToolkitStandardLibrary (MSL)         :Modello:Julia:Bibliografia:
Riporto come risorsa il [[https://www.youtube.com/watch?v=7hF0JRznxNU][video]] di presentazione del nuovo formato di
coding.  Sulla repo di MSL sono presenti alcune [[https://github.com/SciML/ModelingToolkitStandardLibrary.jl/pull/166/commits/5d97d405ee66d7121a8facbe823425fd508f78a2][PR]] in cui degli utenti
hanno utilizzato anche la macro `@component` per definire la funzione
che descrive il componente.

* 27.11.23

#+begin_example
Greetings,

I am new to Julia Programming Language and I don't have any experience in writing to a community of programmers but I'll do my best to explain what my problem is.

I am trying to instantiate a lung model (an electrical) made out of two kinds of blocks: alveoli and airways.  Each of such blocks is constituted by Resistors, Capacitors, Inductors (all of which I have used MSL ones with success) and diode that I'm struggling to implement.
The syntax i used was the one considering the macros @mtkmodel and @mtkbuild.
I have tried to use Shockley Diode equation in the component and everything went fine with the simulation but i couldn't be able to modify its forward threshold 
[...]

I hope I was clear in explaining my problem.
#+end_example

Sembrerebbe che il problema del diodo sia risolto, vedi `[[file:src/test/test14c.jl][test14c.jl]]`

#+begin_src julia
  exlin(x, max_x) = ifelse(x > max_x,
                           exp(max_x)*(1 + x - max_x),
                           exp(x))
  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ids     = 1e-6,
          [description = "Reverse-bias current"]
          max_exp = 15,
          [description = "Value after which linearization is applied"]
          R       = 1e8,
          [description = "Diode Resistance"]
          Vth     = 1e-3,
          [description = "Threshold voltage"]
      end
      @equations begin
          i ~ Ids * (exlin((v - Vth) / (1e-3 * Vth), max_exp) - 1) + (v / R)
      end
  end

#+end_src

* 29.11.23
** DONE Diodo                                                     :Proposta:
Devo mostrare il modello del diodo a Chiara per capire se potrebbe
quello che cerchiamo.  Va tutto bene, anche la parte sullo switch che
abbiamo sotto.

** Switch                                         :Componenti:Modello:Julia:
L'idea è quella di passare le variabili trigger_in e trigger_out
provenienti dai rispettivi moduli (i.e. Airway e Alveolus).

#+begin_src julia
  @mtkmodel Switch begin
      @extend v, i = oneport = OnePort()
      @variables begin
          trigger_in,  [description = "Flag: 1 when air fills previous airway completely, 0 otherwise"]
          trigger_out, [description = "Flag: 1 when air fills current airway completely, 0 otherwise"]
      end
      @equations begin
          # Disabilito il diodo quando ho un completo riempimento di aria e di acqua
          # Riempimento con acqua  (trigger_in = 0, trigger_out = 0) --> v = 0 (corto)
          # Riempimento con aria   (trigger_in = 1, trigger_out = 1) --> v = 0 (corto)
          # Interfaccia aria/acqua (trigger_in = 1, trigger_out = 0) --> i = 0 (aperto)
          # Non possibile          (trigger_in = 0, trigger_out = 1) --> XXXXXXXXXXXXX
          0 ~ ifelse(trigger_in == 1,
                     ifelse(trigger_out == 1, v, i), v)
      end
  end
#+end_src

** DONE [#A] Instabilità della sottorete                          :Problema:
Il sistema (la sottorete) non è stabile.  Faccio una lista dei
possibili responsabili.

* 30.11.23
** Lista possibili cause instabilità
- `trigger_out` e `trigger_in` sono variabili binarie, quindi hanno un
  andamento simile a quello di uno scalino.  Inoltre non sono
  perfettamente stabili (mi riferisco a trigger_out).  Riscrivo il
  codice dello switch rendendolo dipendente dall'integrale di
  corrente.  Si veda `[[file:src/test/test16a.jl][test16a.jl]]`
- Lo switch ad un certo punto commuta istantaneamente.

* 01.12.23
Il funzionamento dello switch è stato testato con più valori di
integrale di corrente e in funzione del tempo.  Non avevo ancora
considerato che l'equazione caratteristica dell'interruttore introduce
una discontinuità del problema, così ho generato una curva più
smussata (si veda `[[file:src/test/test16b.jl][test16b.jl]]`).  Testandola risultano ancora dei
warnings relativi alla stabilità della soluzione, per cui ho risolto
solo in parte il problema.

* 03.12.23
** Modelingtoolkit                        :Domande:Problema:Julia:Callbacks:
Quello che vorrei fare sarebbe implementare un sistema modulare simile
a quello che ho ora ma introducendo le Callbacks.  Il problema che
sussiste è che la sintassi obsoleta non permette una modularità,
garantita invece dalla nuova.
- Come funzionano le callbacks?  [[file:~/.julia/packages/ModelingToolkit/66mEN/docs/src/basics/Composition.md][Questo documento]], nella sezione
  "Components with discontinuous dynamics", accenna a degli esempi di
  utilizzo. Consulto la documentazione di ModelingToolkit.  Ci sono
  alcuni esempi di utilizzo ma con la vecchia sintassi.  Conviene
  davvero riscrivere l'esempio del diodo, switch e resistenza con la
  vecchia sintassi.

* 04.12.23
Scrivo un esempio di messaggio per discourse.

#+begin_example
Greetings.

I am new to `ModelingToolkit` and, more generally, to Julia programming language. In particular, I am using it in my M.Sc. thesis project to model a morphometric lung model (i.e. an electrical equivalent of lung mechanical model taking account of its geometrical properties as well). I am using ModelingToolkit new format with `@mtkmodel` and `@mtkbuild` macros.

One of the problems I am tackling is modeling an ideal Diode Component.
#+end_example

Sono alla ricerca su discourse di informazioni utili.  [[https://discourse.julialang.org/t/mtk-simple-case-with-mtkmodel-and-standard-library-doesnt-work/104807][Questo thread]]
mostra come inizializzare input e output dei moduli.  [[https://discourse.julialang.org/t/tool-for-composable-circuit-simulation/103449][Questo thread]]
mostra come implementare un IdealSwitch con modeling toolkit sia con
vecchio che nuovo formato (in teoria sempre in situazioni stazionarie
ma guarda anche `ControlledSwitch`).

* 05.12.23
Esiste una documentazione di `ModelingToolkit` in fase beta che va ad
elencare le funzioni in fase di sviluppo, non ancora disponibili.
`RealInput` e `RealOutput` sono dedicate a segnali generici e non
rappresentativi di tensioni o correnti.  Ho testato anche
ControlledSwitch ma non funziona correttamente.

* 06.12.23
Devo mandare una mail a Chiara per aggiornarla sullo stato dei lavori.

#+begin_example
Ciao Chiara,
Ti aggiorno su quello che ho fatto negli ultimi giorni.
L'interruttore che avevo implementato, e che ti avevo mostrato l'ultima volta, per ora funziona solo mantenendo l'integrale di corrente in un range che lo tiene sempre aperto oppure sempre chiuso durante la simulazione.
Facendo variare l'integrale di corrente consentendo il superamento della soglia, la simulazione risulta essere instabile.
Ho provato quindi a modificarne l'equazione caratteristica per fare in modo che la transizione della corrente e della tensione fosse più dolce di quella data da uno scalino: ho utilizzato la tangente iperbolica per modulare la resistenza interna dello switch.
Questo mi ha permesso di avere una simulazione che dura un po' di più ma comunque in fase di risoluzione risulta instabile.
Ho scoperto però che si possono scrivere delle callbacks, eventi che si attivano a seguito di una condizione dettata da una o più equazioni definite dall'utente,
Queste callbacks possono essere inserite in fase di risoluzione e dovrebbero limitare, se non addirittura risolvere, l'instabilità del sistema.
Quest'ultima soluzione però non l'ho ancora considerata del tutto perché per me significherebbe necessariamente cestinare il codice che ho scritto in precedenza in quanto le callbacks non sono compatibili con le macro implementate nell'ultima versione di `ModelingToolkit`.
Posso però comunque provare a creare il solito circuito diodo-resistenza-switch utilizzando le callbacks, accertarmi se l'instabilità è risolta e poi agire di conseguenza.
In alternativa scriverei un messaggio sul forum della community di Julia per capire se hanno implementato o hanno intenzione di implementare le callbacks all'interno delle macro che ho già utilizzato.
Ti scrivo di quest'ultima alternativa perché `ModelingToolkit` mi sembra un progetto ancora in attivo sviluppo e ogni mese all'incirca rilasciano nuovi aggiornamenti con delle nuove funzionalità.

Mi dispiace di non essere venuto oggi in laboratorio per aggiornarti di persona ma purtroppo non mi sento bene.
A presto,
Luca
#+end_example

* 11.12.23
Considero il circuito switch-resistenza, riscritto utilizzando il
non-DSL (aka non Domain-Specific Language).  In un esempio, si
utilizza `RealInput` come componente per gestire il segnale da
controllare.

La sintassi per descrivere un componente è la seguente:
#+begin_src julia
  @component function Switch
      # Equazioni, collegamenti ecc.
  end
#+end_src

* 12.12.23
** Switch                                       :Componenti:Julia:Callbacks:
Per comprendere come dichiarare il componente devo prima comprendere
dove verrebbe locata la callback.

#+begin_src julia
  using ModelingToolkit, OrdinaryDiffEq, Plots
  function UnitMassWithFriction(k; name)
      @variables t x(t)=0 v(t)=0
      D = Differential(t)
      eqs = [D(x) ~ v
             D(v) ~ sin(t) - k * sign(v)]
      # Locazione in ODESystem
      ODESystem(eqs, t; continuous_events = [v ~ 0], name) # when v = 0 there is a discontinuity
  end
  @named m = UnitMassWithFriction(0.7)
  prob = ODEProblem(m, Pair[], (0, 10pi))
  sol = solve(prob, Tsit5())
  plot(sol)
#+end_src

Ora posso istanziare il componente `Switch`.

#+begin_src julia
  @component function ControlledSwitch(; name)
      @named n = Pin()
      @named p = Pin()
      @named u = RealInput()
      eqs = [ 0 ~ ifelse(u.u > 0.5, n.v - p.v, n.i)
              0 ~ ifelse(u.u > 0.5, n.i + p.i, p.i)
              ]
      ODESystem(eqs, t, [], []; name,
                systems=[p, n, u], continuous_events=[u.u ~ 0.5])
  end
#+end_src

Purtroppo non funziona neanche in questo modo dato che non riconosce
la variabile `u.u`.
* 13.12.23
Non riesco a scrivere la callback per il diodo.  Devo contattare gli
sviluppatori di `ModelingToolkit` per chiedere come potrei risolvere
il problema.

** DONE [#A] Contattare gli sviluppatori su discourse
*** Definizione del problema
È relativo all'instabilità del modello.  L'instabilità è dovuta
principalmente alla presenza di componenti che creano uno scalino,
vedi l'interruttore.

*** Alcuni test
- [ ] Comprendere se centrano il problema oppure no.
- [X] Cosa succederebbe se inserissi solamente il diodo di Shockley
  nel circuito e poi simulassi? Non funzionerebbe comunque

*** DONE Scrivere il messaggio e poi inoltrarlo a Chiara

** Colloquio con Chiara
Posso discutere sul forum del componente ma prima invio a lei per
capire se, in tal modo, non rivelo nulla dell'eventuale contenuto.

Posso provare a testare anche la funzionalità, ancora in via di
sviluppo, che utilizza gli if sui componenti.

* 14.12.23

#+begin_example
Buongiorno,

Sono nuovo nella community di Julia e di `ModelingToolkit`, in particolare.  Vorrei implementare un componente `DiodoIdeale` che venga rimpiazzato da un corto circuito quando la variabile di controllo (in particolare l'integrale della corrente che lo attraversa) raggiunge uno dei due valori di soglia (0 oppure `Vin_th`).  Inizialmente ho pensato di implementare un modello di diodo ideale semplice ed un modello di switch ideale controllato, realizzando poi un parallelo tra i due nel circuito finale.

Ho riscontrato alcune difficoltà:
- Il componente diodo ideale genera un errore di instabilità dovuto (probabilmente) al fronte di salita troppo ripido, per cui mi sono orientato su un diodo di Shockley.
- Lo switch ideale rimane chiuso, così da escludere il diodo, fino a quando la variabile controllata rimane a zero, quando la variabile diventa positiva, lo switch si apre per poi ritornare chiuso quando la variabile controllata raggiunge un valore `Vin_th`

Questi stratagemmi purtroppo non funzionano in fase di simulazione utilizzando il circuito completo.  Ho letto in alcuni threads che è possibile sfruttare delle Callbacks ma utilizzando le macro `@mtkmodel` ed `@mtkbuild` non ho ben chiaro dove posso inserirle e come scriverle.  Un'altra strada sarebbe quella di utilizzare i condizionali per escludere/includere il diodo nel circuito.  Volevo chiedere dei consigli per evitare di aggirare i problemi dovuti all'instabilità ed affrontarli direttamente.
Fornisco di seguito il codice dei componenti che ho scritto e delle istruzioni che ho utilizzato per la risoluzione.
#+end_example

#+begin_example
Greetings,

I am new to Julia community and, in particular, to the use of `ModelingToolkit` package.  I would like to implement an `IdealDiode` component to be replaced by a short circuit when the controlled variable (i.e. integral of the current flowing into the Diode) has reached one of the two thresholds (being either 0 or `Vin_th`).

Initially, i had thought of implementing a model for a simple ideal diode and a model of an ideal controlled switch. Such devices would be connected in parallel in the final circuit.

I had faced some difficulties:
- Ideal Diode returns instability (dt < dtmin) probably dued to the rising edge. This is why I have decided to go for a Shockley Diode.
- Ideal Switch works this way: if controlled variable is <= 0 or >= `Vin_th`, the switch is closed, so that the diode is excluded. The switch is otherwise open. I am getting the very same error.  I decided to introduce a `tanh` function in the current equation of such device in order to reduce this behavior.

These workarounds seem not to have worked when simulating, considering the full circuit.  In some Threads on Discourse and in the Documentation, I've read about Callbacks but I haven't understood how to write them properly and where to insert them in the DSL code and if there exist some macro helping in this process.  Should I drop the usage of new macros (i.e. @mtkmodel, @mtkbuild ...) for the old format in order to add Callbacks?

Another possibility could be to use conditionals, in order to include/exclude the IdealDiode in the circuit but i don't think this will solve instability, in the end.  I write here to ask some suggestion to avoid workarounds and for some help facing these problems directly.

This is the code i used for modeling.  Forgive my English, it's not my first language.  Thanks in advance for any feedback.

Used libraries

```julia
using ModelingToolkit
using ModelingToolkitStandardLibrary.Blocks
using ModelingToolkitStandardLibrary.Electrical
using OrdinaryDiffEq
using Plots
```

Diode

```julia
@mtkmodel Diode begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        threshold = 0, [description = "Voltage Threshold"]
    end
    @components begin
        input = RealInput()
    end
    @equations begin
        0 ~ ifelse(input.u > 0, v, i)
    end
end
```

ver. 2

```julia
exlin(x, max_x) = ifelse(x > max_x,
                         exp(max_x)*(1 + x - max_x),
                         exp(x))
@mtkmodel Diode begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        Ids     = 1e-6,
        [description = "Reverse-bias current"]
        max_exp = 15,
        [description = "Value after which linearization is applied"]
        R       = 1e8,
        [description = "Diode Resistance"]
        Vth     = 1e-3,
        [description = "Threshold voltage"]
        k       = 1e3,
        [description = "Speed of exponential"]
    end
    @equations begin
        i ~ Ids * (exlin(k * (v - Vth) / Vth, max_exp) - 1) + (v / R)
    end
end
```

Switch:

```julia
@mtkmodel Switch begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        V_FRC, [description = "Airway Volume at FRC"]
    end
    @variables begin
        ∫i(t) = 0, [description = "Current integral"]
    end
    @equations begin
        0 ~ ifelse(∫i / V_FRC <= 0, v,
                   ifelse(∫i / V_FRC < 0.9, i, v))
    end
end
```

Switch ver. 2

```julia
@mtkmodel Switch begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        V_FRC, [description = "Airway Volume at FRC"]
        Rclosed = 1e-12, [description = "Switch Resistance when Closed"]
        Ropen = 2.5e5, [description = "Switch Resistance when Open"]
        k = 1e3
    end
    @variables begin
        ∫i(t) = 0, [description = "Current integral"]
        R(t) = 0,  [description = "Switch Resistance"]
    end
    @equations begin
        R ~ Rclosed + (Ropen - Rclosed) * (1 / 2) * (tanh(k * (∫i / V_FRC) * (1 - (∫i / V_FRC))))
        v ~ R * i
    end
end
```

For performing the simulation I've used:

```julia
@mtkbuild system = System()
prob = ODEProblem(system, Pair[], (0, 2));
sol = solve(prob, Rodas4());
```
#+end_example

** DONE Riprendi da `CONTROLLA` il messaggio da scrivere

* 18.12.23
Ieri sera ho sviluppato una soluzione con l'utilizzo delle Callbacks, la riporto in `[[~/Thesis/src/test/test16c.jl][test16c.jl]]`. Non riesco ad indicizzare per «etichetta».

Colloquio con Chiara. Sistemare il componente Diodo.

* 19.12.23
Mi hanno risposto al post.  Ora sto elaborando un nuovo messaggio.

#+begin_example
Grazie a tutti per le risposte.  Non ho fornito dettagli per ragioni di brevità ma li posso descrivere meglio in questo post.

Devo realizzare un modello morfometrico di polmone umano: un equivalente elettico delle proprietà meccaniche del polmone che tiene conto anche di quelle geometriche a seconda del collegamento di moduli circuitali.

Esistono di due tipi di moduli nel modello morfometrico:
1. Airway: funge da linea di trasmissione.
2. Alveolous: nodo terminale.

Ciascuno di questi (50K) moduli è composto da Resistori, Condensatori, Induttanze e Diodi.  In particolare alcune Resistenze e Condensatori di un modulo sono dipendenti dall'integrale della Corrente entrante in quello specifico modulo.
La Corrente entrante viene sottoposta alla presenza del diodo (posto all'inizio di ciascun modulo) solamente se integrale di corrente è compreso tra 0 e `Vin_th`, altrimenti non ho tale componente.  Questo avviene per delle specifiche di progetto.

L'utilizzo del linguaggio Julia è data dall'esigenza di svincolarsi da licenze proprietarie e di utilizzare efficienti solver di equazioni differenziali come `DifferentialEquations`.

Per ora la mia codebase è stata scritta a partire da ModelingToolkit ma sono aperto a qualunque strumento mi consenta di:
- Creare le due tipologie di moduli
- Istanziare un così grande numero di moduli e, di conseguenza, di componenti
- Simulare il modello morfometrico risultante


#+end_example
* 21.12.23
** [#B] Scrivere risposta su community Julia
** DONE [#A] Finire il resoconto

* 22.12.23
** DONE Leggere le mail nella cartella `Tesi magistrale`
Su thunderbird ho un nuovo progetto da portare avanti per la tesi.
** DONE [#A] Installare il software necessario (paper)
Il software va compilato da sorgente e si trova in `Repo/avatree`.
Il software girerebbe solo su windows, come scritto su readme.

* 04.01.24
Da ciò che è scritto sulle mail inoltratemi da Chiara, sembrerebbe che
il software non possa eseguire correttamente su Linux.  Devo eseguire
quel software utilizzando VisualStudio 2019.

** DONE Installa VisualStudio 2019
** TODO [#C] Compila AVATree da sorgente

* 11.01.24
In questi giorni è comparso un [[https://github.com/SciML/ModelingToolkit.jl/issues/2421][issue su Github]] che vuole introdurre
gli eventi continui e discreti nei componenti.  Spero che abbia
abbastanza visibilità da poter essere mergiato in main.  Sarebbe
fantastico.  Da tenere sotto controllo e da testare.

* 12.01.24
Quell'issue si è dimostrato utile perchè ha risolto il problema degli
eventi continui e discreti nella progettazione di componenti.  Ora
resta da capire come posso utilizzare questa feature nella
progettazione del diodo e dello switch.

* 24.01.24
Il diodo e l'interruttori sono esclusi dai moduli di via aerea e di
alveolo.  Lo step successivo da risolvere consiste nell'importazione
massiccia dei dati in Julia.

Prima di concludere con questi componenti vado a raccogliere di
seguito i precedenti tentativi per poi inserirli negli sviluppi futuri.

#+begin_src julia
  # Utilizzo di caratteristiche "smooth"
  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ids     = 1e-6, [description = "Reverse-bias current"]
          max_exp = 15,   [description = "Value after which linearization is applied"]
          R       = 1e8,  [description = "Diode Resistance"]
          Vth     = 1e-3, [description = "Threshold voltage"]
          k       = 1e3,  [description = "Speed of exponential"]
      end
      @equations begin
          i ~ Ids * (exlin(k * (v - Vth) / (Vth), max_exp) - 1) + (v / R)
      end
  end

  @mtkmodel Switch begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          V_FRC, [description = "Airway Volume at FRC"]
          Rclosed = 1e-6, [description = "Switch Resistance when Closed"]
          Ropen = 2.5e5, [description = "Switch Resistance when Open"]
          k = 1e3
      end
      @variables begin
          ∫i(t) = 0, [description = "Current integral"]
          R(t) = 0,  [description = "Switch Resistance"]
      end
      @equations begin
          R ~ Rclosed + (Ropen - Rclosed) * (1 / 2) * (tanh(k * (∫i / V_FRC) * (1 - (∫i / V_FRC))))
          v ~ R * i
      end
  end

  # Utilizzo di Callback function (continuous_events) [non funzionante]
  @mtkmodel Diode begin
      @components begin
          p = Pin()
          n = Pin()
      end
      @variables begin
          v(t) = 0
          i(t) = 0
      end
      @equations begin
          v ~ p.v - n.v
          0 ~ p.i + n.i
          i ~ p.i
          0 ~ ifelse(v < 0, i, v)
      end
      @continuous_events begin
          [v ~ 0]
      end
  end

#+end_src

* 30.01.24

Modifico lo script `cir2jl` per ottenere solamente lo scheletro del
modello, senza aver istanziato alcun parametro.  Questo script l'ho
rinominato `cir2jl-skeleton`.

* 01.02.24

Da ieri sto eseguendo `main.jl`, che sta costruendo la struttura
principale del modello, l'impalcatura senza parametri.

* 20.02.24                                         :Chaste:Generazione_input:
Il progetto ora si concentra sulla generazione dell'albero
respiratorio del neonato con una particolare libreria, Chaste.
Esistono alcuni esempi dell'utilizzo di questa libreria in C++ sul
sito ufficiale: `AirwayGeneration` e `AirwayGeneration2015`.  Ho
installato tutto su una partizione di Ubuntu dedicata sul mio PC per
motivi di prestazioni.

* 28.02.24                                                        :Colloquio:
Nel modello è necessario reinserire sia il diodo che lo switch.  Ho
tenuto oggi un colloquio con il Prof. Dellaca' e Chiara e mi è stato
detto di provare con delle sigmoidi a raccordare la corrente.  Devo
riguardarmi la documentazione di `ModelingToolkit`.

Dovrei considerare una rete più piccola (solo 3 nodi) così da essere
più in grado di comprendere a cosa è dovuto l'errore

** DONE Riguardare la documentazione di `ModelingToolkit`
** TODO [#C] Comprendere le questioni legate alla licenza software che devo utilizzare
** DONE [#B] Importare la TAC neonatale (vedi CD in cartelletta)
Importata in `~/Documents/CT/DICOM` (su arch) e `~/Documenti/CT/DICOM`
(su Ubuntu).

* 29.02.24
Ho copiato il contenuto del disco fornitomi da Chiara e ora posso
utilizzare i file DICOM relativi ad una TAC di neonato.

* 04.03.24                                                        :Colloquio:

pag 30-31

installa Segment editor --> per 3dslicer

** TODO Come esportare in .vtu e .stl? con MATLAB? Risolvi questo.
- dove definisce il volume della griglia?

#include "AirwayGenerator.hpp"
#include "OutputFileHandler.hpp"
#include "TetrahedralMesh.hpp"
#include "FileFinder.hpp"
#include "UblasIncludes.hpp"

#include "vtkVersion.h"
#include "vtkSmartPointer.h"
#include "vtkPolyData.h"
#include "vtkPointData.h"
#include "vtkSphereSource.h"
#include "vtkXMLPolyDataWriter.h"
#include "vtkSTLReader.h"

* 28.02.24                                                  :Domande:Manuale:
  Appunti sullo status.

** Processing TAC
*** 3D-slicer
 Ho installato questo software (Ubuntu 18.04 LTS) per effettuare la
 segmentazione della TAC.

 #+begin_src bash
   # Mi sposto sulla build di Slicer
   cd ~/Builds/Slicer-5.6.1-linux-amd64
   # Lo eseguo
   ./Slicer
 #+end_src

 Ho installato anche il plugin `AirwaySegmentation` che, una volta
 posizionato un punto di seed all'interno della trachea, automatizza la
 segmentazione dei primi tratti.  Non ancora testato perchè non ho
 degli input.

**** Domande
 - Per la fase della segmentazione dei lobi come posso procedere?

*** CHASTE
 Ho installato Chaste sulla partizione di Ubuntu (versione 20.04 LTS)
 del PC di Chiara utilizzando `CMake` nella fase di building.  Si
 tratta di una libreria per C++, perciò ho cercato sia in locale che
 online (su [[https://chaste.github.io/docs/][sito ufficiale]], [[https://github.com/Chaste/Chaste?tab=readme-ov-file][GitHub]] e GitLab) se vi fossero dei progetti
 già esistenti che potessi utilizzare.  In locale, sulla stessa Repo di
 Chaste, esistono alcuni test (`TestAirwayGeneration`,
 `TestAirwayGenerationTutorial`).

 Ho trovato online anche «[[https://chaste.cs.ox.ac.uk/trac/wiki/PaperTutorials/AirwayGeneration2015][AirwayGeneration2015]]», quindi ho pensato di
 installarlo seguendo la procedura.  Purtroppo non era compatibile con
 la versione di Chaste installata perché richiedeva l'utilizzo di
 `scons` (ormai deprecato) nella fase di building, mentre Chaste poteva
 essere buildato solo con `CMake` quindi ho provato ad installare
 diverse versioni di Ubuntu sul mio PC per trovarne una che fosse
 compatibile con questo build manager.  Alla fine utilizzo una Ubuntu
 18.04 LTS e ho installato sia i due test che «AirwayGeneration2015».
 Sto cercando di capire come funzionano perchè non c'è un granchè di
 documentazione e sono entrambi scritti in C++.

 Allo stato attuale, mediante `TestAirwayGeneration` sono in grado di
 generare dati di un albero respiratorio di esempio:

 #+begin_src bash
   # Mi sposto sulla Repo di Chaste.
   cd ~/Builds/Chaste
   # Compilo il test con 8 threads.
   make -j8 TestAirwayGeneration
   # Eseguo il test con 8 threads.
   ctest -j8 -V -R TestAirwayGeneration

   # Mi sposto sulla cartella contenente gli output.
   cd $CHASTE_TEST_OUTPUT/TestAirwayGenerationTutorial
   # Visualizzo l'albero respiratorio in 3D (i suoi nodi)
   paraview --data=example_complete_conducting_airway.vtu
 #+end_src

**** Domande
 Volevo chiedere se già in passato qualcuno avesse utilizzato un
 programma specifico che utilizzasse la libreria Chaste nella fase di
 processing della TAC.  Come potrei altrimenti procedere?  Ho anche
 notato che esiste un wrapper della libreria per Python chiamato
 `PyChaste` ma nei tutorial nella documentazione non viene mostrato
 nulla riguardo la generazione delle vie aeree.

**** Risorse importanti
 - `[[/home/luca/Repos/Chaste/lung/test/tutorials/TestAirwayGenerationTutorial.hpp][AirwayGenerationTutorial.hpp]]`
 - `[[/home/luca/Builds/Chaste/lung/test/TestAirwayGenerationTutorial.cpp][AirwayGenerationTutorial.cpp]]`
 - `[[/home/luca/Repos/Chaste/lung/test/airway_generation/TestAirwayGeneration.hpp][AirwayGeneration.hpp]]`
 - `[[/home/luca/Builds/Chaste/lung/test/TestAirwayGeneration.cpp][AirwayGeneration.cpp]]`
 - Bootstrap di un progetto sulla repo di CHASTE: vedi wiki

**** Per recapitolare
 Ho utilizzato `AirwayGenerationTutorial`. Il file
 `lung/test/data/TestSubject002MajorAirways.vtu` rappresenta la
 skeletonizzazione dei primi tratti delle vie aeree mentre i file
 `*.stl` siano le segmentazioni lobari (i.e. lll, lul, rul, rml,
 rll). Se si dispone di queste informazioni si dovrebbe riuscire a
 generare il file `.vtu` dell'albero respiratorio completo.
** Generazione del modello
 Il modello di albero respiratorio implementato in `Julia` utilizza
 resistori ed induttanze (entrambe fisse o variabili in funzione
 dell'integrale di corrente).  Il problema in questa sezione è legato
 alla potenza di calcolo: il modello completo (50k parametri) non è
 stato generato dopo due giorni di esecuzione del codice su questo PC
 (parallelizzato su 8 threads).

* 05.03.24                                                   :Teoria:Manuale:
  Alcune definizioni.  Espongo un approccio per la segmentazione delle
  vie aeree nei primi tratti.

** Cosa sono files ".vtu" e i files ".stl"?
 [[https://discourse.slicer.org/t/convert-a-surface-mesh-to-a-volumetric-mesh-in-3d-slicer/1416/10][Questa fonte]] definisce i file ".vtu" e ".stl".
 - .vtu :: tetrahedral mesh in a VTK unstructured grid.  Si veda anche
   [[https://vtk.org/wp-content/uploads/2015/04/file-formats.pdf][qui]].
 - .stl :: surface mesh
** Cosa è `Tetgen'?
 [[https://www.wias-berlin.de/software/tetgen/1.5/index.html][Fonte:]] Software (datato) per la generazione di mesh tetraedriche.
** Primi tratti
 Ho segmentato i primi tratti utilizzando `Chest Imaging Platform` >
 `Toolkit` > `Segmentation` > `Segment Lung Airways`. Questo tool
 genera una label map che identifica i punti appartenenti ai primi
 tratti nei 3 piani. Posso esportare la label map in una segmentazione
 ed infine in un modello per poterlo esportare in `.vtk`. Non mi è
 stato ancora possible esportare in `.vtu`.
* 14.03.24                                                 :Manuale:Problema:
  Alcuni `How-Tos` e gestioni problemi relativi alla compatibilità con
  Ubuntu.

** Generazione input per Chaste
*** Importazione dei DICOM
 Slicer > Add DICOM Data > [Selezione]

*** Render 3D
 Selezione modulo `Volume Rendering`. Dal menù `Volume` scelgo
 `Parenchima IMR`. Dal volume `Preset` scelgo `CT-Lung`.

*** Segmentazione Vie Aeree
 Dal menù `Modules` scelgo `Markups` > `Point list`, poi seleziono un
 punto appartenente alla trachea (selezione punto fiduciario chiamato
 automaticamente "F").  Dal menù `Modules` scelgo `Segmentation` >
 `Airway Segmentation`.  Dal menu `CT volume` seleziono `203:
 Parenchima IMR` e dal menu `Seed point` seleziono il punto fiduciario
 "F" identificato precedentemente.

*** Skeletonizzazione
 Utilizzo il modulo `Vascular Modeling Toolkit` > `Extract Centerline`.
 Eseguo l'autodetect degli endpoints. Nella sezione `Tree`, dal menù
 `Centerline model`, seleziono il modello generato in fase di
 segmentazione (chiamato "Trachea"). Premo su `Apply`.

*** Esportazione della skeletonizzazione
 Vi sono vari formati disponibili, alcuni compatibili con VTK:
 - ".vtk" :: VTK Polygon Mesh
 - ".vtp" :: VTK XML Polygon Mesh
 - ".stl" :: Stereolitography Mesh
 - ".ply" :: Standford Polygon Mesh
 - ".obj" :: Wavefront Mesh
 - ".vtu" :: tetrahedral mesh in a VTK unstructured grid.  Si veda anche
   [[https://vtk.org/wp-content/uploads/2015/04/file-formats.pdf][qui]].

 Si consulti `[[https://manpages.ubuntu.com/manpages/focal/man1/vtkplotter-convert.1.html][VTKplotter-convert]]` e `[[https://github.com/marcomusy/vedo][vedo]]`.  Riscontro dei problemi in
 fase di installazione dovuti alla mancanza di librerie software
 necessarie.

 Testato il tool `vedo` (Ubuntu 22.04), in quanto `VTKplotter` non fa
 parte delle repository ufficiali (a quanto pare vedo dovrebbe essere
 la continuazione del progetto vtkplotter-convert).  Il tool genera un
 file .vtk a partire da un file .obj ma non è in grado di convertire
 in .vtu.

** Gestione distribuzione Linux
 Finora ho eseguito Chaste su Ubuntu 18.04.6 LTS (codename bionic).
 #+begin_example
 Distributor ID:	Ubuntu
 Description:	Ubuntu 18.04.6 LTS
 Release:	18.04
 Codename:	bionic
 #+end_example

 I problemi che ho riscontrato nella precedente fase possono essere
 risolti aggiornando all'ultima versione LTS.  L'ultimo rilascio della
 libreria Chaste è 2024.1 e le dipendenze installabili da package
 manager (apt) sono disponibili fino alla versione di Ubuntu 22.04 LTS
 (codename jammy).  Se non erro sul computer di Chiara è installata
 questa versione, provo lì prima di fare cambiamenti.  Funziona tutto
 correttamente, posso eseguire l'upgrade all'ultima versione LTS.

 #+begin_example
 Distributor ID:	Ubuntu
 Description:	Ubuntu 22.04.4 LTS
 Release:	22.04
 Codename:	jammy
 #+end_example

 Ho deciso di mantenere l'ultima versione solamente sul computer di
 Chiara, così da avere una soluzione di backup nel caso scegliessimo di
 utilizzare `AirwayGeneration2015`.
 
* 18.03.24                                  :Problema:Scrittura_Tesi:Domande:
** DONE Gestione distribuzione Linux (installazione)
Provo a ricompilare Chaste utilizzando i sorgenti della release
2024.1.  

Se non dovesse funzionare tento con la versione precedente (2021.1).
Comincio a scaricarne il codice in `~/Repos/Chaste.old`.
nn
Il seguente comando permette di utilizzare una qualunque release
(precedente o attuale) sostituendo <versione> con il numero di
versione desiderata (e.g. 2024.1).

#+begin_src bash
git clone -b <versione> https://github.com/Chaste/Chaste.git ~/Repos/Chaste
#+end_src


*** 2024.1 (Release più recente)

#+begin_src bash
  # Clonare la Repository.
  git clone -b 2024.1 https://github.com/Chaste/Chaste.git ~/Repos/Chaste

  # Creare la cartella di build.
  mkdir -p ~/Build/Chaste

  # Spostarsi sulla cartella di build.
  cd ~/Build/Chaste

  # Lanciare cmake interattivo (ncurses).
  ccmake ~/Repos/Chaste
  
#+end_src

Nell'interfaccia testuale di `ccmake`, digitare i seguenti comandi
(associati alla pressione di tasti singoli) uno per volta, aspettando
la fine dell'esecuzione di ciascuno prima di lanciare il successivo.

#+begin_example
  c
  e
  c
  e
  g
  q
#+end_example

I precedenti comandi eseguono le funzioni:
- c :: configure.  Va eseguito due volte per la corretta configurazione
- e :: exit. Alla fine di un'operazione di configure 
- g :: generate. Genera Makefile.
- q :: quit. Uscire dal programma ccmake

Infine eseguire:

#+begin_src bash
  # Build dell'oggetto `Continuous` (si veda CMakeFirstRun sul sito di Chaste)
  make -j4 Continuous
#+end_src

Il building è andato a buon fine.  Provo con il building dei test
specifici (`TestAirwayGeneration` e `TestAirwayGenerationTutorial`).

#+begin_src bash
  # Build dell'oggetto `TestAirwayGeneration`
  make -j4 TestAirwayGeneration
  make -j4 TestAirwayGenerationTutorial
#+end_src

Provo ad eseguirli:

#+begin_src bash
  # Eseguo `TestAirwayGeneration`
  ctest -j4 -V -R TestAirwayGeneration
  ctest -j4 -V -R TestAirwayGenerationTutorial
#+end_src

Il comando restituisce degli errori

#+begin_example
Start testing: Mar 18 11:06 CET
----------------------------------------------------------
364/558 Testing: TestAirwayGeneration
364/558 Test: TestAirwayGeneration
Command: "/home/chiara/Builds/Chaste/lung/test/TestAirwayGeneration"
Directory: /home/chiara/Repos/Chaste/
"TestAirwayGeneration" start time: Mar 18 11:06 CET
Output:
----------------------------------------------------------
Running 2 tests

 ***** TestAirwayGeneration.hpp *****


Entering TestGeneration
Passed
Entering TestDummyClassCoverage
Passed
OK!
<end of output>
Test time =   0.07 sec
----------------------------------------------------------
Test Passed.
"TestAirwayGeneration" end time: Mar 18 11:06 CET
"TestAirwayGeneration" time elapsed: 00:00:00
----------------------------------------------------------

374/558 Testing: TestAirwayGenerationTutorial
374/558 Test: TestAirwayGenerationTutorial
Command: "/home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial"
Directory: /home/chiara/Repos/Chaste/
"TestAirwayGenerationTutorial" start time: Mar 18 11:06 CET
Output:
----------------------------------------------------------
Running 1 test

 ***** TestAirwayGenerationTutorial.hpp *****


Entering TestGenerateAirways
ERROR: In ./IO/XMLParser/vtkXMLParser.cxx, line 389
vtkXMLDataParser (0x55b31a5b8230): Error parsing XML in stream at line 24, column 3, byte index 1599: not well-formed (invalid token)

ERROR: In ./IO/XML/vtkXMLReader.cxx, line 467
vtkXMLUnstructuredGridReader (0x55b31a5af3c0): Error parsing input file.  ReadXMLInformation aborting.

ERROR: In ./Common/ExecutionModel/vtkExecutive.cxx, line 781
vtkCompositeDataPipeline (0x55b31a5c52b0): Algorithm vtkXMLUnstructuredGridReader(0x55b31a5af3c0) returned failure for request: vtkInformation (0x55b31a5cb2c0)
  Debug: Off
  Modified Time: 83
  Reference Count: 1
  Registered Events: (none)
  Request: REQUEST_INFORMATION
  FORWARD_DIRECTION: 0
  ALGORITHM_AFTER_FORWARD: 1



terminate called after throwing an instance of 'Exception'
  what():  
Chaste error: ./mesh/src/reader/VtkMeshReader.cpp:483: No point data 'radius'
[Satellite-L50-B:27311] *** Process received signal ***
[Satellite-L50-B:27311] Signal: Aborted (6)
[Satellite-L50-B:27311] Signal code:  (-6)
[Satellite-L50-B:27311] [ 0] /lib/x86_64-linux-gnu/libc.so.6(+0x42520)[0x7f135ae9e520]
[Satellite-L50-B:27311] [ 1] /lib/x86_64-linux-gnu/libc.so.6(pthread_kill+0x12c)[0x7f135aef29fc]
[Satellite-L50-B:27311] [ 2] /lib/x86_64-linux-gnu/libc.so.6(raise+0x16)[0x7f135ae9e476]
[Satellite-L50-B:27311] [ 3] /lib/x86_64-linux-gnu/libc.so.6(abort+0xd3)[0x7f135ae847f3]
[Satellite-L50-B:27311] [ 4] /lib/x86_64-linux-gnu/libstdc++.so.6(+0xa2b9e)[0x7f135b74db9e]
[Satellite-L50-B:27311] [ 5] /lib/x86_64-linux-gnu/libstdc++.so.6(+0xae20c)[0x7f135b75920c]
[Satellite-L50-B:27311] [ 6] /lib/x86_64-linux-gnu/libstdc++.so.6(+0xae277)[0x7f135b759277]
[Satellite-L50-B:27311] [ 7] /lib/x86_64-linux-gnu/libstdc++.so.6(+0xae4d8)[0x7f135b7594d8]
[Satellite-L50-B:27311] [ 8] /home/chiara/Builds/Chaste/mesh/libchaste_mesh.so(_ZN13VtkMeshReaderILj1ELj3EE12GetPointDataENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt6vectorIdSaIdEE+0x1cc)[0x7f135ce2c3aa]
[Satellite-L50-B:27311] [ 9] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0x105e5)[0x55b319fa05e5]
[Satellite-L50-B:27311] [10] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0x110d3)[0x55b319fa10d3]
[Satellite-L50-B:27311] [11] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xb9ab)[0x55b319f9b9ab]
[Satellite-L50-B:27311] [12] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xe6f7)[0x55b319f9e6f7]
[Satellite-L50-B:27311] [13] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xe5dc)[0x55b319f9e5dc]
[Satellite-L50-B:27311] [14] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xe482)[0x55b319f9e482]
[Satellite-L50-B:27311] [15] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xe344)[0x55b319f9e344]
[Satellite-L50-B:27311] [16] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xe958)[0x55b319f9e958]
[Satellite-L50-B:27311] [17] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xa976)[0x55b319f9a976]
[Satellite-L50-B:27311] [18] /lib/x86_64-linux-gnu/libc.so.6(+0x29d90)[0x7f135ae85d90]
[Satellite-L50-B:27311] [19] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x80)[0x7f135ae85e40]
[Satellite-L50-B:27311] [20] /home/chiara/Builds/Chaste/lung/test/TestAirwayGenerationTutorial(+0xa845)[0x55b319f9a845]
[Satellite-L50-B:27311] *** End of error message ***
<end of output>
Test time =   0.50 sec
----------------------------------------------------------
Test Failed.
"TestAirwayGenerationTutorial" end time: Mar 18 11:06 CET
"TestAirwayGenerationTutorial" time elapsed: 00:00:00
----------------------------------------------------------

End testing: Mar 18 11:06 CET

Continuous_lung =   0.07 sec*proc

Nightly_lung =   0.50 sec*proc

#+end_example

*** 2024.1 (Ultimo commit, versione di sviluppo)

Durante l'installazione delle dipendenze il tool `python3-paraview`
bloccava l'installazione dell'ultima versione di VTK (9).  Non è
chiaro quale sia la versione adeguata (il pacchetto
`chaste-dependencies` che raccoglie tutte le dipendenze è aggiornato
al 2022 e la versione di VTK consigliata è ferma alla 7.1).

*** 2021.1 (penultima Release)

#+begin_src bash
# Clonare la Repository.
git clone -b 2021.1 https://github.com/Chaste/Chaste.git ~/Repos/Chaste.old

# Creare la cartella di build.
mkdir -p ~/Build/Chaste.old

# Spostarsi sulla cartella di build.
cd ~/Build/Chaste.old

# Lancio cmake interattivo (ncurses). --> ERRORE
ccmake ~/Repos/Chaste.old
#+end_src

CMake restituisce un errore:

#+begin_example
CMake Error at /usr/share/cmake-3.22/Modules/FindPackageHandleStandardArgs.cmake:230 (message):
  Could NOT find MPI (missing: MPI_C_FOUND) (found version "3.1")
Call Stack (most recent call first):
  /usr/share/cmake-3.22/Modules/FindPackageHandleStandardArgs.cmake:594 (_FPHSA_FAILURE_MESSAGE)
  /usr/share/cmake-3.22/Modules/FindMPI.cmake:1830 (find_package_handle_standard_args)
  CMakeLists.txt:428 (find_package)
#+end_example

Posso eventualmente utilizzare questa versione ma portandomi allo
stesso commit che ho sul mio PC.


*** 2024.1 Installazione manuale

1. Editare `.bashrc` aggiungendo delle variabili d'ambiente

#+begin_src bash
export CHASTE_LIBS=$HOME/apps/chaste-libs
export PATH=$CHASTE_LIBS/bin:$PATH
#+end_src

2. Fare il sourcing del nuovo `.bashrc`

#+begin_src bash
source ~/.bashrc
#+end_src

3. Creare la cartella per accogliere le dipendenze

#+begin_src bash
mkdir -p $CHASTE_LIBS
#+end_src

4. Compilare le dipendenze (operazione molto lunga e con alto rischio di fallimento).

** Scrittura tesi
Comincio a delineare i requisiti software da soddisfare per garantire
ripetibilità.  Cosa s'intende per modello morfometrico?  Consultare il
pdf fornito da Chiara.  Quali altri concetti sono importanti ai fini
della comprensione della tesi?

*** Definizioni importanti
- Modello morfometrico

*** Requisiti software
- Julia :: utilizzato nello sviluppo del modello morfometrico.
- Chaste :: libreria utilizzata in fase di generazione dell'input al
  modello morfometrico.  Genera un surrogato polmonare, i cui
  parametri geometrici sono necessari alla stima di impedenze,
  resistenze e capacità impiegate nel modello morfometrico.

**** Domande
- Dovrei inserire anche le alternative, o meglio, i tentativi di
  installazione delle alternative?

* 20.03.24                                                :Conversione:Input:
** Gestione distribuzione Linux
L'installazione di Chaste sul mio portatile funziona (Ubuntu), quindi
non faccio alcun aggiornamento e tento di eseguire con quella.  Il
motivo per cui ho tentato di installare Chaste su una versione LTS più
aggiornata è quello di poter utilizzare lo stesso computer per fare
diverse cose senza dover lasciare il sistema operativo che sto
utilizzando.

** TODO Conversione skeletonizzazione
*** TODO vtkToolbox (MATLAB)
Su arch ho scaricato ed installato (in un virtual environment) il tool
`vedo`.  Provo ad utilizzare la libreria `[[https://it.mathworks.com/matlabcentral/fileexchange/94993-vtktoolbox][vtkToolbox]]` per MATLAB.
L'installazione è avvenuta senza problemi (non è stato necessario
compilare alcun software da sorgente).

Questa libreria è in grado di lavorare solamente con due tipologie di
file: `vtkPolyData` e `vtkUnstructuredGrid`.  Per comprendere cosa
siano mi sto riferendo a [[https://vtk.org/wp-content/uploads/2015/04/file-formats.pdf][questa fonte]].

**** Formato dei file VTK
Esistono due differenti stili di formato di file in VTK:
- Serial formats :: (legacy) più semplici da leggere e scrivere (anche
  con intervento umano). Sono meno flessibili della seconda categoria.
- XML formats    :: Formati preferiti e più utilizzati. Esistono due
  tipi di file XML:
  - Serial   :: progettato per lettura e scrittura da parte di
    applicazioni di un solo processo.
  - Parallel :: progettato per lettura e scrittura da parte di
    applicazioni con processi multipli.

  Nei file XML i dataset VTK sono classificati in due categorie:
  - Structured   :: Array topologicamente regolare di celle (pixel,
    voxel, quatrilateri o esaedri).  I tipi di dataset structured sono
    `vtkImageData`, `vtkRectilinearGrid`, `vtkStructuredGrid`.
  - Unstructured :: Array topologicamente irregolare di punti o
    celle. i subset sono descritti utilizzando «pieces». I tipi di
    dataset unstructured sono `vtkPolyData` `vtkUnstructuredGrid`
    
  Di seguito elenco tutti i tipi di date e di file associati ad una
  particolare estensione.
  - ImageData (.vti)          :: Serial   vtkImageData        (structured).
  - PolyData (.vtp)           :: Serial   vtkPolyData         (unstructured).
  - RectilinearGrid (.vtr)    :: Serial   vtkRectilinearGrid  (structured).
  - StructuredGrid (.vts)     :: Serial   vtkStructuredGrid   (structured).
  - UnstructuredGrid (.vtu)   :: Serial   vtkUnstructuredGrid (unstructured).
  - PImageData (.pvti)        :: Parallel vtkImageData        (structured).
  - PPolyData (.pvtp)         :: Parallel vtkPolyData         (unstructured).
  - PRectilinearGrid (.pvtr)  :: Parallel vtkRectilinearGrid  (structured).
  - PStructuredGrid (.pvts)   :: Parallel vtkStructuredGrid   (structured).
  - PUnstructuredGrid (.pvtu) :: Parallel vtkUnstructuredGrid (unstructured). 

Chaste richiederebbe l'utilizzo di un Serial Unstructured Grid (.vtu).
Il toolbox per MATLAB può lavorare con .vtp, .pvtp, .vtu e .pvtu.

*** WriteVTK (Julia)
Ho anche trovato una libreria per Julia chiamato [[https://juliavtk.github.io/WriteVTK.jl/stable/][WriteVTK]].  Esiste
anche una [[https://github.com/JuliaVTK/ReadVTK.jl][ReadVTK]].  Non ancora testato.

** TODO Bootstrap di un test (Chaste)
Cerco la documentazione su come posso creare un nuovo test su Chaste.
Su Chaste quest'operazione viene chiamata «creazione di un User
Project».  Si veda [[https://chaste.github.io/docs/user-guides/user-projects/][questa]] documentazione.
- Scaricare [[https://github.com/Chaste/template_project][template]] di User Project.

* 21.03.24                                        :Conversione:Input:Manuale:
** Bootstrap di un test (Chaste)
Quando faccio il bootstrap invoco il giusto interprete Python.  Su
Ubuntu 20.04 ho sia python (2.7 mi pare) che python3.

#+begin_src bash
  python3 setup_project.py
#+end_src

** Gestione distribuzione Linux
Provo a installare Chaste compilando da sorgente le librerie
necessarie.  Provo a farlo su Artix Linux, derivata di Arch.  Si
consulti la documentazione su [[https://chaste.github.io/docs/dev-guides/developer-install-guide/][questo sito]].  Il processore del PC ha in
totale 8 threads, quindi modifico di seguito il seguente codice per
compilare le librerie necessarie utilizzando tutta la potenza di
calcolo disponibile.

#+begin_src bash
  # CMake 3.22.6
  wget https://www.cmake.org/files/v3.22/cmake-3.22.6.tar.gz
  tar -zxf cmake-3.22.6.tar.gz
  cd cmake-3.22.6
  ./bootstrap --prefix=$CHASTE_LIBS --parallel=8 && make -j8 && make install
  cd ..
  rm -rf cmake-3.22.6.tar.gz cmake-3.22.6

  # Boost 1.74.0
  cd $CHASTE_LIBS
  wget https://boostorg.jfrog.io/artifactory/main/release/1.74.0/source/boost_1_74_0.tar.gz
  tar -zxf boost_1_74_0.tar.gz
  cd boost_1_74_0
  ./bootstrap.sh --prefix=$CHASTE_LIBS --with-libraries=system,serialization,program_options
  ./b2 install
  cd ..
  rm -rf boost_1_74_0.tar.gz boost_1_74_0

  # PETSc lite 3.18.6
  # mpich-4.1.2
  # HDF5-1.10.11
  # ParMETIS
  cd $CHASTE_LIBS
  wget https://ftp.mcs.anl.gov/pub/petsc/release-snapshots/petsc-lite-3.18.6.tar.gz
  tar -zxf petsc-lite-3.18.6.tar.gz
  rm -f petsc-lite-3.18.6.tar.gz
  cd petsc-3.18.6
  export PETSC_DIR=`pwd`

  mpich=https://www.mpich.org/static/downloads/4.1.2/mpich-4.1.2.tar.gz
  hdf5=https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/hdf5-1.10.11/src/hdf5-1.10.11.tar.bz2

  export PETSC_ARCH=linux-gnu
  ./configure \
      --with-make-np=8 \
      --with-cc=gcc \
      --with-cxx=g++ \
      --with-fc=0 \
      --with-x=false \
      --with-ssl=false \
      --download-f2cblaslapack=1 \
      --download-mpich=$mpich \
      --download-hdf5=$hdf5 \
      --download-parmetis=1 \
      --download-metis=1 \
      --with-shared-libraries \
      --with-debugging=0
  make all
  make test # optional

  # SUNDIALS 5.8.0
  cd $CHASTE_LIBS
  wget https://github.com/LLNL/sundials/releases/download/v5.8.0/sundials-5.8.0.tar.gz
  tar -zxf sundials-5.8.0.tar.gz
  mkdir build-sundials-5.8.0 && cd build-sundials-5.8.0
  cmake \
      -DCMAKE_INSTALL_PREFIX=$CHASTE_LIBS \
      -DBUILD_SHARED_LIBS=ON \
      -DCMAKE_BUILD_TYPE=Release \
      -DEXAMPLES_ENABLE=OFF ../sundials-5.8.0
  make -j8 && make install
  cd ..
  rm -rf build-sundials-5.8.0 sundials-5.8.0 sundials-5.8.0.tar.gz

  # XSD 4.0.0
  cd $CHASTE_LIBS
  wget https://www.codesynthesis.com/download/xsd/4.0/linux-gnu/x86_64/xsd-4.0.0-x86_64-linux-gnu.tar.bz2
  tar -xjf xsd-4.0.0-x86_64-linux-gnu.tar.bz2
  ln -s $CHASTE_LIBS/xsd-4.0.0-x86_64-linux-gnu/bin/xsd $CHASTE_LIBS/bin/xsd
  rm -f xsd-4.0.0-x86_64-linux-gnu.tar.bz2

  # Xerces 3.2.3
  cd $CHASTE_LIBS
  wget https://archive.apache.org/dist/xerces/c/3/sources/xerces-c-3.2.3.tar.gz
  tar -zxf xerces-c-3.2.3.tar.gz
  cd xerces-c-3.2.3/
  export XERCESCROOT=`pwd`
  ./configure --prefix=$CHASTE_LIBS
  make -j8 all
  make install
  cd ..
  rm -rf xerces-c-3.2.3 xerces-c-3.2.3.tar.gz

  # VTK 9.1.0 --> ERROR
  cd $CHASTE_LIBS
  wget https://www.vtk.org/files/release/9.1/VTK-9.1.0.tar.gz
  tar -zxf VTK-9.1.0.tar.gz
  mkdir build_VTK-9.1.0 && cd build_VTK-9.1.0
  cmake -DCMAKE_INSTALL_PREFIX=$CHASTE_LIBS ../VTK-9.1.0
  make -j8
  make install
  cd ..
  rm -rf build_VTK-9.1.0 VTK-9.1.0 VTK-9.1.0.tar.gz

  # chaste_codegen (in a Python virtual environment)
  python3 -m venv $CHASTE_LIBS/chaste_codegen
  source $CHASTE_LIBS/chaste_codegen/bin/activate
  python3 -m pip install --upgrade pip setuptools wheel
  python3 -m pip install chaste_codegen

#+end_src

(Quasi) Tutte le dipendenze sono state compilate ed installate da
sorgente.  VTK non compila correttamente quindi utilizzo la versione
9.3.0 con package manager.  Provo ora a compilare Chaste.  Avevo
saltato la compilazione di Boost e la fase di configuration di ccmake,
così come quella di generation.  Forse è il caso di utilizzare solo le
dipendenze aggiornate.

Ho disinstallato tutte le dipendenze compilate da sorgente e ho
compilato da sorgente l'ultima versione di `petsc`.  Dava ancora
errore, a causa di `xsd` (non avevo installato `libxsd`).  Sono
riuscito a configurare e generare con cmake ma non a compilare con
make.  Rimango della mia teoria: lascio l'installazione di Chaste
sulla mia macchina senza aggiornare alcun componente.  L'ultimo
tentativo che potrei fare quando sono a casa è quello di disinstallare
le dipendenze di chaste (pacchetto chaste-dependencies) e reinstallare
le singole dipendenze allo stato aggiornato.

** Conversione skeletonizzazione (vtkToolbox)
*** Funzioni utili
Creo un elenco di funzioni che serviranno alla conversione del file
".vtp" al ".vtu":
- vtkRead  :: Legge un file legacy: .vtk oppure XML: .vtp o .vtu
  #+begin_src octave
    function outStruct = vtkRead(filename, verbose)
  #+end_src
  
- vtkWrite :: Scrive un file legacy: .vtk oppure XML: .vtp o .vtu
  #+begin_src octave
    % Defaults:
    % verbose = false
    % 
    % dataMode can be chosen from {'ascii', 'binary'} for vtk, ply, stl
    %                         and {'ascii', 'binary', 'appended'} for vtp, vtu
    %                         and {'ascii'} for obj, off
    function vtkWrite(inStruct, filename, verbose, dataMode)
  #+end_src

L'idea sarebbe quella di generare un nuovo file .vtp e di sottoporlo a `vtkRead`.

* 22.03.24
** Disinstallazione vecchie dipendenze
#+begin_src bash
# Rimozione
sudo apt remove chaste-dependencies
# Aggiornamento di sistema (update delle repository)
sudo apt update
#+end_src

** Installazione nuove dipendenze
  Ottengo la lista delle dipendenze da installare.

| Dipendenze   | Versione | Pacchetto                    |
|--------------+----------+------------------------------|
| GCC          |     12.x | gcc                          |
| Clang        |     14.x | clang                        |
| Intel oneAPI |   2024.x | ---                          |
| Boost        |     1.74 | libboost-system-dev          |
|              |          | libboost-serialization-dev   |
|              |          | libboost-program-options-dev |
| HDF5         |   1.10.7 | hdf5-tools                   |
|              |          | libhdf5-openmpi-dev          |
| ParMETIS     |      4.0 | libmetis-dev                 |
|              |          | libparmetis-dev              |
| PETSc        |     3.15 | libpetsc-real3.15            |
|              |          | libpetsc-real3.15-dev        |
|              |          | libpetsc-real3.15-dbg        |
| SUNDIALS     |      5.8 | libsundials-dev              |
| VTK          |      9.1 | libvtk9.1                    |
|              |          | libvtk9-dev                  |
| Xerces       |    3.2.3 | libxerces-c-dev              |
| XSD          |      4.0 | xsdcxx                       |


Comandi di installazione manuale

#+begin_src bash
sudo apt install 

sudo apt-get install cmake cmake-curses-gui                                 \
libboost-system-dev libboost-serialization-dev libboost-program-options-dev \
libpetsc-real3.15 libpetsc-real3.15-dev libpetsc-real3.15-dbg               \
hdf5-tools libhdf5-openmpi-dev                                              \
libmetis-dev libparmetis-dev                                                \
libsundials-dev                                                             \
xsdcxx                                                                      \
libxerces-c-dev                                                             \
libvtk9.1 libvtk9-dev

#+end_src 

Dopo l'installazione delle dipendenze più aggiornate, posso provare a
compilare i sorgenti più aggiornati di Chaste.

#+begin_src bash
# Aggiornamento del codice sorgente
cd ~/Repos/Chaste-dev
git pull

# Rimozione della precedente build
cd ~/Builds/Chaste-dev
rm -rf *

# Compilazione del codice (per polmone)
cmake ~/Repos/Chaste-dev
make -j4 lung

# Compilazione dei test che mi servono
make -j4 TestAirwayGeneration
make -j4 TestAirwayGenerationTutorial
ctest -V -R TestAirwayGeneration
ctest -V -R TestAirwayGenerationTutorial
#+end_src 

Il solito errore di VTK è comparso.  Non proseguo su questa via.

* 25.03.24
** Idea di Francesca
Segmentazione da 3DSlicer, esporto in .mhd, importo su matlab e lavoro
per estrarre la linea centrale (center-line) e generare il
.vtp. utilizzo poi la funzione del toolbox per generare il .vtu.
Quando esporto in mhd con Chaste, i file che questo restituisce sono
in formato zraw e mhd.  Stando a ciò che è stato detto all'incontro,
il mhd è un formato che punta al contenuto di zraw quindi entrambi i
file devono essere nella working directory di matlab per funzionare
correttamente.

- region_growing: funzione in matlab per effettuare l'estrazione delle
  vie aeree.  La soglia che ci servirà è sui 900. Devo però ricondurmi
  ad un range da -1000 a 0.

- se uso .mhd: utilizzare [[https://mipav.cit.nih.gov/][MIPAV]].

Altri programmi che posso utilizzare:
- [[https://imagej.net/ij/index.html][imagej]]

** DONE Importare documenti da computer di Chiara
Mi servono gli appunti che avevo sull'altro computer per aggiornare lo
stato della gestione della distribuzione.

Gli appunti su questo computer (arch) includono informazioni file vtk?

** Conversione skeletonizzazione (vtkToolbox)
Devo rivedere la procedura

* 26.03.24
Non posso generare io un file vtp e se anche lo facessi non saprei
come cambiare quello di 3DSlicer.

** Idea di Francesca
Ho alcuni dubbi sull'utilizzo di altri formati (tipo mhd).  Per quale
motivo passare a questo formato se poi devo fare parte del lavoro che
già facevo in 3DSlicer su MATLAB?  Se intendo bypassare la vtkRead è
la strada giusta ma cosa mi dice che vtkWrite non abbia gli stessi
problemi?  Ci devo riflettere.  Esistono modalità alternative per la
manipolazione di file vtk?  Cosa accadrebbe se utilizzassi Julia ad
esempio?

** Julia ReadVTK
Sto provando a utilizzare la libreria per Julia chiamata [[https://juliavtk.github.io/ReadVTK.jl/stable/][ReadVTK]] per
effettuare la conversione.  Ho manipolato il file generato da
3DSlicer, in particolare il campo `version` e `header_type` di VTKFile.
In questo modo la funzione VTKFile riesce ad importare il file .vtp.
Di seguito le modifiche utili alla lettura del file:

#+begin_example
<VTKFile type="PolyData" version="1" byte_order="LittleEndian" header_type="UInt64" compressor="vtkZLibDataCompressor">
#+end_example

Il numero celle che riesce ad indicizzare con questa lettura è
negativo, quindi non corretto (-9223372036854775808).  La REPL trova
però un numero positivo di punti (1735).

ReadVTK lavora con un encoding di tipo `raw` per gli AppendedData
mentre quello utilizzato da 3DSlicer è `Base64`.

* 27.03.24
Per utilizzare una libreria con funzioni per effettuare l'estrazione
della centerline MATLAB avrei bisogno di un'immagine binary, double,
single, integer o logical.

** Avatree su arch linux
Clono la Repo da [[https://github.com/snousias/avatree][qui]].

#+begin_src bash
  cd ~/Repos/
  git clone https://github.com/snousias/avatree
  mkdir ~/Builds/avatree
  cd ~/Builds/avatree
  cmake ~/Repos/avatree
#+end_src

Aspetto che finisca la compilazione di ITK (dipedenza di avatree).
fast non compila su arch.  Provo con Ubuntu.  Potrei provare a vedermi
le funzioni C++ che servirebbero per scrivere il test con Chaste.

* 28.03.24
Provo a fare bootstrap di progetto da Ubuntu 20.04.

* 29.03.24
Ho provato a disinstallare l'ultima versione di vtk per Ubuntu 22.04 e
a reinstallare le vecchie dipendenze (chaste dependencies).  Il
messaggio che ho ottenuto è il seguente

#+BEGIN_EXAMPLE
chiara@Satellite-L50-B:~/Repos/Chaste-dev$ sudo apt install chaste-dependencies
Lettura elenco dei pacchetti... Fatto
Generazione albero delle dipendenze... Fatto
Lettura informazioni sullo stato... Fatto   
I seguenti pacchetti sono stati installati automaticamente e non sono più richiesti:
  libdouble-conversion-dev libutfcpp-dev
Usare "sudo apt autoremove" per rimuoverli.
I seguenti pacchetti aggiuntivi saranno inoltre installati:
  libfltk1.1 libqt5x11extras5 libvtk7-dev libvtk7-java libvtk7-jni libvtk7.1p-qt python3-vtk7 tcl-vtk7 vtk7
Pacchetti suggeriti:
  vtk7-doc vtk7-examples java-virtual-machine mayavi2
I seguenti pacchetti NUOVI saranno installati:
  chaste-dependencies libfltk1.1 libqt5x11extras5 libvtk7-dev libvtk7-java libvtk7-jni libvtk7.1p-qt python3-vtk7 tcl-vtk7 vtk7
0 aggiornati, 10 installati, 0 da rimuovere e 32 non aggiornati.
È necessario scaricare 7.714 kB di archivi.
Dopo quest'operazione, verranno occupati 50,7 MB di spazio su disco.
Continuare? [S/n]
#+END_EXAMPLE

Curioso, esistono dei test per gestire le mesh.  Che siano questi
quelli di cui ho bisogno?  Vedi [[https://chaste.github.io/docs/dev-guides/cmake-build-guide/][qui]] e, soprattutto [[https://chaste.github.io/docs/dev-guides/building-executable-apps/][qui]].

Non mi sono fidato delle precedenti installazioni e ho disinstallato
tutte le dipendenze vecchie e nuove e ho reinstallato le vecchie
(chaste-dependencies), che hanno come ultimo aggiornamento
2022.04.11.  Provo ora a lavorare con la versione 2021.1.

La versione 2021.1 non compila l'oggetto `lung` quindi non è
utilizzabile.  Provo con l'ultima versione e vecchie dipendenze.

* 03.04.24
Ho provato ad installare dipendenze e Chaste su Fedora (Computer di
Chiara) e compare di nuovo quell'errore di VTK.

* 04.04.24
Rileggo la mail di Davide.  Ci sono varie soluzioni:
1. [[https://github.com/ElsevierSoftwareX/SOFTX_2019_291][Meshtool]] (in C++)
2. [[https://github.com/baxmittens/VTUFileHandler.jl][VTUFileHandler]] (per Julia)
3. [[http://www.itksnap.org/pmwiki/pmwiki.php?n=Downloads.SNAP4][ITK-snap]]
4. [[https://github.com/KIT-IBT/vtkToolbox][vtkToolbox]] (MATLAB)

** DONE Meshtool
Considero il primo per ora e lo installo.  Studio ora il comportamento
delle varie funzioni:
- clean quality          :: Deform mesh elements to reach a certain quality threshold value.
- clean topology         :: Clean the mesh from bad topology definitions.
- convert                :: Convert between different mesh formats.
- collect                :: Merge a mesh with datasets.
- extract data           :: Data defined on a mesh is extracted for a given submesh.
- extract gradient       :: Compute gradient and gradient magnitude of a scalar function on a mesh.
- extract mesh           :: A submesh is extracted from a given mesh based on given element tags.
- extract myocard        :: The myocardium is extracted from a given mesh.
- extract surface        :: Extract a sequence of surfaces defined by set operations on element tags.
- extract unreachable    :: Extract elements that are unreachable through edge-traversal from a given start vertex.
- extract volume         :: Extract elements inside a given box volume.
- generate fibres        :: Generate default fibers for a given mesh file.
- generate distancefield :: Generate a distancefield between two surfaces.
- generate mesh          :: Generate a tetrahedral mesh from a list of nested triangle surfaces.
- insert data            :: Data defined on a submesh is inserted back into a mesh.
- insert meshdata        :: The fiber and tag data of a mesh is inserted into another mesh.
- insert submesh         :: A submesh is inserted back into a mesh and written to an output mesh.
- interpolate clouddata  :: Interpolate data from a pointcloud onto a mesh.
- interpolate elemdata   :: Interpolate element data from one mesh onto another.
- interpolate elem2node  :: Interpolate data from elements onto nodes.
- interpolate node2elem  :: Interpolate data from nodes onto elements.
- interpolate nodedata   :: Interpolate nodal data from one mesh onto another.
- itk close              :: Apply closing (i.e. dilate-erode) algorithm to itk data.
- itk crop               :: Remove surrounding whitespace.
- itk dtype              :: Convert datatype.
- itk extract            :: Extract slices of an itk image stack.
- itk flip               :: Flip the voxel data along given axes.
- itk normalize          :: Normalize voxel spacing.
- itk padding            :: Add padding to voxel data.
- itk refine             :: Refine voxel data.
- itk sample             :: Create an itk image stack from sampeling surfaces.
- itk smooth             :: Smooth the voxel data.
- map                    :: Map .vtx, .surf and .neubc files to the indexing of a submesh.
- merge surface          :: Merge the geometry given by a closed surface mesh into a different mesh.
- merge meshes           :: Merge two meshes, unifying co-located vertices.
- query bbox             :: Print the bounding box of a given mesh.
- query curvature        :: Compute the curvature of a surface.
- query edges            :: Print several statistics related to the mesh edges.
- query graph            :: Print the nodal connectivity graph.
- query idx              :: Print indices in a proximity to a given coordinate.
- query insidepoint      :: Get a point inside a given closed surface.
- query quality          :: Print mesh quality statistics.
- query tags             :: Print the tags present in a given mesh.
- reindex                :: Reindex a mesh to improve matrix bandwidth and cache efficiency.
- resample mesh          :: Resample a tetrahedral mesh to fit a given edge size range.
- resample purkinje      :: Resample purkinje cables as close as possible to a segment size.
- resample surfmesh      :: Resample a triangle mesh to fit a given edge size range.
- restore mapping        :: Restore nodal and element mapping for a submesh w.r.t. a reference mesh.
- smooth data            :: Smooth data defined on a mesh.
- smooth mesh            :: Smooth surfaces and volume of a mesh.
- smooth surface         :: Smooth one or multiple surfaces of a mesh.
- split                  :: Generate the split list for given split operations.

Ricerco tra queste quelle che mi interessano.
- convert         :: Convert between different mesh formats.
- extract data    :: Data defined on a mesh is extracted for a given submesh.
- extract mesh    :: A submesh is extracted from a given mesh based on given element tags.
- extract surface :: Extract a sequence of surfaces defined by set operations on element tags.
- extract volume  :: Extract elements inside a given box volume.

*** Formati di input supportati
Noto, analizzando i formati possibili degli output, che sono sempre
gli stessi in ciascuna delle funzioni di interesse (in seguito scarto
quelli inutili):
- carp_txt
- carp_bin
- vtk
- vtk_bin
- mmg
- neu
- purk
- obj
- stellar
- vcflow

Quelli utili sono:
- vtk
- vtk_bin
- obj

Potrei utilizzare un file `*.vtk' o `*.obj' come input.

*** Formati di output supportati
Noto,
analizzando i formati possibili degli output, che sono sempre
gli stessi in ciascuna delle funzioni di interesse (in seguito scarto
quelli inutili):
- carp_txt
- carp_bin
- vtk
- vtk_bin
- vtk_polydata
- mmg
- neu
- obj
- stellar
- vcflow
- ensight_txt

Quelli utili sono:
- vtk
- vtk_bin
- vtk_polydata
- obj

Mi servirebbe un .vtu con particolari caratteristiche ma questo
strumento non assicura l'esportazione in quel formato, a meno che
`vtk_bin' non sia .vtu

*** Meshtool convert
Non difficile da capire ma non sono sicuro funzioni con i formati che
voglio.

#+begin_example
[luca@probook SOFTX_2019_291]$ ./meshtool convert
OpenMP thread utilization: 8 / 8 threads.
convert: convert between different mesh formats
parameters:
-imsh=<path>	 (input) path to basename of the input mesh
-ifmt=<path>	 (input) format of the input mesh
-omsh=<path>	 (output) path to basename of the output mesh
-ofmt=<path>	 (input) format of the output mesh
-scale=<float>	 (optional) Vertex scaling applied to output mesh

The supported input formats are:
carp_txt, carp_bin, vtk, vtk_bin, mmg, neu, purk, obj, stellar, vcflow

The supported output formats are:
carp_txt, carp_bin, vtk, vtk_bin, vtk_polydata, mmg, neu, obj, stellar, vcflow, ensight_txt
#+end_example

**** Parametri
- input:
  - path to basename of the input mesh.
  - format of the input mesh.
  - format of the output mesh.
- output:
  - path to basename of the output mesh.
    
*** Meshtool extract data
Non ho capito come utilizzarla.

#+begin_example
[luca@probook SOFTX_2019_291]$ ./meshtool extract data
OpenMP thread utilization: 8 / 8 threads.
Data extract error: Insufficient parameters provided.
extract data: data defined on a mesh is extracted for a given submesh
parameters:
-submsh=<path>		 (input) path to basename of the submesh
-msh_data=<path>	 (input) file the data is extracted from.
-submsh_data=<path>	 (output) file the data is extracted into
-mode=<int>		 (optional) Data mode. 0 = nodal, 1 = element. Default is 0.

Note that the files defining the submesh must include a *.eidx and a *.nod file.
This files define how elements and nodes of the submesh map back into the original mesh.
The *.eidx and *.nod files are generated when using the "extract mesh" mode.
#+end_example

**** Parametri
- input:
  - path to basename of the submesh.
  - file the data is extracted from.
- output:
  - file the data is extracted into.
    
*** Meshtool extract surface
Non utile

#+begin_example
[luca@probook SOFTX_2019_291]$ ./meshtool extract surface
OpenMP thread utilization: 8 / 8 threads.
Surface extract error: Insufficient parameters provided.
extract surface: extract a sequence of surfaces defined by set operations on element tags
parameters:
-msh=<path>		 (input) path to basename of the mesh
-surf=<path>		 (output) list of names associated to the given operations
-op=operations		 (optional) list of operations to perform. By default, the
			 surface of the full mesh is computed.
-tag_file=<path>	 (optional) path to an alternative tag file {*.tags, *.btags}.
-edge=<deg. angle>	 (optional) surface elements connected to sharp edges will
			 be removed. A sharp edge is defined by the nodes which connect elements
			 with normal vectors at angles above the given threshold.
-ang_thr=<deg. angle>	 (optional) if set, surface traversal stops when angle between
			 current and starting normal vectors exceeds threshold.
-coord=<xyz>:<xyz>:..	 (optional) restrict surfaces to those elements reachable by
			 surface edge-traversal from the surface vertices closest to the given
			 coordinates. If -edge= is also provided, sharp edges will block
			 traversal, thus limit what is reachable.
-size=<float>		 (optional) surface edge-traversal is limited to the given
			 radius from the initial index.
-lower_size=<float>	 (optional) surface edge-traversal limitation lower size (for extracting bands).
-hybrid=<int>		 (optional) Write hybrid quad + tri surfaces. 1 == on, 0 == off. 0 is default.
-ifmt=<format>		 (optional) mesh input format.
-ofmt=<format>		 (optional) mesh output format. If set, the surfaces will also
			 be written as surface meshes.

The supported input formats are:
carp_txt, carp_bin, vtk, vtk_bin, mmg, neu, purk, obj, stellar, vcflow
The supported output formats are:
carp_txt, carp_bin, vtk, vtk_bin, vtk_polydata, mmg, neu, obj, stellar, vcflow, ensight_txt

The format of the operations is:
tagA1,tagA2,[surfA1,surfA2..]..[+-:]tagB1,tagB2,[surfB1..]..;tagA1,..[+-:]tagB1..;..
Tag regions separated by "," will be unified into submeshes and their surface computed.
Alternatively, surfaces can be provided directly by .surf surface files (only basename, no extension).
If two surfaces are separated by "-", the rhs surface will be removed from the
lhs surface (set difference). Similarly, using "+" will compute the surface union.
If the submeshes are separated by ":", the set intersection of the two submesh surfaces will be computed.
Individual operations are separated by ";".

The number of names provided with "-surf=" must match the number of operations. If no operations are provided,
the surface of the whole geometry will be extracted. Individual names are separated by ",".

Further restrictions can be added to the surface extraction with the -edge= , -coord= , -size= options.
#+end_example

**** Parametri
- input:
  - path to basename of the mesh
- output:
  - list of names associated to the given operations
- opzionali:
  - tutti i rimanenti (molti)
    
*** Meshtool extract volume
Questa funzione non credo mi servirà.

#+begin_example
[luca@probook SOFTX_2019_291]$ ./meshtool extract volume
OpenMP thread utilization: 8 / 8 threads.
Volume extract error: Insufficient parameters provided.
extract volume: extract elements inside a given box volume.
parameters:
-msh=<path>		 (input) path to basename of the mesh to extract from
-coord=x,xd,y,yd,z,zd	 (input) volume definition
-submsh=<path>		 (output) path to basename of the submesh to extract to
-mode=<int>		 (optional) mesh output mode. 0 = submesh, 1 = vtx file. Default is 0.
-ifmt=<format>		 (optional) mesh input format.
-ofmt=<format>		 (optional) mesh output format.

The supported input formats are:
carp_txt, carp_bin, vtk, vtk_bin, mmg, neu, purk, obj, stellar, vcflow
The supported output formats are:
carp_txt, carp_bin, vtk, vtk_bin, vtk_polydata, mmg, neu, obj, stellar, vcflow, ensight_txt
#+end_example

**** Parametri
- Input:
  - path to basename of the mesh to extract from.
  - volume definition.
- Output:
  - path to basename of the submesh to extract to.

*** Possibili test con meshtool
1. Provare a convertire da `vtk' o `.obj' a `vtk_bin' con `meshtool convert'
** VTUFileHandler
Framework scritto in Julia per effettuare il post processing di
simulazioni numeriche su interi domini usando il .vtu file system.

Vedi [[https://baxmittens.github.io/VTUFileHandler.jl/dev/][Documentazione]] su Github.

#+begin_src julia
  function VTUFile(file::String) ... end
  function Base.write(vtu::VTUFile, add_timestamp=true) ... end
#+end_src

Tramite queste funzioni si realizza la lettura e la scrittura di un file .vtu.
Installo il pacchetto nella REPL di Julia.

#+begin_src julia
  # Installo
  # using Pkg
  # Pkg.add("VTUFileHandler")

  # Includo
  using VTUFileHandler

  # Posso effettuare una "decompressione" dei campi di interesse.
  set_uncompress_keywords(["horsfield_order","radius","start_id"])

  # Leggo il file
  file = VTUFile("~/Documents/Polimi/Thesis/output-slicer/major_airways.vtu")
#+end_src

Tramite questo tool riesco a decifrare il contenuto della mesh ma non
riesco a modificarlo, né a crearne una nuova.  Magari ne *parlo con
Chiara*.

** DONE ITK-snap
Non ho idea di come questo possa servire.  Devo leggere meglio la
documentazione.

** vtkToolbox
Ho compilato le funzioni da sorgente su tutti i sistemi ma non si
riesce a procedere nell'installazione.  Forse posso provare con
Windows.

#+begin_src bash
  # Clonare
  cd ~/Repos
  git clone https://github.com/KIT-IBT/vtkToolbox

  # Generazione makefiles
  mkdir ~/Builds/vtkToolbox
  cd ~/Builds/vtkToolbox
  cmake ~/Repos/vtkToolbox

  # Generazione file binari
  make

  # Installazione --> Errore!
  make install
#+end_src

Installando anche il toolbox mediante il gestore degli add-on di
Matlab ho riscontrato un errore nell'utilizzo dei parametri.

#+begin_example
>> out=readVTK("major_airways.vtu", true)
Output argument "outStruct" (and possibly others) not assigned a value in the execution with "vtkRead" function.

Error in readVTK (line 20)
outStruct = vtkRead(filename, verbose);
#+end_example

*** Domande
- Come è riuscito Davide a compilare ed installare le librerie?

* 05.04.24
** DONE Meshtool convert
Provo a convertire da `vtk' o `.obj' a `vtk_bin' con `meshtool convert'.
#+begin_src bash
  ./meshtool convert                                                              \
      -imsh=/home/luca/Documents/Polimi/Thesis/output-slicer/trachea_segmentation \
      -ifmt=vtk                                                                   \
      -omsh=/home/luca/Documents/Polimi/Thesis/output-slicer/trachea_segmentation \
      -ofmt=vtk_bin
#+end_src

Riporto l'output con errore.  (Visualizzando con ParaView il file
`trachea_segmentation.vtk' questo risulta visibile.
#+begin_example
[luca@probook SOFTX_2019_291]$ ./meshtool convert                                 \
      -imsh=/home/luca/Documents/Polimi/Thesis/output-slicer/trachea_segmentation \
      -ifmt=vtk                                                                   \
      -omsh=/home/luca/Documents/Polimi/Thesis/output-slicer/trachea_segmentation \
      -ofmt=vtk_bin
OpenMP thread utilization: 8 / 8 threads.
Reading mesh: /home/luca/Documents/Polimi/Thesis/output-slicer/trachea_segmentation
Reading vtk file:                                      [============]
readVTKmesh error: File /home/luca/Documents/Polimi/Thesis/output-slicer/trachea_segmentation.vtk did not contain a complete mesh (points and elements)!
Aborting!
#+end_example

* 11.04.24
** DONE Scrivere mail Chiara
SCHEDULED: <2024-04-11 gio 15:00> DEADLINE: <2024-04-12 gio>
Il contenuto della mail si basa sui tentativi dei giorni scorsi.

#+begin_example
Ciao Chiara, come stai?
Ho provato i pacchetti che ha consigliato Davide.

1. `Meshtool': strumento che permette la manipolazione di mesh in alcuni formati: per la mesh in input: a) vtk b) vtk_bin c) obj; per la mesh in output: a) vtk b) vtk_bin c) vtk_polydata d) obj.  Esistono varie funzioni e ho testato quelle che sembravano le più utili:
- convert: Convert between different mesh formats.
- extract data: Data defined on a mesh is extracted for a given submesh.
- extract mesh: A submesh is extracted from a given mesh based on given element tags.
- extract surface: Extract a sequence of surfaces defined by set operations on element tags.
- extract volume: Extract elements inside a given box volume.

Le ultime quattro funzioni non sono utili al nostro caso (ma ho comunque l'output del terminale che ne illustra l'utilizzo) anche perché sono richiesti dei file che non ho, quindi mi sono dedicato al test della prima funzione con un file in input con formato .vtk e uno di output con formato vtk_bin ma ha restituito un errore in quanto la mesh non era completa.

2. `VTUFileHandler.jl': Framework scritto in Julia per effettuare il processing di simulazioni numeriche usando file .vtu.  Mediante la funzione `VTUFile()' sono riuscito ad importare il file .vtu e a decomprimere i suoi parametri ("horsefield_order", "radius" e "start_id") ma non riesco a modificare il contenuto di questo file o a crearne uno nuovo a partire dai dati decompressi.  Inoltre potrei lavorare solo da .vtu a .vtu quindi non saprei come potrebbe essermi utile. 

3. `vtkToolbox': Toolbox che avevo già testato su Matlab ma che non ero riuscito ad installare (né su Linux né su Windows).  Questo è lo stesso toolbox che Davide è riuscito ad utilizzare per importare il file .vtu e generare il .mat.  Ho provato ad installarlo su entrambi i sistemi operativi nelle due modalità: da add-in manager di Matlab e compilandolo da sorgente con cmake e con VisualStudio (rispettivamente su Linux e Windows).  Non sono riuscito ad installarlo.

Vorrei provare comunque a scrivere lo User Project per Chaste sulla base delle istruzioni del Tutorial per capire se fornisce dei messaggi di errore di qualche tipo dovuti al formato errato dei primi tratti delle vie aeree.  L'unica cosa che mi manca sono i file .stl relativi alla segmentazione lobare ma avrei bisogno di parlarti un attimo per quanto riguarda questa fase perchè 3DSlicer permette di fare la segmentazione con un suo tool ma ho bisogno della posizione dei punti fiduciari in corrispondenza delle fissure tra i lobi e non riesco a distinguere bene dalla TAC del neonato dove si trovino.
#+end_example

Mi ha risposto dandomi appuntamento Lunedì 15 Aprile.

** Richiesto colloquio con Chiara
SCHEDULED: <2024-04-15 lun 12:20-14:00>

*** TODO Raccogliere le domande da porgli
SCHEDULED: <2024-04-13 sab> DEADLINE: <2024-04-14 dom 21:00>

* 15.05.24                                                        :Colloquio:
In seguito al colloquio è stato concordato il fatto di iniziare a
scrivere la tesi.  Alcuni documenti mi verranno inviati da Chiara
prossimamente.  Nel frattempo vogliamo avere dei risultati includendo
anche Diodo e/o Switch (come li avevamo considerati in precedenza).

** TODO [#A] Rivedere i test16*

* 16.04.24
** Callbacks e integrale della corrente                          :Callbacks:
Ho provato a rivedere alcune parti del codice.  Qui di seguito il tentativo.

#+begin_src julia
  using DifferentialEquations
  using ModelingToolkit
  using ModelingToolkitStandardLibrary.Blocks
  using ModelingToolkitStandardLibrary.Electrical
  using Plots

  @parameters t
  D = Differential(t)

  @mtkmodel Res begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          R, [description = "Resistance value."]
      end
      @equations begin
          v ~ R * i
      end
  end

  # Qui un condensatore con capacità fissa che registra l'integrale
  # della corrente che lo attraversa.
  @mtkmodel Cap begin
      @extend v, i = oneport = OnePort()
      @variables begin
          ∫i(t) = eps()
      end
      @parameters begin
          C, [description = "Capacitance value."]
      end
      @equations begin
          D(v) ~ i / C
          D(∫i) ~ ifelse(∫i > 0, i, eps())
      end
  end

  @mtkmodel System begin
      @components begin
          R1 = Res(R = 1)
          C1 = Cap(C = 1)
          src = Constant(k = 1)
          gen = Voltage()
          gnd = Ground()
      end
      @equations begin
          connect(src.output, gen.V)
          connect(gen.p, R1.p)
          connect(R1.n, C1.p)
          connect(C1.n, gen.n, gnd.g)
      end
      @continuous_events begin
          # Prova delle callback.
          # [C1.∫i ~ .25] => [C1.v ~ 0]
          # Il seguente commentato non funziona perché si tiene in
          # considerazione il valore corrente per entrambi i valori di i
          # e ∫i.
          # [C1.i * t ~ - C1.∫i] => [C1.∫i ~ 0]
          # [C1.i ~ 0] => [C1.∫i ~ 0]
      end
  end

  @mtkbuild system = System()
  # u0 = [system.C1.v => 0, system.C1.i => 0]
  prob = ODEProblem(system, [], (0, 10), [])
  sol = solve(prob, Rodas4())
  plot(sol, idxs = [system.C1.i, system.C1.v, system.C1.∫i])

#+end_src

Non capisco se si possa modificare l'osservabilità di una variabile,
perché non si riesce a scrivere callbacks utilizzando tutte le
variabili di sistema.  Questa sera il sito della documentazione non
viene caricato correttamente.  Ritenterò domani.  L'unica cosa che ho
scoperto è che la condition può comprendere tutte le variabili ma
l'affect solo gli stati.

** DONE Colloquio con Davide                                     :Colloquio:
Deve ancora essere schedulato.

* 17.04.24
** Callbacks                                                     :Callbacks:
Posso utilizzare anche i parametri appartenenti a diversi componenti
(e.g. src.k per avere il valore in tensione del generatore).  Penso
che prima avevo sbagliato a calcolare le resistenze e le induttanze
variabili, nonché a calcolare il valore dell'integrale della corrente:

#+begin_src julia
  @mtkmodel Res begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra = 1, [description = "Resistance value."]
          Rb = 40, [description = "Resistance value."]
          V_FRC = 1
      end
      @variables begin
          ∫i(t) = 0
          R(t) = Ra + Rb
      end
      @equations begin
          R ~ Ra + Rb * (1 - ∫i / V_FRC)
          v ~ R * i
          D(∫i) ~ ifelse((((∫i < 0) & (i < 0)) | (∫i >= V_FRC)),
                         0,
                         ifelse(∫i >= 0,
                                i,
                                i))
      end
  end
#+end_src

* 19.04.24
** Switch
Un'idea che potrei utilizzare sarebbe quella della derivata della
corrente e della derivata della tensione di un OnePort.  In questo
modo posso sfruttare le callbacks per cambiare il valore di tali
derivate e ottenere i valori che voglio.

* 23.04.24
** TODO [#A] Importare file colloquio Chiara e Davide
Colloquio con Davide e Chiara
* 24.04.24
** DONE [#A] Modificare l'equazione dello switch
L'equazione da utilizzare è quella nel messaggio Whatsapp di Chiara
(tra i preferiti)
*** TODO [#A] Implementare triggers nello switch

* 25.04.24
** Modello morfometrico
Proporrei la separazione dei due ordini di modello presenti in
`AVTree.jl` per crearne due:
- `LowOrderModels.jl`  :: Comprende i componenti singoli.
- `HighOrderModels.jl` :: Comprende i moduli (Alveolus, Airway).

** TODO Modello integratore di corrente
È possibile creare un componente a basso livello che gestisca
l'integrazione della corrente?
