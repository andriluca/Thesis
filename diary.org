#+title: Diario dei Log del progetto
#+author: Luca Andriotto
#+STARTUP: overview latexpreview entitiespretty

Raccolgo in questo file cosa è stato fatto/scoperto ogni giorno.

* 11.10.23
- [X] La funzione =squarewave= è buggata e non può essere utilizzata come input del sistema in Julia. Posso riscriverla semplicemente
- Il numero di threads utilizzabile è settabile all'avvio della REPL (-t auto).
- La repl, da Emacs, non produce correttamente i grafici quindi è sempre meglio avere un terminale sotto mano
- [[file:src/test/test3.jl][test3.jl]] fa il suo dovere

* 12.10.23
- [[file:src/test/test3.jl][test3.jl]] non permette di estrarre i flussi (aka le correnti) dalle soluzioni. Passo alla soluzione cosiddetta acausale (circuitale). La soluzione sarà riportata in [[file:src/test/test4.jl][test4.jl]].

* 16.10.23                                               :Modello:Componenti:
- La modularità del circuito è realizzata mediante dei modelli
  appositi, chiamati `Block`s:

#+begin_src julia
  @mtkmodel Block begin
      @components begin
          in = Pin()
          out = Pin()
          resistor = Resistor(R = 1.0)
          capacitor = Capacitor(C = 1.0)
          ground = Ground()
      end
      @equations begin
          connect(in, resistor.p)
          connect(resistor.n, capacitor.p)
          connect(out, capacitor.p)
          connect(capacitor.n, ground.g)
      end
  end
#+end_src

Questi blocchi hanno un punto d'ingresso ed uno di uscita, comodi per
effettuare dei collegamenti più complessi con blocchi in cascata.

Il sistema quindi altro non è se non una composizione di blocchi:

#+begin_src julia
  @mtkmodel System begin
      @components begin
          block1 = Block(resistor.R = 2.0)
          block2 = Block(resistor.R = 2.0)
          constant = Constant(k = 1.0)
          source = Voltage()
          ground = Ground()
      end
      @equations begin
          connect(constant.output, source.V)
          connect(source.p, block1.in)
          connect(block1.out, block2.in)
          connect(source.n, ground.g)
      end
  end
#+end_src

Il codice completo è in [[file:src/test/test5.jl][test5.jl]].

- Vi sono altri due problemi ora:
  - [X] Generare diversi blocchi (airway e alveolo) con diverse
    strutture.
  - [ ] Rendere la resistenza `Rtube` variabile e dipendente
    dall'integrale della corrente.

- Nel file ~Albero.cir~, l'ultima riga rappresenta la trachea.
  enable, IN sono due ingressi, NodeAA e TrigAB sono due uscite
  (stando a quello che dice Chiara).

* 17.10.23                                               :Modello:Componenti:
- Per entrambi gli schematici si vedano i fogli stampati.  Queste sono
  le versioni senza resistenza variabile.

#+begin_src julia
  @mtkmodel Airway begin
      @components begin
          in       = Pin()
          out      = Pin()
          r_tube   = Resistor(R = 1.0)
          i_tube   = Inductor(L = 1.0)
          c_g      = Capacitor(C = 1.0)
          r_sw     = Resistor(R = 1.0)
          i_sw     = Inductor(L = 1.0)
          c_sw     = Capacitor(C = 1.0)
          r_tube_1 = Resistor(R = 1.0)
          i_tube_1 = Inductor(L = 1.0)
          ground   = Ground()
      end
      @equations begin
          connect(in, r_tube.p)
          connect(r_tube.n, i_tube.p)
          connect(i_tube.n, c_g.p, i_sw.p, r_tube_1.p)
          connect(i_sw.n, r_sw.p)
          connect(r_sw.n, c_sw.p)
          connect(r_tube_1.n, i_tube_1.p)
          connect(out, i_tube_1.n)
          connect(c_g.n, c_sw.n, ground.g)
      end
  end
#+end_src

#+begin_src julia
  @mtkmodel Alveolo begin
      @components begin
          in     = Pin()
          out    = Pin()
          r_tube = Resistor(R = 1.0)
          i_tube = Inductor(L = 1.0)
          c_ga   = Capacitor(C = 1.0)
          i_t    = Inductor(L = 1.0)
          r_t    = Resistor(R = 1.0)
          c_t    = Capacitor(C = 1.0)
          r_s    = Resistor(R = 1.0)
          c_s    = Resistor(R = 1.0)
          ground   = Ground()
      end
      @equations begin
          connect(in, r_tube.p)
          connect(r_tube.n, i_tube.p)
          connect(i_tube.n, c_ga.p, i_t.p, out)
          connect(i_t.n, r_t.p)
          connect(r_t.n, c_t.p)
          connect(c_t.n, c_s.p, r_s.p)
          connect(c_ga.n, c_s.n, r_s.n, ground.g)
      end
  end
#+end_src

- [X] Lavorare sull'importazione di file CSV in cui ciascuna colonna
  corrisponde ad un array di variabili dello stesso tipo (tutte
  resistenze...).

* 18.10.23                                                            :Input:

Tramite questo codice posso importare un CSV come DataFrame.
#+begin_src julia
  # Read a DataFrame from CSV file
  df = CSV.read("data.csv", DataFrame)
  r = df.x1
#+end_src

- [X] Consulta il materiale fornito da Chiara per messaggio

* 20.10.23                              :Modello:Verilog:Parametri:Variabili:

Devo utilizzare IA{D, E, F, G, H, I}, IB{L, A, B} di `Albero.cir`


#+begin_example
IBB ( TrigBLB NodeBLA NodeBBA TrigBBB Vcharge ) alveolo_completo_luglio La= 5.896531e-03 Lb= 5.236159e+00 Ra= 2.282920e+02 Rb= 1.114955e+04 Chargeth= 5.185713e-07 Ccap= 2.463766e-07 Vin_th= 7.098371e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IBA ( TrigBLB NodeBLA NodeBAA TrigBAB Vcharge ) alveolo_completo_luglio La= 5.687354e-03 Lb= 5.050408e+00 Ra= 2.017423e+02 Rb= 9.852891e+03 Chargeth= 5.958497e-07 Ccap= 2.464514e-07 Vin_th= 6.794462e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IBL ( TrigAHB NodeAHA NodeBLA TrigBLB ) zwall_semplificato_veriloga La= 1.290849e-03 Lb= 1.159971e+00 Ra= 3.097440e+01 Rb= 1.512758e+03 Rws= 1.461035e+07 Lws= 9.016810e-01 Cws= 1.003855e-10 Chargeth= 5.910861e-07 Ccap= 5.722034e-10 Vin_th= 5.588244e+00 Vgravity= 0
IAH ( TrigAFB NodeAFA NodeAHA TrigAHB ) zwall_semplificato_veriloga La= 1.653093e-03 Lb= 1.485488e+00 Ra= 3.554331e+01 Rb= 1.735899e+03 Rws= 8.703449e+06 Lws= 5.994469e-01 Cws= 1.685156e-10 Chargeth= 9.427715e-07 Ccap= 9.126539e-10 Vin_th= 5.289833e+00 Vgravity= 0
IAF ( TrigADB NodeADA NodeAFA TrigAFB ) zwall_semplificato_veriloga La= 1.166141e-03 Lb= 1.047907e+00 Ra= 2.231464e+01 Rb= 1.089824e+03 Rws= 9.257208e+06 Lws= 7.164089e-01 Cws= 1.584351e-10 Chargeth= 8.396596e-07 Ccap= 8.128360e-10 Vin_th= 4.990351e+00 Vgravity= 0
IAD ( TrigACB NodeACA NodeADA TrigADB ) zwall_semplificato_veriloga La= 1.852803e-03 Lb= 1.664949e+00 Ra= 3.100029e+01 Rb= 1.514023e+03 Rws= 4.186147e+06 Lws= 3.705082e-01 Cws= 3.503620e-10 Chargeth= 1.744963e-06 Ccap= 1.689219e-09 Vin_th= 4.666378e+00 Vgravity= 0

[...]

IAE ( TrigADB NodeADA NodeAEA TrigAEB Vcharge ) alveolo_completo_luglio La= 6.440085e-03 Lb= 5.718839e+00 Ra= 3.109214e+02 Rb= 1.518509e+04 Chargeth= 3.642283e-07 Ccap= 2.462271e-07 Vin_th= 7.926677e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IAG ( TrigAFB NodeAFA NodeAGA TrigAGB Vcharge ) alveolo_completo_luglio La= 6.908560e-03 Lb= 6.134848e+00 Ra= 4.012746e+02 Rb= 1.959785e+04 Chargeth= 2.699475e-07 Ccap= 2.461359e-07 Vin_th= 8.694383e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IAI ( TrigAHB NodeAHA NodeAIA TrigAIB Vcharge ) alveolo_completo_luglio La= 7.229610e-03 Lb= 6.419942e+00 Ra= 4.759710e+02 Rb= 2.324594e+04 Chargeth= 2.198790e-07 Ccap= 2.460874e-07 Vin_th= 9.256451e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
#+end_example

** IAD ( TrigACB NodeACA NodeADA TrigADB ) zwall_semplificato_veriloga 
La= 1.852803e-03 -- sarebbe la I
Lb= 1.664949e+00
Ra= 3.100029e+01 -- resistenza in aria
Rb= 1.514023e+03 -- quello da aggiungere per avere quella in acqua (rl - ra)
Rws= 4.186147e+06
Lws= 3.705082e-01
Cws= 3.503620e-10
Chargeth= 1.744963e-06 -- V_FRC
Ccap= 1.689219e-09 -- C_g
Vin_th= 4.666378e+00 -- tensione su primo diodo
Vgravity= 0

** IAE ( TrigADB NodeADA NodeAEA TrigAEB Vcharge ) alveolo_completo_luglio
La= 6.440085e-03
Lb= 5.718839e+00 
Ra= 3.109214e+02 
Rb= 1.518509e+04 
Chargeth= 3.642283e-07 
Ccap= 2.462271e-07 
Vin_th= 7.926677e+00 
Vgravity= 0 
Lti= 5.795540e-04 
Rti= 1200 
Cti= 2.400000e-05 
Rs= 80000 
Cs= 2.100000e-05

** IAF ( TrigADB NodeADA NodeAFA TrigAFB ) zwall_semplificato_veriloga
La= 1.166141e-03
Lb= 1.047907e+00
Ra= 2.231464e+01
Rb= 1.089824e+03
Rws= 9.257208e+06
Lws= 7.164089e-01
Cws= 1.584351e-10
Chargeth= 8.396596e-07
Ccap= 8.128360e-10
Vin_th= 4.990351e+00
Vgravity= 0

** IAG ( TrigAFB NodeAFA NodeAGA TrigAGB Vcharge ) alveolo_completo_luglio
La= 6.908560e-03
Lb= 6.134848e+00
Ra= 4.012746e+02
Rb= 1.959785e+04
Chargeth= 2.699475e-07
Ccap= 2.461359e-07
Vin_th= 8.694383e+00
Vgravity= 0 
Lti= 5.795540e-04
Rti= 1200
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IAH ( TrigAFB NodeAFA NodeAHA TrigAHB ) zwall_semplificato_veriloga
La= 1.653093e-03
Lb= 1.485488e+00
Ra= 3.554331e+01
Rb= 1.735899e+03
Rws= 8.703449e+06
Lws= 5.994469e-01
Cws= 1.685156e-10
Chargeth= 9.427715e-07
Ccap= 9.126539e-10
Vin_th= 5.289833e+00
Vgravity= 0

** IAI ( TrigAHB NodeAHA NodeAIA TrigAIB Vcharge ) alveolo_completo_luglio
La= 7.229610e-03
Lb= 6.419942e+00
Ra= 4.759710e+02
Rb= 2.324594e+04
Chargeth= 2.198790e-07
Ccap= 2.460874e-07
Vin_th= 9.256451e+00
Vgravity= 0
Lti= 5.795540e-04
Rti= 1200 
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IBL ( TrigAHB NodeAHA NodeBLA TrigBLB ) zwall_semplificato_veriloga 
La= 1.290849e-03 
Lb= 1.159971e+00 
Ra= 3.097440e+01 
Rb= 1.512758e+03 
Rws= 1.461035e+07 
Lws= 9.016810e-01 
Cws= 1.003855e-10 
Chargeth= 5.910861e-07 
Ccap= 5.722034e-10 
Vin_th= 5.588244e+00 
Vgravity= 0

** IBB ( TrigBLB NodeBLA NodeBBA TrigBBB Vcharge ) alveolo_completo_luglio
La= 5.896531e-03
Lb= 5.236159e+00
Ra= 2.282920e+02
Rb= 1.114955e+04
Chargeth= 5.185713e-07
Ccap= 2.463766e-07
Vin_th= 7.098371e+00
Vgravity= 0
Lti= 5.795540e-04
Rti= 1200
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IBA ( TrigBLB NodeBLA NodeBAA TrigBAB Vcharge ) alveolo_completo_luglio 
La= 5.687354e-03 
Lb= 5.050408e+00 
Ra= 2.017423e+02 
Rb= 9.852891e+03 
Chargeth= 5.958497e-07 
Ccap= 2.464514e-07 
Vin_th= 6.794462e+00 
Vgravity= 0 
Lti= 5.795540e-04 
Rti= 1200 
Cti= 2.400000e-05 
Rs= 80000 
Cs= 2.100000e-05

Questi sono tutti i dati che ho trovato ma non so interpretare i nomi dei componenti nel file `Albero.cir` con i corrispettivi nel modello.

Penso sia necessario elencare i parametri e le variabili in gioco (dal documento cartaceo fornito da Chiara).

** Parametri
*** Non-terminal units (Airway)

| Parametro                     | Simbolo |   Valore | Unità           |
|-------------------------------+---------+----------+-----------------|
| Air density                   | \rho_a      | 1.132e-2 | cmH_{2}O * s^2 / m^2 |
| Air viscosity                 | \mu_a      | 1.739e-7 | cmH_{2}O * s       |
| Atmospheric pressure          | P_{at}     |     1033 | cmH_{2}O           |
| Fetal fluid density           | \rho_l      |  1.006e1 | cmH_{2}O * s^2 / m^2 |
| Fetal fluid viscosity         | \mu_l      | 8.667e-6 | cmH_{2}O * s       |
| Radius at FRC                 | r_{FRC}    |          | cm              |
| Surface tension               | \gamma       |      .04 | cm * cmH_{2}O      |
| Young modulus of soft tissues | Y_s      |      600 | [N / m^2]        |
| (?) Density                   | \rho_s      |      .88 | [g / mL?]       |
| (?) Viscosity                 | \mu_s      |     1.06 | g / mL          |

Il valore di viscosità non mi convince (nemmeno nell'unità di misura).

*** Terminal units (Alveoli)

| Parametro                                      | Simbolo |        Valore | Unità                                  |
|------------------------------------------------+---------+---------------+----------------------------------------|
| Air density                                    | \rho_a      |      1.132e-2 | cmH_{2}O*s^2/m^2                            |
| Air viscosity                                  | \mu_a      |      1.739e-7 | cmH_{2}O*s                                |
| Atmospheric pressure                           | P_{at}     |          1033 | cmH_{2}O                                  |
| Fetal fluid density                            | \rho_l      |       1.006e1 | cmH_{2}O*s^2/m^2                            |
| Fetal fluid viscosity                          | \mu_l      |      8.667e-6 | cmH_{2}O*s                                |
| Radius at FRC                                  | r_{FRC}    |               | cm                                     |
| Surface tension                                | \gamma       |           .04 | cm*cmH_{2}O                               |
| Young modulus soft tissues                     | Y_s      |           600 |                                        |
| Tissue compliance related to stress relaxation | C_s      |      7e-8 * 3 |                                        |
| Static tissue compliance                       | C_t      |      8e-8 * 3 | L / cmH_{2}O                              |
| Tissue inertance                               | I_t      | .00069/300*NA | cmH_{2}O * s^2 / L                         |
| Tissue resistance related to stress relaxation | R_s      |           8e6 | cmH_{2}O * s / L                          |
| Newtonian tissue resistance                    | R_t      |          12e4 | cmH_{2}O * s / L                          |
| (?) Density                                    | \rho_s      |           .88 |                                        |
| (?) Viscosity                                  | \mu_s      |          1.06 | [g/mL da documento ma non mi convince] |

** Variabili
*** Non-terminal units

| Variabili                                     | Simbolo | Range              | Unità          | Formula                                                                |
|-----------------------------------------------+---------+--------------------+----------------+------------------------------------------------------------------------|
| Capillary pressure due to air-fluid interface | V_{th}     | .2 - 9.1           | cmH_{2}O          | \dfrac{\gamma}{r_{FRC}} in air, 0 otherwise.                                   |
| Airway Resistance                             | R_{tube}   |                    | cmH_{2}O * s / L  | R_a + (R_l - R_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})         |
| Resistance (air-filled)                       | R_{a}      | .64 - 4.50e4       | cmH_{2}O * s / L  | \dfrac{8\mu_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                          |
| Resistance (liquid-filled)                    | R_{l}      | 32 - 2.24e6        | cmH_{2}O * s / L  | \dfrac{8\mu_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                          |
| Volume at FRC                                 | V_{FRC}    |                    | L              | \pi\cdot {r_{FRC}}^2 \cdot l_{FRC}                                                      |
| Flow*                                         | \dot{V} |                    | [L / s]        |                                                                        |
| Airway inertance                              | I_{tube}   |                    | cmH_{2}O * s^2 / L | I_a + (I_l - I_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})         |
| Inertance (air-filled)                        | I_{a}      | .95e-2 - .91       | cmH_{2}O * s^2 / L | \dfrac{8\rho_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                          |
| Inertance (liquid-filled)                     | I_{l}      | 8.58 - 816.22      | cmH_{2}O * s^2 / L | \dfrac{8\rho_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                          |
| Shunt airway compliance due to gas            | C_g      |                    | L / cmH_{2}O      | C_{FRC}\cdot (\dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}}) in air, 0 otherwise. |
| Airway compliance at FRC                      | C_{FRC}    | 2.27e-13 - 4.32e-7 | L / cmH_{2}O      | \dfrac{\pi\cdot {r_{FRC}}^2 \cdot l_{FRC}}{P_{at}}                                         |
| Airway tissue shunt impedance                 | Z_w      |                    | cmH_{2}O * s / L  | R_{ws} + j \cdot (\omega \cdot I_{ws} - \dfrac{1}{\omega \cdot C_{ws}})                               |
| Resistance of the soft tissues**              | R_{sw}     |                    | cmH_{2}O * s / L  | \dfrac{h_k \cdot \mu_{s}}{2\pi {r_{FRC}}^3 \cdot l_{FRC}}                                     |
| Inertance of the soft tissues**               | I_{sw}     |                    | cmH_{2}O * s^2 / L | \dfrac{h_k \cdot \rho_{s}}{2\pi r_{FRC} \cdot l_{FRC}}                                        |
| Compliance of the soft tissues**              | C_{sw}     |                    | L / cmH_{2}O      | \dfrac{2\pi {r_{FRC}}^3 \cdot l_{FRC}}{h_k \cdot \Y_{s}}                                    |
|                                               | h_k      |                    | [cm?]          | \sqrt{{r_k}^2 + \dfrac{w_{ak}}{\pi}} - r_k                                     |
|                                               | w_{ak}     |                    | [?]            | .033(2\pi\cdot r_k \cdot 1000 - .08) + .056                                       |
| Resistance of airway soft tissues**           | R_{ws}     | 1.14e1 - 2.27e7    | cmH_{2}O * s / L  | \dfrac{h_k \cdot \mu_{s}}{2\pi {r_{FRC}}^3 \cdot l_{FRC}}                                     |
| Inertance of airway soft tissues**            | I_{ws}     | 5.77e-4 - 1.13e-1  | cmH_{2}O * s^2 / L | \dfrac{h_k \cdot \rho_{s}}{2\pi r_{FRC} \cdot l_{FRC}}                                        |
| Compliance of airway soft tissues**           | C_{ws}     | 5.64e-11 - 1.28e-4 | L / cmH_{2}O      | \dfrac{2\pi {r_{FRC}}^3 \cdot l_{FRC}}{h_k \cdot \Y_{s}}                                    |


*: Quando facciamo l'integrale nel tempo, gli estremi temporali significano il tempo in cui l'interfaccia aria-liquido entra nella airway e il tempo in cui essa esce.
**: Sono la stessa cosa?? Assumo la loro uguaglianza nel mio ragionamento.

*** Terminal units

| Variabili                                                        | Simbolo | Range         | Unità          | Formula                                                                                                               |
|------------------------------------------------------------------+---------+---------------+----------------+-----------------------------------------------------------------------------------------------------------------------|
| Capillary pressure due to air-fluid interface of the acinar unit | v_{thA}    | 1.2 - 10.3    | cmH_{2}O          | \dfrac{2\gamma}{r_k} at the interface, 0 otherwise.                                                                         |
| Airway Resistance                                                | R_{tube}   |               | cmH_{2}O * s / L  | \dfrac{R_a + (R_l - R_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})}{\frac{V_0 + \int\limits_{t_0}^{t} {\dot{V} dt}}{V_{FRC,A}}} |
| Resistance (air-filled)                                          | R_a      | .64 - 4.50e4  | cmH_{2}O * s / L  | \dfrac{8\mu_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                                                                         |
| Resistance (liquid-filled)                                       | R_l      | 32 - 2.24e6   | cmH_{2}O * s / L  | \dfrac{8\mu_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                                                                         |
| Volume at FRC                                                    | V_{FRC}    |               | L              | \pi\cdot {r_{FRC}}^2 \cdot l_{FRC}                                                                                                     |
| Volume at FRC [acinar?]                                          | V_{FRC,A}  |               | L              | \dfrac{FRC}{N_A}                                                                                                       |
|                                                                  | V_0      |               | L              | \dfrac{\text{initial liquid volume}}{N_A}                                                                              |
| Airway inertance                                                 | I_{tube}   |               | cmH_{2}O * s^2 / L | I_a + (I_l - I_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}}) in air, 0 otherwise.                                   |
| Inertance (air-filled)                                           | I_a      | .95e-2 - .91  | cmH_{2}O * s^2 / L | \dfrac{8\rho_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                                                                         |
| Inertance (liquid-filled)                                        | I_l      | 8.58 - 816.22 | cmH_{2}O * s^2 / L | \dfrac{8\rho_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                                                                         |
| Shunt terminal unit compliance due to gas                        | C_{gA}     |               | L / cmH_{2}O      | C_{FRC,A}\cdot (\dfrac{\int\limits_{t_i}^{t_fA} {\dot{V} dt}}{V_{FRC,A}}) in air, 0 otherwise.                                           |
|                                                                  | C_{FRC,A}  |               | L / cmH_{2}O      | \dfrac{\text{FRC}}{P_{at} N_A} + \dfrac{\pi {r_FRC}^2 l_{FRC}}{P_{at}}                                                              |
| Acinar tissue impedance                                          | Z_{tissue} |               | cmH_{2}O * s / L  | R_t + j \cdot (\omega\cdot I_t - \dfrac{1}{\omega \cdot C_t}) + \dfrac{R_s}{1 + j\omega C_s R_s}                                                       |

** DONE Domande da fare
1. La resistenza `R_{tube}` ha diverse formule per i due modelli distinti (ossia per airway e alveolo)? yes
2. Nel parametro `I_t` il valore NA è il numero di Avogadro? Non saprei, non ci serve però

* 23.10.23                                                          :Verilog:
- Continuo il lavoro del 20.10 per sistemare le variabili ed i
  parametri del modello per capire di più.
- Rivedo il file in Verilog per comprendere le formule implementate.

** Unità non terminali
- [ ] Capire cosa significa `inout`
- [ ] Capire il ruolo di `through`
- [ ] Cosa sono nodeA e nodeC?
- [X] Cosa significa `cross` in Verilog? vedi [[https://verilogams.com/refman/modules/analog-procedural/timing.html#index-8][questa risorsa]]
- [ ] Non capisco perché non considero la caduta di potenziale sulla
  capacità ma quella tra il nodo `through` e `nodeC`.

Crea degli input (pin):
1. enable
2. IN

Crea degli output:
1. triggerOut

Vi sono una serie di variabili, istanziate come intere o reali.

*Intere*:
1. integration_en
2. sw_state: questa flag sembra controllare lo "stato" del programma.

*Reali*:
1. Lvalue
2. Rvalue
3. Cvalue
4. threshold
5. charge
6. trigout
7. thresholdb

Noto che ci sono i parametri "simili" a quelli del file `Albero.cir`
(i.e. stessi nomi).

#+begin_src verilog
  // VerilogA for BIO, cella_zwall, veriloga

  `include "constants.vams"
  `include "disciplines.vams"

  module zwall_semplificato_veriloga_events(enable, IN, OUT, triggerOUT);

     // [Inputs]
     input enable;
     electrical enable;
     inout IN, OUT;
     electrical IN, OUT, through;
     electrical integration;
     // [Outputs]
     output triggerOUT;
     electrical triggerOUT;

     // [Nodi]
     electrical nodeA, nodeC; //, nodeB;

     ground gnd;

     // [Parametri simili ad `Albero.cir`]
     parameter La       = 1e-6;
     parameter Lb       = 10e-6;
     parameter Ra       = 1e-3;
     parameter Rb       = 10e-3;
     parameter Rws      = 1;
     parameter Lws      = 1e-3;
     parameter Cws      = 1e-6;
     parameter Chargeth = 10e-6;
     parameter Ccap     = 1e-6;

     parameter Vin_th   = 1;
     parameter Vgravity = 0;

     // Variabili (intere e reali)
     integer   integration_en = 0, sw_state=1;
     real	  Lvalue = 0, Rvalue = 0, Cvalue = 0;
     real	  threshold = 1, charge = 0, trigout = 0, thresholdb = 0.5;

     analog begin

        @(cross(V(enable, gnd) - 0.5, +1)) begin
           integration_en = 1;
        end

        V(integration, gnd) <+ idt(integration_en * I(through, OUT)) / Chargeth;
        charge = min(V(integration, gnd), 1);

        @(cross(charge - threshold, +1)) begin
           sw_state = 0;
           trigout  = 1;
        end

        V(triggerOUT, gnd) <+ transition(trigout, 0, 10n, 10n);

        // [A seconda del valore di `sw_state` associo diversi valori a {R, L, C}value].
        if (sw_state == 1)
          begin
             Lvalue = La + Lb * max(0, (1 - charge));
             Rvalue = Ra + Rb * max(0, (1 - charge));
             Cvalue = max(1e - 12, Ccap * charge);
          end
        else
          begin
             Lvalue = La;
             Rvalue = Ra;
             Cvalue = Ccap;
          end

        // [Per ora lascio stare]
        V(IN, nodeA)       <+ V(enable, gnd) * transition(sw_state*Vin_th, 0, 10u, 10u) + Vgravity; // *restricted
        // [Lvalue e Rvalue corrispondono a L_{tube}/2 e a R_{tube}/2 rispettivamente]
        V (nodeA, through) <+  Lvalue * ddt(I(nodeA, through)) + (Rvalue) * I(nodeA, through);

        I (through, nodeC) <+ Cws * ddt(V(through, nodeC));
        V (nodeC, gnd)     <+ Rws * I(nodeC, gnd) + Lws * ddt(I(nodeC, gnd));
        // [OUT probabilmente è l'ultimo nodo sulla destra.]
        V(through, OUT)    <+ Rvalue * I(through, OUT) + Lvalue * ddt(I(through, OUT));
        I(through, gnd)    <+ ddt(Cvalue * V(through, gnd));

     end

  endmodule
  #+end_src

** Unità terminali (alveoli)

#+begin_src verilog
  // VerilogA for BIO, alveolo_veriloga, veriloga

  `include "constants.vams"
  `include "disciplines.vams"

  module alveolo_completo_aprventitre(enable, IN, OUT, triggerOUT, Vcharge);

     // [Nodi di Input -- Pin]
     input enable;
     electrical enable;
     input  Vcharge;
     electrical Vcharge;

     // [Porte leggibili?]
     inout IN, OUT;
     electrical IN, OUT;

     // [Nodi di Output -- Port]
     output triggerOUT;
     electrical triggerOUT;

     // [Nodi]
     electrical nodeA, nodeB;

     ground gnd;

     // [Parametri simili ad `Albero.cir`]
     parameter La       = 1e-6;
     parameter Lb       = 10e-6;
     parameter Ra       = 1e-3;
     parameter Rb       = 10e-3;
     parameter Chargeth = 10e-6;
     parameter Ccap     = 1e-6;
     parameter Vin_th   = 1;
     parameter Vgravity = 0;
     parameter Lti      = 1e-3;
     parameter Rti      = 1e-3;
     parameter Cti      = 1e-3;
     parameter Rs       = 1;
     parameter Cs       = 1e-6;

     // [Variabili intere e reali]
     integer integration_en = 0;
     real	Lvalue = 0, Rvalue = 0, Cvalue = 0, Rvalb = 0;
     real	threshold = 1;
     real	Vinteg = 0;
     real	VintegARIA = 0;
     real	charge = 0;
     real	chargeb = 0;
     real	chargec = 0;
     real	aux = 0;
     real	trigout = 0;
     real	temp = 1;
     real	Ctival = Cti, Csval = Cs, mult = 1, sw_state = 1;
     real	Vin_th2 = 0;
     real	th_swap = 0; 

     analog begin
        // la `@` consiste in una tipologia di if specifica per gli eventi, praticamente.
        @(cross(V(enable, gnd) - 0.5, +1)) begin
           integration_en = 1;
        end

        // Faccio l'integrazione quando la tensione su enable ha attraversato lo 0 in rising.
        // Se supero la threshold in modalità rising.
        VintegARIA = idt(integration_en * I(nodeA, OUT));
        // Faccio l'integrazione in ogni caso.
        Vinteg     = idt(I(nodeA, OUT));

        // Prendo il minimo tra 1 e il massimo tra 0 e il rapporto tra
        // l'integrale della corrente con il volume massimo a FRC.
        // Charge rappresenta la percentuale di volume occupata
        // dall'aria.

        charge  = min(1, max(0, VintegARIA / Chargeth));  //serve per R, l e cambio Vin_th e Vin_th2
        // Uso una costante per V_FRC
        chargec = min(1, max(0, VintegARIA / (2.5399e-4)));

        // Uso altre costanti
        chargeb = max(0,((Vinteg - 1.27e-4) / (2.5399e-4 - 1.27e-4)));

        aux  = min(1, (0.06 + chargeb));
        temp = 1;  //modifica del 21 luglio

        @(cross(chargec - threshold, +1)) begin //fine dell'integrazione della carica
           trigout  = 1; 
           sw_state = 0;
        end

        @(cross((charge - 1), +1)) begin
           th_swap = 1;
        end

        V(triggerOUT, gnd) <+ transition (trigout, 0, 10n, 10n);

        Rvalb = (Ra / aux);

        Lvalue = La + Lb * max(0,(1 - charge));
        Rvalue = (Rb / aux) * max(0,(1 - charge));

        Ctival = Cti / (temp); // va da Cti a Cti/15 quando ho raggiunto chargeb/2
        Csval  = Cs / (temp);// come sopra
        Cvalue = max(1e-15, Ccap * chargec);

        Vin_th2 = 0.08 / (pow((3 * max(VintegARIA / 100, 1e-8)) / (12.56), 1/3));

        V(IN, nodeA)   <+ V(enable, gnd) * Vin_th * transition ((1-th_swap), 0, 10u, 10u);
        V (nodeA, OUT) <+ Lvalue * ddt(I(nodeA, OUT)) +(Rvalb + Rvalue) * I(nodeA, OUT) + Vin_th2 * transition (th_swap, 0, 10u, 10u);
        I(OUT, gnd)    <+ Cvalue * ddt(V(OUT, gnd));
        V(OUT, nodeB)  <+ Lti * ddt(I(OUT, nodeB)) + Rti * I(OUT, nodeB) + idt(I(OUT, nodeB)) / (transition(Ctival * mult, 0, 10u, 10u));
        I(nodeB, gnd)  <+ V(nodeB, gnd) / Rs + transition(Csval * mult, 0, 10u, 10u) * ddt(V(nodeB, gnd));

     end
  endmodule
#+end_src

* 24.10.23                                   :Modello:Parametri:Bibliografia:
Riprendo le domande che avevo ieri.
- `inout`: tipo una porta readable.

Considerazioni:
- Una buona risorsa dove iniziare ad imparare il Verilog è [[https://verilogams.com][questa]].

** Colloquio con Chiara
Dice che forse è meglio tentare un approccio iterativo dopo il quale
posso integrare la corrente nel tempo di simulazione per cambiare i
valori di resistenza.  Dice che posso andare avanti con Julia se posso
inserire dei componenti variabili (tempo varianti o in funzione di
altre variabili come V(out) o I(nodeA, out)).  Le faccio qualche
domanda. Ora so a cosa corrispondono i vari componenti nel modello, in
termini di simboli utilizzati nel file `Albero.cir`.

** Non terminali
| ".cir"   | Modello cartaceo                                                   |
|----------+--------------------------------------------------------------------|
| La       | Induttanza in aria                                                 |
| Lb       | Quello da aggiungere per avere l'induttanza nel liquido (I_l - I_a)  |
| Ra       | Resistenza in aria                                                 |
| Rb       | Quello da aggiungere per avere la resistenza nel liquido (rl - ra) |
| Rws      | Resistenza del ramo sotto                                          |
| Lws      | Induttanza del ramo sotto                                          |
| Cws      | capacità del ramo sotto                                            |
| Chargeth | V_{FRC}                                                               |
| Ccap     | C_g                                                                 |
| Vin_th    | Tensione sul primo diodo (aka V_{th})                                 |
| Vgravity |                                                                    |

** Terminali
| ".cir"   | Modello cartaceo                                                   |
|----------+--------------------------------------------------------------------|
| La       | Induttanza in aria                                                 |
| Lb       | Quello da aggiungere per avere l'induttanza nel liquido (I_l - I_a)  |
| Ra       | Resistenza in aria                                                 |
| Rb       | Quello da aggiungere per avere la resistenza nel liquido (rl - ra) |
| Chargeth | V_{FRC}                                                               |
| Ccap     | C_g                                                                 |
| Vin_th    | Tensione sul primo diodo (aka V_{th})                                 |
| Vgravity |                                                                    |
| Lti      | Vedi grafico                                                       |
| Rti      | Vedi grafico                                                       |
| Cti      | Vedi grafico                                                       |
| Rs       | Vedi grafico                                                       |
| Cs       | Vedi grafico                                                       |

* 25.10.23                                               :Modello:Componenti:
** DONE Esiste un componente "Diodo" in Julia                   :Componenti:
Non sembrerebbe esistere un componente "Diodo" nella libreria standard
di `ModelingToolkit`.

** Scrivo tutte le equazioni differenziali in Julia
NodeC non corrisponde alla sua definizione nel modello elettrico: è
come se l'induttanza e la resistenza sopra fossero scambiate di posto
con la capacità che sta sotto (il nodo non è così importante stando a
quello che dice Chiara).

** Quali sono le variabili in funzione del tempo di cui conosciamo l'andamento? :Variabili:
Probabilmente anche quest'informazione la posso ricavare dal Verilog.
Sicuramente la forma d'onda della tensione in ingresso.  Non so se
sappiamo qualcosa del flusso

** DONE Quali sono le equazioni differenziali che devo risolvere in ciascun modulo?
Sicuramente sono contenute nei file Verilog quindi ripartirei da lì.
Il Verilog contiene queste equazioni.
*** Non terminali
#+begin_src verilog
  // 1 -- [tensione tra Rvalue e Lvalue]
  V (nodeA, through) <+ Lvalue * ddt(I(nodeA, through)) + (Rvalue) * I(nodeA, through);
  // 2 -- [corrente attraverso Cws]
  I (through, nodeC) <+ Cws * ddt(V(through, nodeC));
  // 3 -- [tensione sul blocco Rws-Lws]
  V (nodeC, gnd)     <+ Rws * I(nodeC, gnd) + Lws * ddt(I(nodeC, gnd));
  // 4 -- [tensione su Cvalue]
  // [OUT probabilmente è l'ultimo nodo sulla destra.]
  V(through, OUT)    <+ Rvalue * I(through, OUT) + Lvalue * ddt(I(through, OUT));
  // 5 -- [Corrente attraverso Cvalue]
  I(through, gnd)    <+ ddt(Cvalue * V(through, gnd));
#+end_src

*** Terminali
#+begin_src verilog
  // 1 -- [tensione sul blocco vin_th2-Rvalue-Lvalue]
  V (nodeA, OUT) <+ Lvalue * ddt(I(nodeA, OUT)) +(Rvalb + Rvalue) * I(nodeA, OUT) + Vin_th2 * transition (th_swap, 0, 10u, 10u);
  // 2 -- [corrente attraverso Cvalue]
  I(OUT, gnd)    <+ Cvalue * ddt(V(OUT, gnd));
  // 3 -- [tensione sul blocco Lt-Rt-Ct?] [sembrerebbe esclusa la capacità]
  V(OUT, nodeB)  <+ Lti * ddt(I(OUT, nodeB)) + Rti * I(OUT, nodeB) + idt(I(OUT, nodeB)) / (transition(Ctival * mult, 0, 10u, 10u));
  // 4 -- [corrente attraverso il parallelo tra Cs e Rs] 
  I(nodeB, gnd)  <+ V(nodeB, gnd) / Rs + transition(Csval * mult, 0, 10u, 10u) * ddt(V(nodeB, gnd));
#+end_src

** DONE Cosa s'intende per `transition` in Verilog?
Stando a quanto scritto [[https://verilogams.com/refman/basics/expressions.html#transition][qui]]:
#+begin_example
Converts a piecewise constant waveform, operand, into a waveform that has controlled transitions. 
#+end_example

Quindi converte una forma d'onda costante a tratti (immagino una
"spezzata") in una forma d'onda con transizioni controllate.

** A cosa servono tutte le flag del Verilog?                       :Verilog:
Non penso sia per ora necessario
* 27.10.23                                          :Componenti:Bibliografia:
Ho guardato due video del canale di Julia:
- [[https://www.youtube.com/watch?v=q8SzFTtgA60][Cedar: un simulatore di circuito analogico accelerato]]
- [[https://www.youtube.com/watch?v=ZYkojUozeC4][Causal vs. Acausal Modeling]]: spiega la differenza tra i due stili di
  modeling e quanto sia più facile scalare il problema, in termini di
  componenti, in un modello acausale.  Da ciò deduco che l'approccio
  migliore per creare il modello sia quello acausale perché anche più
  efficiente in termine di risoluzione delle equazioni differenziali.
- [[https://www.youtube.com/watch?v=3DfVowNFI2c][Exploring audio circuits with `ModelingToolkit.jl`]]: Posso recuperare
  le equazioni del diodo da qui

#+begin_src julia
  function LinearContinuationShockleyDiode(;name, Is = 1.0e-15, eta = 1.0,
                                           Vt = 26.0e-3, Maxexp = 15.0)
      @named oneport = Oneport()
      @unpack v, i = oneport
      ps = @parameters Is = Is eta = eta, Vt = Vt, Maxexp = Maxexp
      eqs = [
          i ~ IfElse.ifelse(v/Vt > Maxexp,
                            Is ∗ (exp(Maxexp) ∗ (1 + v/Vt - Maxexp) - 1),
                            Is ∗ (exp(v/Vt) - 1))
      ]
      extend(ODESystem(eqs, t, [], ps, name=name), oneport)
  end
#+end_src

#+begin_src julia
  function Diode(;name, Ids=1e-6, Vt=0.04, max_exp=15, R=1e8)
      @named oneport = OnePort()
      @unpack v, i = oneport
      pars = @parameters Ids=Ids Vt=Vt max_exp=max_exp R=R
      eqs = [i ~ Ids*(exlin(v/Vt, max_exp) - 1) + (v/R)]
      extend(ODESystem(eqs, t, [], pars; name=name), oneport)
  end
#+end_src

Esiste una libreria di componenti elettrici/elettronici basata su
`ModelingToolkit.jl` diversa da quella standard? A quanto pare no.

* 28.10.23                                                       :Componenti:
Ho pensato di trasformare l'equazione contenente l'integrale in un
equazione differenziale che poi verrà introdotta all'interno di una
legge di Ohm leggermente modificata.

#+begin_example
Variazione di resistenza nel tempo
d/dt (R(t)) = alpha * I(t)
Legge di Ohm
V(t) = R(t) * I(t)
#+end_example

con:
1. alpha = - (Rl - Ra) / V_FRC

Penso a come tradurlo in Julia.

Riporto per continuità di ragionamento anche uno dei casi errati che
ho provato a risolvere.

#+begin_src julia
  # ERRATO, vedi sotto
  @parameters t
  D = Differential(t)

  @mtkmodel VariableResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra, [description = "Resistance when air-filled"]
          Rl, [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Ra, [description = "Variable resistance"]
      end
      @equations begin
          # Ho trasformato l'equazione integrale della resistenza in una differenziale
          D(R) ~ ((Rl - Ra) / V_FRC) * i
          v ~ R * i
      end
  end
#+end_src

Mi sono reso conto di aver sbagliato l'equazione caratteristica della resistenza variabile e la riscrivo.  La variazione della resistenza nel tempo è negativa, in quanto la resistenza diminuisce con l'integrale della corrente.

#+begin_src julia
  @parameters t
  D = Differential(t)

  @mtkmodel VariableResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra, [description = "Resistance when air-filled"]
          Rl, [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Rl, [description = "Variable resistance"]
      end
      @equations begin
          # Ho trasformato l'equazione integrale della resistenza in una
          # differenziale. In particolare ho considerato che i valori
          # estremi di resistenza siano Rl ed Ra, quindi ho limitato
          # l'incremento.
          D(R) ~ ifelse(R > Ra,
                        - ((Rl - Ra) / V_FRC) * i,
                        0)
          v ~ R * i
      end
  end
#+end_src

Mostro un semplice circuito con generatore di onda quadra (e nel caso costante) e resistenza
variabile a Chiara per capire se la forma d'onda può essere quella
corretta oppure no. (vedi `[[file:src/test/test7.jl][test7.jl]]`)

* 29.10.23                                                       :Componenti:
Noto che si verifica un problema: quando la resistenza variabile
raggiunge il valore minimo, questa indipendentemente dalla tensione
fornita non cambia.  Provo a modificare il codice modificando la legge
di Ohm.

#+begin_src julia
  @parameters t
  D = Differential(t)

  # CID: Current Integral-Dependent.
  @mtkmodel CIDResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra,    [description = "Resistance when air-filled"]
          Rl,    [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Rl, [description = "Variable resistance"]
      end
      @equations begin
          # Trasformo l'equazione integrale della resistenza in una
          # differenziale che ne modella la variazione.
          D(R) ~ - ((Rl - Ra) / V_FRC) * i
          # Ra <= R <= Rl
          v ~ min(Rl, max(Ra, R)) * i
      end
  end
#+end_src

** Migliorare la tolleranza della soluzione        :Suggerimenti:Julia:Must:
L'opzione `reltol` va inserita nella funzione `solve()`. Leggi la
sezione "Controlling the Solver" di [[https://docs.sciml.ai/SciMLTutorialsOutput/html/introduction/01-ode_introduction.html][questa risorsa]].

#+begin_example
[...] However, a good rule of thumb is that the total solution accuracy is 1-2 digits less than the relative tolerances. [...]
#+end_example

** DONE Implementare induttore variabile
Ottenuto a partire dal codice di `CIDResistor`.  Da testare

#+begin_src julia
  @parameters t
  D = Differential(t)

  # CID: Current Integral-Dependent.
  @mtkmodel CIDInductor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ia,    [description = "Inductance when air-filled"]
          Il,    [description = "Inductance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore
          # d'inizializzazione del sistema.
          I(t) = Il, [description = "Variable inductance"]
      end
      @equations begin
          # Trasformo l'equazione integrale dell'induttanza in una
          # differenziale che ne modella la variazione.
          D(I) ~ - ((Il - Ia) / V_FRC) * i
          # Ia <= I <= Il
          # d/dt (i(t)) = 1 / L * v(t), equazione dell'induttore
          D(i) ~ (1 / (min(Il, max(Ia, I)))) * v
         end
  end
#+end_src

* 30.10.23                                                       :Componenti:
In realtà non sono ancora totalmente convinto dalle soluzioni che ho
trovato in questi giorni e che riguardano la resistenza variabile.
Questo perché l'equazione caratteristica non è mai comparsa.  Voglio
presentare a Chiara due soluzioni:
- Quella più corretta dal punto di vista matematico, con le equazioni
  riprese dal paper cartaceo da lei fornitomi.
  #+begin_src julia
    @mtkmodel VariableResistor begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ra,    [description = "Resistance when air-filled"]
            Rl,    [description = "Resistance when liquid-filled"]
            V_FRC, [description = "Airway Volume at FRC"]
        end
        @variables begin
            # Dopo l'uguale ho i valori di inizializzazione delle
            # variabili.
            ∫i(t) = 0, [description = "Current integral"]
            # Dichiaro come variabile d'interesse anche la resistenza.
            R(t) = Rl, [description = "Variable resistance"]
        end
        @equations begin
            # Ho trasformato l'equazione integrale della resistenza in una
            # differenziale. La notazione `∫i` indica il nome di una
            # variabile che rappresenta l'integrale della corrente.
            D(∫i) ~ i
            # Ra <= R <= Rl: suppongo che i valori Ra ed Rl siano estremi da non superare.
            R ~ min(Rl, max(Ra, (Ra + (Rl - Ra) * (1 - ∫i / V_FRC))))
            # R ~ Ra + (Rl - Ra) * (1 - ∫i / V_FRC) # --> non funziona in
            # questa forma.
            # Legge di Ohm per legare la corrente alla
            # tensione sulla resistenza.
            v ~ R * i
        end
    end
  #+end_src
  Fornisco delle immagini raffiguranti grafici delle simulazioni del
  componente (queste hanno nel titolo `*_not_approx`).
  
- Quella meno rigorosa dal punto di vista matematico (con però una
  forma d'onda migliore).

  #+begin_src julia
    @mtkmodel VariableResistor begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ra, [description = "Resistance when air-filled"]
            Rl, [description = "Resistance when liquid-filled"]
            V_FRC, [description = "Airway Volume at FRC"]
        end
        @variables begin
            # Creo una variabile temporanea perché non riesco a salvare la
            # variabile "in place".
            # Dopo l'uguale ho i valori di inizializzazione delle
            # variabili.
            Rtemp(t) = Rl, [description = "Temporary resistance"]
            R(t) = Rl, [description = "Variable resistance"]
        end
        @equations begin
            # Facendo la derivata della resistenza ottengo questo:
            D(Rtemp) ~ - ((Rl - Ra) / V_FRC) * i
            # Ra <= R <= Rl
            # Limito la resistenza tra i due valori estremi.
            R ~ min(Rl, max(Ra, Rtemp))
            v ~ R * i
        end
    end
  #+end_src

  Fornisco delle immagini raffiguranti grafici delle simulazioni del
  componente (queste hanno nel titolo `*_approx`).

Per me la soluzione approssimata potrebbe essere migliore in quanto le
forme d'onda sono continue.

Un altro problema che ho è quello di non sapere quanto valga
l'ampiezza dell'onda quadra che si vuole utilizzare nelle simulazioni,
per cui mando più grafici.

* 31.10.23                                                          :Modello:
Chiara ha risposto dicendo che il componente si comporta come
dovrebbe, quindi inizio ad abbozzare il modello della sottorete.

Mi è stato chiesto di farlo prima con resistenze e condensatori fissi
e poi le rendo variabili in un altro test.

|                 |          IAD |          IAE |          IAF |          IAG |          IAH |          IAI |          IBL |          IBA |          IBB |
|-----------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------|
| Tipo            |       Airway |     Alveolus |       Airway |     Alveolus |       Airway |     Alveolus |       Airway |     Alveolus |     Alveolus |
| Ra              | 3.100029e+01 | 3.109214e+02 | 2.231464e+01 | 4.012746e+02 | 3.554331e+01 | 4.759710e+02 | 3.097440e+01 | 2.017423e+02 | 2.282920e+02 |
| Rb              | 1.514023e+03 | 1.518509e+04 | 1.089824e+03 | 1.959785e+04 | 1.735899e+03 | 2.324594e+04 | 1.512758e+03 | 9.852891e+03 | 1.114955e+04 |
| La              | 1.852803e-03 | 6.440085e-03 | 1.166141e-03 | 6.908560e-03 | 1.653093e-03 | 7.229610e-03 | 1.290849e-03 | 5.687354e-03 | 5.896531e-03 |
| Lb              | 1.664949e+00 | 5.718839e+00 | 1.047907e+00 | 6.134848e+00 | 1.485488e+00 | 6.419942e+00 | 1.159971e+00 | 5.050408e+00 | 5.236159e+00 |
| Ccap (C_g)       | 1.689219e-09 | 2.462271e-07 | 8.128360e-10 | 2.461359e-07 | 9.126539e-10 | 2.460874e-07 | 5.722034e-10 | 2.464514e-07 | 2.463766e-07 |
| Rti             |            - |         1200 |            - |         1200 |            - |         1200 |            - |         1200 |         1200 |
| Lti             |            - | 5.795540e-04 |            - | 5.795540e-04 |            - | 5.795540e-04 |            - | 5.795540e-04 | 5.795540e-04 |
| Cti             |            - | 2.400000e-05 |            - | 2.400000e-05 |            - | 2.400000e-05 |            - | 2.400000e-05 | 2.400000e-05 |
| Rs              |            - |        80000 |            - |        80000 |            - |        80000 |            - |        80000 |        80000 |
| Cs              |            - | 2.100000e-05 |            - | 2.100000e-05 |            - | 2.100000e-05 |            - | 2.100000e-05 | 2.100000e-05 |
| Rws             | 4.186147e+06 |            - | 9.257208e+06 |            - | 8.703449e+06 |            - | 1.461035e+07 |            - |            - |
| Lws             | 3.705082e-01 |            - | 7.164089e-01 |            - | 5.994469e-01 |            - | 9.016810e-01 |            - |            - |
| Cws             | 3.503620e-10 |            - | 1.584351e-10 |            - | 1.685156e-10 |            - | 1.003855e-10 |            - |            - |
| Chargeth (V_FRC) | 1.744963e-06 | 3.642283e-07 | 8.396596e-07 | 2.699475e-07 | 9.427715e-07 | 2.198790e-07 | 5.910861e-07 | 5.958497e-07 | 5.185713e-07 |
| Vin_th           | 4.666378e+00 | 7.926677e+00 | 4.990351e+00 | 8.694383e+00 | 5.289833e+00 | 9.256451e+00 | 5.588244e+00 | 6.794462e+00 | 7.098371e+00 |
| Vgravity        |            0 |            0 |            0 |            0 |            0 |            0 |            0 |            0 |            0 |
| STATUS          |           OK |           OK |           OK |           OK |           OK |           OK |           OK |           OK |           OK |

Tutti i componenti instanziati nel modello sottostanti sono stati
ricontrollati con la precedente tabella riassuntiva.  Noto che alcuni
valori si ripetono ({R, L, C}ti, {R, C}s).

#+begin_src julia
  # Dichiaro la struttura circuitale (i.e. serie tra il generatore e la resistenza variabile).
  @mtkmodel System begin
      @components begin
          # Sorgenti del segnale e ground
          gen = Square(frequency = 0.5, amplitude = 1.0e-3, smooth = true)
          source = Voltage()
          ground = Ground()

          # IAD
          # Per ora ignoro questa parte.
          # Chargeth= 1.744963e-06 # -- V_FRC
          # Vin_th= 4.666378e+00 # -- tensione su primo diodo
          # Vgravity= 0
          IAD = Airway(
              r_tube.R = (3.100029e+01 + 1.514023e+03) / 2,
              i_tube.L = (1.852803e-03 + 1.664949e+00) / 2,
              c_g.C    = 1.689219e-09,
              r_sw.R   = 4.186147e+06,
              i_sw.L   = 3.705082e-01,
              c_sw.C   = 3.503620e-10,
              r_tube_1.R = (3.100029e+01 + 1.514023e+03) / 2,
              i_tube_1.L = (1.852803e-03 + 1.664949e+00) / 2
          )

          # IAE
          # Chargeth= 3.642283e-07 
          # Vin_th= 7.926677e+00 
          # Vgravity= 0 
          IAE = Alveolus(
              r_tube.R = 3.109214e+02 + 1.518509e+04,
              i_tube.L = 6.440085e-03 + 5.718839e+00,
              c_ga.C   = 2.462271e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IAF
          # Per ora ignoro questa parte.
          # Chargeth= 8.396596e-07
          # Vin_th= 4.990351e+00
          # Vgravity= 0 
          IAF = Airway(
              r_tube.R = (2.231464e+01 + 1.089824e+03) / 2,
              i_tube.L = (1.166141e-03 + 1.047907e+00) / 2,
              c_g.C    = 8.128360e-10,
              r_sw.R   = 9.257208e+06,
              i_sw.L   = 7.164089e-01,
              c_sw.C   = 1.584351e-10,
              r_tube_1.R = (2.231464e+01 + 1.089824e+03) / 2,
              i_tube_1.L = (2.231464e+01 + 1.089824e+03) / 2
          )

          # IAG
          # Chargeth= 2.699475e-07
          # Vin_th= 8.694383e+00
          # Vgravity= 0 
          IAG = Alveolus(
              r_tube.R = 4.012746e+02 + 1.959785e+04,
              i_tube.L = 6.908560e-03 + 6.134848e+00,
              c_ga.C   = 2.461359e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IAH
          # Per ora ignoro questa parte.
          # Chargeth= 9.427715e-07
          # Vin_th= 5.289833e+00
          # Vgravity= 0
          IAH = Airway(
              r_tube.R = (3.554331e+01 + 1.735899e+03) / 2,
              i_tube.L = (1.653093e-03 + 1.485488e+00) / 2,
              c_g.C    = 9.126539e-10,
              r_sw.R   = 8.703449e+06,
              i_sw.L   = 5.994469e-01,
              c_sw.C   = 1.685156e-10,
              r_tube_1.R = (3.554331e+01 + 1.735899e+03) / 2,
              i_tube_1.L = (1.653093e-03 + 1.485488e+00) / 2
          )

          # IAI
          # Chargeth= 2.198790e-07
          # Vin_th= 9.256451e+00
          # Vgravity= 0
          IAI = Alveolus(
              r_tube.R = 4.759710e+02 + 2.324594e+04,
              i_tube.L = 7.229610e-03 + 6.419942e+00,
              c_ga.C   = 2.460874e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IBL
          # Per ora ignoro questa parte.
          # Chargeth= 5.910861e-07 
          # Vin_th= 5.588244e+00 
          # Vgravity= 0
          IBL = Airway(
              r_tube.R = (3.097440e+01 + 1.512758e+03) / 2,
              i_tube.L = (1.290849e-03 + 1.159971e+00) / 2,
              c_g.C    = 5.722034e-10,
              r_sw.R   = 1.461035e+07,
              i_sw.L   = 9.016810e-01,
              c_sw.C   = 1.003855e-10,
              r_tube_1.R = (3.097440e+01 + 1.512758e+03) / 2,
              i_tube_1.L = (1.290849e-03 + 1.159971e+00) / 2
          )

          # IBA
          # Chargeth= 5.958497e-07 
          # Vin_th= 6.794462e+00 
          # Vgravity= 0 
          IBA = Alveolus(
              r_tube.R = 2.017423e+02 + 9.852891e+03,
              i_tube.L = 5.687354e-03 + 5.050408e+00,
              c_ga.C   = 2.464514e-07,
              r_t.R    = 1200 ,
              i_t.L    = 5.795540e-04 ,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000 ,
              c_s.C    = 2.100000e-05
          )

          # IBB        
          # Chargeth= 5.185713e-07
          # Vin_th= 7.098371e+00
          # Vgravity= 0
          IBB = Alveolus(
              r_tube.R = 2.282920e+02 + 1.114955e+04,
              i_tube.L = 5.896531e-03 + 5.236159e+00,
              c_ga.C   = 2.463766e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )
      end

      @equations begin
          connect(gen.output, source.V)
          connect(source.p, IAD.in)
          connect(IAD.out, IAE.in, IAF.in)
          connect(IAF.out, IAH.in, IAG.in)
          connect(IAH.out, IBL.in, IAI.in)
          connect(IBL.out, IBA.in, IBB.in)
          connect(source.n, ground.g)
      end
  end
#+end_src

Noto che vi erano degli errori nella definizione della capacità `c_s`
nel modello alveolare.  Questi sono stati sistemati in `[[file:src/test/test8.jl][test8.jl]]`.

Ho sistemato il modello di stamattina isolando il parametri del
sistema per rendere il tutto maggiormente modificabile. (si veda
`[[file:src/test/test9.jl][test9.jl]]`).

** DONE Capire come graficare meglio i risultati
** DONE Implementare il modello con componenti variabili.          :Modello:

* 01.11.23                                                       :Componenti:
Implemento il diodo in Julia rimanipolando del codice trovato online
il 27.10.

#+begin_src julia
  function Diode(;name, Ids=1e-6, Vt=0.04, max_exp=15, R=1e8)
      @named oneport = OnePort()
      @unpack v, i = oneport
      pars = @parameters Ids=Ids Vt=Vt max_exp=max_exp R=R
      eqs = [i ~ Ids*(exlin(v/Vt, max_exp) - 1) + (v/R)]
      extend(ODESystem(eqs, t, [], pars; name=name), oneport)
  end

  exlin(x, max_x) = ifelse(x > max_x, exp(max_x)*(1 + x - max_x), exp(x))

  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          # Parametri che costituiscono il componente.
          Ids, [description = "Current flowing in the component"]
          Vt, [description = "Threshold"]
          max_exp
          R
      end
      @equations begin
          i ~ Ids * (exlin(v / Vt, max_exp) - 1) + (v / R)
      end
  end

  function Diode(::Ideal; name)
      @named(p = Pin()); @named(n = Pin())
      @variables v(t) i(t)
      eqs = [
          v ~ p.v - n.v #Convenience
          0 ~ p.i + n.i #in = -out
          i ~ p.i #Positive current flows *into* p terminal
          0 ~ IfElse.ifelse(v<0, i, v)
      ]

      ODESystem(eqs, t, [v, i], [], systems=[p, n], defaults=Dict(), name=name)
  end

  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          # Parametri che costituiscono il componente.
          V_th, [description = "Resistance when liquid-filled"]
      end
      @equations begin
          0 ~ ifelse(v < v_th, i, v - v_th)
      end
  end

#+end_src

Ho provato un po' di alternative ma nessuna di queste è valida per il
mio utilizzo.  Ho migliorato la leggibilità del codice di `[[file:src/test/test9.jl][test9.jl]]`.

* 02.11.23
** DONE Mostro `[[file:src/test/test9.jl][test9.jl]]` ed il grafico risultante.
Ok, va bene ma vedi sotto.

** DONE Domande da fare
- Per ora non riesco ad implementare un diodo.  Volevo chiedere quale
  equazione caratteristica posso utilizzare per implementarlo e come
  devo interpertare il valore `v_th` dei vari blocchi.
Il diodo compare solo nell'interfaccia aria/acqua. quando ho solo aria
o solo acqua questo non c'è.
- Il modello con componenti variabili deve considerare solo resistenze
  `Rtube` o anche altri componenti variabili?  Anche Ltube.
- Il modello di via respiratoria deve considerare solo `Rtube` come
  variabile, non `Rtube1`, giusto?
Le resistenze devono essere uguali, quindi variabile.

** DONE Implementare il modello con componenti variabili
** Colloquio con Chiara                                       :Suggerimenti:
L'integrale nella via aerea "media" (quindi via respiratoria ed
alveolo) non deve essere effettuato dall'inizio della simulazione ma
da quando arriva l'aria all'interno della via aerea.  Ho bisogno di
trovare un modo per passare una variabile da un modulo all'altro
(passerei l'integrale della corrente nel precedente modulo?).

** DONE Vedi come posso passare una variabile da un modulo all'altro :Componenti:
** DONE Modificare l'onda quadra così che abbia 40ns di rise e 400ns di HIGH.

* 03.11.23                                                 :Input:Componenti:
Inizierei considerando il problema più semplice: l'onda quadra.  Leggo
la sua implementazione per capire da quali parametri dipende.

Guardando in `.../Blocks/sources.jl`, noto delle funzioni
differenziabili per evitare il fenomeno di Gibbs.  L'equazione di
`Square` viene modificata dal parametro `smooth=true`.  In
particolare, se lo eguaglio ad un valore numerico, questo diventa lo
smoothing factor dell'onda quadra.

Cosa s'intende per smoothing factor?  Lo scoprirò empiricamente.  È
legato alla pendenza dell'onda quadra, la cui implementazione
"smoothed" è un'artan(x) (vedi `[[file:src/test/test11.jl][test11.jl]]`).

Mi dedico ora al diodo.  Credo che spostando la variabile `∫i` nei
modelli ad alto livello (i.e. `Airway` e `Alveolus`) dovrei avere modo
di calcolarla una volta sola e poi sfruttarla in ciascun componente.
Altre due variabili potrebbero essere interessanti da implementare:
trigger_in e trigger_out. La prima indica lo stato di riempimento della
via aerea in input a quella del modulo.  La seconda indica lo stato di
riempimento della via aerea del modulo corrente.  L'integrale della
corrente deve essere valutato a partire dal momento in cui arriva
l'aria nella via aerea corrente, quindi ipotizzo che lo stato di
`trigger_in` sarà true mentre quello di `trigger_out` sarà `false`.  Lo
stato sarà mantenuto fino a quando l'integrale sarà uguale a `V_FRC`,
valore che rappresenta il volume massimo.  Quando `∫i / V_FRC = 1`,
cambio stato: trigger_in = 1, trigger_out = 1.

| trigger_in | trigger_out | stato      | integrazione     |
|-----------+------------+------------+------------------|
| false     | false      | Full water | no --> D(∫i) = 0 |
| false     | true       | ---        | ---              |
| true      | false      | Interface  | sì --> D(∫i) = i |
| true      | true       | Full air   | no --> D(∫i) = 0 |

#+begin_src julia
  # Nel modulo gestisco solo trigger_out.
  trigger_out = ifelse(∫i / V_FRC >= 1,
                       true,
                       false)
  # Integro solo quando sono nello stato "interface"
  D(∫i) = ifelse(trigger_in == true && trigger_out == false,
                 0,
                 i)
#+end_src

La variabile `∫i` dovrà esistere anche nei componenti variabili per
interagire con quella del modello ad alto livello.  Devo quindi
effettuare una connessione alto-basso livello.

#+begin_src julia
  r_tube.v.∫i   = ∫i
  i_tube.v.∫i   = ∫i
  r_tube_1.v.∫i = ∫i
  i_tube_1.v.∫i = ∫i
#+end_src

Devo riscrivere la configurazione dei parametri che non avrà più
sdoppiata la V_FRC.

* 04.11.23                                          :Modello:Parametri:Input:
Voglio semplificare la gestione dei parametri di sistema, in quanto vi
sono molti duplicati delle stesse variabili/parametri.

Ho scritto un semplice codice di prova per testare l'isolamento dei
parametri in un modello ad alto livello.

#+begin_src julia
  @mtkmodel System begin
      @parameters begin
          A
          R
          C
      end
      @components begin
          # Sorgenti del segnale e ground.
          gen = Square(amplitude = A,
                       frequency = 0.1,
                       smooth    = 1.0e-3)
          source = Voltage()
          ground = Ground()
          R1 = Resistor(R = R)
          C1 = Capacitor(C = C)
      end
      @equations begin
          connect(gen.output, source.V)
          connect(source.p, R1.p)
          connect(R1.n, C1.p)
          connect(C1.n, source.n, ground.g)
      end
  end

  # Istanzio il modello (parametri esclusi).
  @mtkbuild system = System()

  sys_ps = [
      system.A => 2
      system.R => 4.0
      system.C => 1.0e-1
  ]

#+end_src

- Alcuni parametri devono necessariamente essere scritti all'interno
  della funzione che genera quel componente (e.g. `frequency` e
  `smooth` per `Square()`).
- I nomi dei parametri nel modello superiore (alias per "ad alto
  livello") possono essere gli stessi di quelli dei modelli inferiori,
  senza interferire tra loro.

* 04.11.23                                          :Modello:Parametri:Input:
Ieri pomeriggio ho provato ad implementare un parametro ereditabile
all'interno del modello superiore ma a quanto pare non ha funzionato:
i parametri inferiori devono comunque essere inizializzati in qualche
modo.

Sto leggendo la documentazione di `ModelingToolkit.jl` per capirne
meglio il funzionamento, dato che molte delle cose che vorrei
implementare dipendono da ciò.

** TODO [#C] Associare unità di misura e input/output alle variabili :Componenti:

Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/ContextualVariables/#Variable-metadata][`Variable Metadata`]].
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Variable_metadata/#Input-or-output][`Input or output`]].

#+begin_src julia
  # Per esempio questo
  @variables x[1:2, 1:2] [connect = Flow; unit = u"m^3/s"]
#+end_src

** TODO [#C] Aiutare il futuro sviluppatore del sistema mediante `getdescription(var)` :Futuro:Manuale:
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Variable_metadata/#Variable-descriptions][`Variables descriptions`]].  Inserire nella documentazione finale.

** TODO [#B] Leggere manuale di `ModelingToolkit`               :Julia:Must:
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#components][`Composing Models and Building Reusable Components`]].
- [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#Numerics-with-Composed-Models][`Numerics with Composed Models`]] tratta di come estrarre le serie
  temporali dalla soluzione del sistema.

#+begin_src julia
  sol[x,1:5] # Dove x è variabile, 1..5 è l'intervallo d'interesse
#+end_src

- [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#Variable-scope-and-parameter-expressions][`Variable scope and parameter expressions`]] tratta di come
  condividere i parametri appartenenti a sistemi a diversi livelli.
  (Per "comporre" i livelli, il codice d'esempio utilizza `\circ`).
  Esiste una funzione `ParentScope()` che dovrebbe permettere di avere
  la visibilità dei parametri del modello superiore ma per ora non
  funziona correttamente.

Leggi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/MTKModel_Connector/#mtkmodel_connector][`Components and Connectors`]]: Include le informazioni essenziali
sulla gestione dei modelli costituiti da componenti.

* 05.11.23
** DONE Dubbi sulle unità di misura                       :Domande:Risposte:
Le unità di misura di ciascuna variabile devono essere quelle
elettriche oppure quelle meccaniche?  R: Quelle elettriche

* 07.11.23                                            :Bash:Input:Repository:
** Conversione dati di input                             :Conversione:Input:
Sto lavorando su uno script per effettuare una conversione dei dati
contenuti in `Albero.cir` in un formato che sia leggibile dal main di
Julia.

L'idea sarebbe quella di convertire ciascuna riga nella dichiarazione
del componente superiore dell'apposito tipo.
*** DONE I parametri `C_g` e `C_ga` verranno chiamati entrambi `C_g` :Conversione:Parametri:
** Sistemazione del tree della repository              :Pulizia:Repository:
I file sorgenti erano troppo caotici nella directory, quindi ho deciso
di creare delle posizioni più sensate.

* 08.11.23
** DONE Sistemare nome parametri per corrispondere a quelli di `cir2jl` :Parametri:Julia:
C'è un problema che devo risolvere, ossia che il file del modello che
voglio importare è troppo grande per essere importato da Julia...

** TODO [#B] Come posso importare un così gran numero di dati?    :Problema:
* 09.11.23                                                       :Componenti:
Il problema della gestione dell'input di 50k moduli è da risolversi
suddividendo, per forza di cose, in sottoreti minori.  Fosse esso
gestibile da diversi threads sarebbe ancora meglio.

Come potrei gestire queste sottoreti?

Ho parlato con Chiara: mi ha fornito dell'albero completo senza {R, C,
I}_sw per capire se lo StackOverflowError si può risolvere.  Devo per
forza di cose ora ritornare al problema del diodo, di `trigger_out` e
`trigger_in`.  Dice inoltre che si possono utilizzare le unità
elettriche per il nostro modello e non quelle fisiche/meccaniche.

** DONE Sistemare lo script per includere anche i trigger{in, out}    :Bash:
L'ho fatto in treno.  Basta un `echo` ed un `sed`.

* 10.11.23                                                       :Componenti:
Ho sistemato lo script e il `main.jl` così da calcolare l'integrale
della corrente a partire da quando arriva il flusso.  Ho aggiunto
`src/util/graphs_trigger.jl`: crea i grafici di quello che avviene a
livello di `trigger_in`, `trigger_out` e integrale della corrente nei
vari moduli.

** DONE Convenzioni delle correnti                                 :Domande:
La corrente negativa indica una corrente entrante nella via aerea?
contrario.  Risposta completa nei giorni seguenti.

* 13.11.23                                                 :Componenti:Input:
** DONE Segno dell' integrale di corrente                 :Domande:Proposta:
Ho dei dubbi relativi all'integrale della corrente.  Se questo deve
modificare i componenti variabili, non avrebbe senso andare ad
utilizzare solamente la corrente entrante nell'integrale?  Il grafico
che ho generato mostra chiaramente che, nel momento in cui la flag
`trigger_in = 1` e `trigger_out = 0`, il sistema continuerà a valutare
l'integrale di corrente per quel particolare modulo.  Si noti però
che, ad esempio, IBL ha un andamento oscillatorio ma raggiunge anche
dei livelli negativi di integrale.  Penso si possa utilizzare anche
un'opzione `bounds` delle variabili di ModelingToolkit, applicata alla
variabile integrale.  Dalla documentazione, l'utilizzo di questo
metadato è utile solo al tuning dei parametri, quindi non me ne faccio
nulla.

Ho provato anche una soluzione di questo tipo:
#+begin_src julia
  @equations begin
      0 ~ ifelse(∫i > 0,
                 D(∫i) - trigger_in * (1.0 - trigger_out) * in.i,
                 ∫i)
  end
#+end_src

I controlli nei componenti variabili dovrebbero limitare i valori di
resistenza ed induttanza nel seguente modo:

#+begin_src julia
  @equations begin
      # Ra <= R <= Rl: suppongo che i valori Ra ed Rl siano estremi da
      # non superare.
      R ~ min((Ra + Rb), max(Ra, (Ra + Rb * (1 - ∫i / V_FRC))))
      v ~ R * i
  end
#+end_src

La risposta è che non è fattibile perchè poi vogliamo che l'integrale
vari quando ho solo aria.

** DONE Devo valutare il comportamento in presenza di una tensione costante :Input:Componenti:
Ho riscontrato un problema relativo a `MaxIters`, il massimo numero di
iterazioni e ho risolto andando a modificare la tolleranza, rendendo
la soluzione più approssimata.
* 14.11.23                                                       :Repository:
Devo mostrare i risultati a tensione costante a Chiara.
** Package management
Quali sono le guidelines per scrivere codice in julia correttamente?
Il pacchetto julia `Pkg`, già preinstallato, crea in automatico due
file toml: `Manifest.toml` e `Project.toml`. Si veda la [[https://docs.julialang.org/en/v1/stdlib/Pkg/][documentazione]]
di Pkg.

* 15.11.23
** Risultati test con step function (alias tensione costante) :Input:Variabili:
I risultati mostrati ieri sono abbastanza coerenti con quello che ci
si aspetta ma alcuni versi delle correnti e picchi non convincono.  Ho
voluto "smussare" la tensione costante che stavo fornendo in quanto
credevo fosse il solito fenomeno di Gibbs, così ho sistemato il picco.
Per quanto riguarda le correnti e i loro versi è bastato prendere come
riferimento un componente e non il nodo d'uscita.
** Convenzione correnti                                           :Risposte:
Se la corrente è positiva, allora è anche entrante (viceversa).

** Segno dell'integrale di corrente                               :Risposte:
La risposta è che non è fattibile perchè poi vogliamo che l'integrale
vari quando ho solo aria.

** DONE Diodo                                    :Proposta:Domande:Risposte:
La soluzione per il diodo è stata trovata sul [[https://discourse.julialang.org/t/diode-model-not-working-as-expected-with-modelingtoolkit/95125/2][forum online]].
#+begin_src julia
  exlin(x, max_x) = ifelse(x > max_x, exp(max_x)*(1 + x - max_x), exp(x))
  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ids     = 1e-6,
          [description = "Reverse-bias current"]
          Vt      = 0.04,
          [description = "Threshold in voltage"]
          max_exp = 15,
          [description = "Value after which linearization is applied"]
          R       = 1e8,
          [description = "Diode Resistance"]
      end
      @equations begin
          i ~ Ids * (exlin(v / Vt, max_exp) - 1) + (v / R)
      end
  end
#+end_src

Basterebbe quindi rimaneggiare questa forma per poter usufruire del
componente.  Dovrei renderlo dipendente dall'integrale di corrente
della via aerea e, a denominatore dell'esponenziale cosa dovrebbe
esserci?  Qual è il ruolo di `Vin_th`? Solo la "disabilitazione" del
diodo oppure svolge un ruolo all'interno del diodo?

Creo del codice di test per il diodo.
#+begin_src julia
    using ModelingToolkit
    using ModelingToolkitStandardLibrary.Blocks
    using ModelingToolkitStandardLibrary.Electrical
    using OrdinaryDiffEq
    using Plots

    @parameters t

    exlin(x, max_x) = ifelse(x > max_x,
                             exp(max_x)*(1 + x - max_x),
                             exp(x))
    @mtkmodel Diode begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ids     = 1e-6,
            [description = "Reverse-bias current"]
            Vt      = 0.04,
            [description = "Threshold in voltage"]
            max_exp = 15,
            [description = "Value after which linearization is applied"]
            R       = 1e8,
            [description = "Diode Resistance"]
        end
        @equations begin
            i ~ Ids * (exlin(v / Vt, max_exp) - 1) + (v / R)
        end
    end

    @mtkmodel System begin
        @components begin
            V = Voltage()
            D = Diode()
            R = Resistor(R = 100)
            Gnd = Ground()
        end
        @equations begin
            V.V.u ~ 15 * sin(2*π*50*t)
            connect(V.p, D.p)
            connect(D.n, R.p)
            connect(V.n, R.n, Gnd.g)
        end
    end

  @mtkbuild system = System()
  prob = ODEProblem(system, Pair[], (0/50, 1/50), saveat=1/50e2);
  sol = solve(prob, Rodas4(), dtmax = 1.0e-3);

#+end_src

`Vin_th` rappresenta la soglia in tensione che esercita il diodo.  Ciò
significa che il parametro `Vt` del diodo sarà da essere modificato in
ogni componente.  L'esclusione del diodo la si effettua quando
`trigger_in = 1` e `trigger_out = 0` (situazione di interfaccia
aria-acqua).

* 16.11.23
** Diodo di Shockley                                                :Teoria:
Il diodo si comporta come dovrebbe ma devo capire ora come gestire al
meglio i vari parametri.  Per poterlo fare devo innanzitutto sapere a
cosa si riferiscono tali parametri però, per cui mi riferisco alla
pagina wiki del [[https://it.wikipedia.org/wiki/Equazione_del_diodo_ideale_di_Shockley][diodo ideale di Shockley]].

\begin{equation}
i_D = I_s\cdot \left(e^{\frac{v_D}{\eta v_T}} - 1\right)
\end{equation}

- Vt :: tensione termica
- Vd :: tensione applicata ai capi
- \eta :: fattore di idealità (dipendente dal materiale)

** Diodo                                                            :Teoria:
Riporto l'equazione del [[https://it.wikipedia.org/wiki/Diodo#Diodo_ideale][diodo ideale]].  Il mio scopo è quello di
implementare questa soluzione ma per ora ho solo trovato online del
materiale per la precedente.

\begin{equation}
I = I_0 \cdot e^{\frac{V_D}{V_T}}
\end{equation}

I parametri sono i medesimi, considerato I_0 = I_s.  La vera domanda è
se esiste un modo per determinare inserire il valore di tensione di
soglia (e.g. 0.6, 0.7V dei diodi visti ad Elettronica) all'interno
dell'equazione caratteristica, dato che la tensione termica
sembrerebbe essere diversa da questa.

- Tensione di soglia (V_s, V_{th}) :: la minima differenza di potenziale
  applicabile tra gate e source del transistore per formare il canale;
  nei diodi è la minima tensione necessaria per attivare la conduzione
  in polarizzazione diretta. [[[https://it.wikipedia.org/wiki/Tensione_di_soglia][Wikipedia]]]
- Tensione termica (V_T, in engl. "Thermal voltage") :: è definita come
  $V_T = \frac{k_B T}{q}$ Dove:
  - k_B :: Costante di Boltzmann [J K^{-1}]
  - T :: Temperatura [K]
  - q :: Carica dell'elettrone [C]
  In `Modia.jl` viene descritta nel seguente modo:
  #+begin_quote
  Voltage equivalent of temperature
  #+end_quote


  In condizioni fisiologiche: $V_T \approx 26.7 mV$. [[[https://www.edutecnica.it/elettronica/diodo/diodo.htm][Fonte]]]

** Altre soluzioni                                :Componenti:Julia:Proposta:
Leggendo degli esempi di `Modia.jl`, ho trovato anche questa
formulazione che sembra interessante:
#+begin_src julia
  # Ideal diode
  IdealDiode = OnePort | Model(
      Ron   = 1e-5u"Ω",
      Goff  = 1e-5u"1/Ω",
      s = Var(start = 0.0),
      equations = :[              
          closed = positive(s)   # closed = s > 0  
          v = s*u"V"*(if closed; Ron*u"1/Ω" else 1         end)
          i = s*u"A"*(if closed; 1          else Goff*u"Ω" end)
      ]
  )
#+end_src

** Riflessioni                                           :Problema:Proposta:
Il modello di diodo deve fare in modo che, superata la tensione di
soglia, chiamata nel nostro problema `Vin_th`, la corrente `i_D` possa
scorrere e la tensione `V_D = Vin_th` ai capi.  Se la tensione misurata
dovesse essere inferiore alla soglia Vin_th, allora `i_D = 0` e la
tensione sul diodo (`V_D`) seguirà quella del generatore.

*** Misurazione e sovrascrittura della differenza di potenziale :Problema:Domande:Proposta:
Come faccio a gestire il fatto che devo sia misurare una differenza di
potenziale che imporla?  Potrei utilizzare il sensore di tensione
(i.e. VoltageSensor) presente nella libreria standard.

#+begin_src julia
  @mtkmodel VoltageSensor begin
      @components begin
          # Sfrutta due pin, positivo e negativo
          p = Pin()
          n = Pin()
      end
      @variables begin
          # L'unica variabile in uscita
          v(t)
      end
      @equations begin
          # Misura la tensione senza introdurre corrente
          p.i ~ 0
          n.i ~ 0
          v   ~ p.v - n.v
      end
  end
#+end_src
Segue una soluzione che vuole sfruttare questo componente. non resta
che testarla nel circuito diodo-resistenza.

#+begin_src julia
  @mtkmodel Diode begin
      @parameters begin
          Vin_th, [description = "Diode threshold"]
      end
      @extend v, i = oneport = OnePort()
      @components begin
          VS = VoltageSensor()
      end
      @equations begin
          connect(oneport.p, VS.p)
          connect(oneport.n, VS.n)
          v ~ (if VS.v >= Vin_th; 
                   Vin_th
               else
                   VS.v)
          i ~ (if VS.v < Vin_th;
                   0)
      end
  end
#+end_src

Non sono riuscito per ora ad instanziarlo.  I risultati sono riportati in `[[file:src/test/test13.jl][test13.jl]]`

* 17.11.23
** Diodo                                          :Componenti:Julia:Modello:
Esiste, nella libreria standard, anche un [[file:~/.julia/packages/ModelingToolkitStandardLibrary/sOsqv/src/Electrical/Analog/sensors.jl][sensore multiplo]] che
incorpora due sensori: uno di corrente ed uno di tensione.  Mi
riferisco a `MultiSensor`.  Potrei collegare i poli per la misurazione
della corrente al generatore di tensione e i poli per la misurazione
della tensione ai due rami del circuito, quello a monte del generatore
e quello a valle del resto del modulo.  Consulto ora come è fatto il
[[file:~/.julia/packages/ModelingToolkitStandardLibrary/sOsqv/src/Electrical/Analog/sources.jl][generatore di tensione]].  Devo ora capire esattamente quali sono i
valori delle tensioni e delle correnti del due poli del diodo.

| Stato       | Corrente_p | Corrente_n | Tensione_p | Tensione_n |
|-------------+-----------+-----------+-----------+-----------|
| VS.v >= V_th | CS.i      | CS.i      | V_th       | V_th       |
| VS.v < V_th  | 0         | 0         | VS.v      | 0         |


#+begin_src julia
  #=
  Proverei ad implementare queste equazioni.
  p.i ~ n.i ~ CS.i
  p.v ~ VS.v
  n.v ~ V_th

  p.i ~ CS.i
  n.i ~ 0
  p.v ~ VS.v
  n.v ~ 0
  =#
  n.i ~ ifelse(VS.v >= V_th, CS.i, 0)
  n.v ~ ifelse(VS.v >= V_th, V_th, 0)
#+end_src

Se mettessi la differenza di tensione ai capi uguale a zero avrei un
corto circuito ma la tensione sul catodo seguirebbe l'andamento di
quella dell'anodo, non rimanendo fissa.  Sperimento il codice su
[[file:src/test/test14.jl][test14.jl]].  Il risultato sembrerebbe essere instabile.

*** Alternativa: `Modia.jl`
Guardando sulla libreria di `Modia.jl`, il diodo non è implementato se
non con una funzione commentata, la si veda nei giorni passati.

#+begin_src julia
  IdealDiode = OnePort | Model(
      Ron   = 1e-5u"Ω",
      Goff  = 1e-5u"1/Ω",
      s = Var(start = 0.0),
      equations = :[
          closed = positive(s)   # closed = s > 0
          v = s*u"V"*(if closed; Ron*u"1/Ω" else 1         end)
          i = s*u"A"*(if closed; 1          else Goff*u"Ω" end)
      ]
  )
#+end_src

Non si capisce molto la logica del componente.

* 20.11.23
** Albero                                   :Input:Proposta:Julia:Parametri:
L'altro giorno ho visto un [[https://www.youtube.com/watch?v=iwFMg-rCWNg][video]] che parlava di `DataFrames.jl`, un
pacchetto per la gestione di dati tabulari su Julia.  In particolare
si interfaccerebbe con uno standard open-source, Apache Arrow, che
renderebbe istantanea l'importazione dell'albero.  Esiste un [[https://www.youtube.com/watch?v=SXF4BawX-hs][guida
completa]] a `DataFrame.jl`, oltre alla documentazione sul [[https://dataframes.juliadata.org/stable/][sito
ufficiale]].

** Diodo
Penso sia meglio impostare un messaggio per discourse, così da trovare
una soluzione del diodo lì.

* 21.11.23
Creo una tabella con i dati della sottorete e provo ad importarli in
Julia.

#+begin_src CSV
Name,Type,Ra,Rb,La,Lb,C_g/C_ga,V_FRC,Vin_th,Rti/Rws,Lti/Lws,Cti/Cws,Rs,Cs,From
IAD,airway,3.100029e+01,1.514023e+03,1.852803e-03,1.664949e+00,1.689219e-09,1.744963e-06,4.666378e+00,4.186147e+06,3.705082e-01,3.503620e-10,,,
IAE,alveolus,3.109214e+02,1.518509e+04,6.440085e-03,5.718839e+00,2.462271e-07,3.642283e-07,7.926677e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IAD
IAF,airway,2.231464e+01,1.089824e+03,1.166141e-03,1.047907e+00,8.128360e-10,8.396596e-07,4.990351e+00,9.257208e+06,7.164089e-01,1.584351e-10,,,IAD
IAG,alveolus,4.012746e+02,1.959785e+04,6.908560e-03,6.134848e+00,2.461359e-07,2.699475e-07,8.694383e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IAF
IAH,airway,3.554331e+01,1.735899e+03,1.653093e-03,1.485488e+00,9.126539e-10,9.427715e-07,5.289833e+00,8.703449e+06,5.994469e-01,1.685156e-10,,,IAF
IAI,alveolus,4.759710e+02,2.324594e+04,7.229610e-03,6.419942e+00,2.460874e-07,2.198790e-07,9.256451e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IAH
IBL,airway,3.097440e+01,1.512758e+03,1.290849e-03,1.159971e+00,5.722034e-10,5.910861e-07,5.588244e+00,1.461035e+07,9.016810e-01,1.003855e-10,,,IAH
IBA,alveolus,2.017423e+02,9.852891e+03,5.687354e-03,5.050408e+00,2.464514e-07,5.958497e-07,6.794462e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IBL
IBB,alveolus,2.282920e+02,1.114955e+04,5.896531e-03,5.236159e+00,2.463766e-07,5.185713e-07,7.098371e+00,1200,5.795540e-04,2.400000e-05,80000,2.100000e-05,IBL
#+end_src

* 22.11.23
** Diodi, ruolo delle callbacks                :Componenti:Modello:Proposta:
Le Callbacks sarebbero d'aiuto nella fase di solving, sostituendo la
`transition` di Verilog, come documentato [[https://discourse.julialang.org/t/ideal-diode-mtk-callbacks-to-mimic-verilog-a-events/62528][qui]].

* 23.11.23
Il problema di queste callbacks è che si rifanno alla modalità senza
macro, precedente a quella utilizzata attualmente.  Dovrei quindi
capire se fosse possibile scrivere le callbacks pur mantenendo la
struttura del codice che ho già, senza quindi rifare di nuovo tutto.

** Test callbacks con sintassi obsoleta             :Modello:Julia:Proposta:
Testo sul solito circuito D-R con vecchia sintassi (si veda
`[[file:src/test/test14b.jl][test14b]]`).

La sintassi utilizzata nella [[file:~/.julia/packages/ModelingToolkitStandardLibrary/sOsqv/src/Electrical/Analog/ideal_components.jl][libreria standard dei componenti]].
Raccolgo le domande che sorgono durante la scrittura di questo
sorgente.  Dalla [[~/.julia/packages/ModelingToolkit/66mEN/docs/src/basics/Events.md][documentazione]] (in locale), sembrerebbe che la
necessità sia più quella di stabilire

* 24.11.23
** ModelingToolkitStandardLibrary (MSL)         :Modello:Julia:Bibliografia:
Riporto come risorsa il [[https://www.youtube.com/watch?v=7hF0JRznxNU][video]] di presentazione del nuovo formato di
coding.  Sulla repo di MSL sono presenti alcune [[https://github.com/SciML/ModelingToolkitStandardLibrary.jl/pull/166/commits/5d97d405ee66d7121a8facbe823425fd508f78a2][PR]] in cui degli utenti
hanno utilizzato anche la macro `@component` per definire la funzione
che descrive il componente.

* 27.11.23

#+begin_example
Greetings,

I am new to Julia Programming Language and I don't have any experience in writing to a community of programmers but I'll do my best to explain what my problem is.

I am trying to instantiate a lung model (an electrical) made out of two kinds of blocks: alveoli and airways.  Each of such blocks is constituted by Resistors, Capacitors, Inductors (all of which I have used MSL ones with success) and diode that I'm struggling to implement.
The syntax i used was the one considering the macros @mtkmodel and @mtkbuild.
I have tried to use Shockley Diode equation in the component and everything went fine with the simulation but i couldn't be able to modify its forward threshold 
[...]

I hope I was clear in explaining my problem.
#+end_example

Sembrerebbe che il problema del diodo sia risolto, vedi `[[file:src/test/test14c.jl][test14c.jl]]`

#+begin_src julia
  exlin(x, max_x) = ifelse(x > max_x,
                           exp(max_x)*(1 + x - max_x),
                           exp(x))
  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ids     = 1e-6,
          [description = "Reverse-bias current"]
          max_exp = 15,
          [description = "Value after which linearization is applied"]
          R       = 1e8,
          [description = "Diode Resistance"]
          Vth     = 1e-3,
          [description = "Threshold voltage"]
      end
      @equations begin
          i ~ Ids * (exlin((v - Vth) / (1e-3 * Vth), max_exp) - 1) + (v / R)
      end
  end

#+end_src

* 29.11.23
** DONE Diodo                                                     :Proposta:
Devo mostrare il modello del diodo a Chiara per capire se potrebbe
quello che cerchiamo.  Va tutto bene, anche la parte sullo switch che
abbiamo sotto.

** Switch                                         :Componenti:Modello:Julia:
L'idea è quella di passare le variabili trigger_in e trigger_out
provenienti dai rispettivi moduli (i.e. Airway e Alveolus).

#+begin_src julia
  @mtkmodel Switch begin
      @extend v, i = oneport = OnePort()
      @variables begin
          trigger_in,  [description = "Flag: 1 when air fills previous airway completely, 0 otherwise"]
          trigger_out, [description = "Flag: 1 when air fills current airway completely, 0 otherwise"]
      end
      @equations begin
          # Disabilito il diodo quando ho un completo riempimento di aria e di acqua
          # Riempimento con acqua  (trigger_in = 0, trigger_out = 0) --> v = 0 (corto)
          # Riempimento con aria   (trigger_in = 1, trigger_out = 1) --> v = 0 (corto)
          # Interfaccia aria/acqua (trigger_in = 1, trigger_out = 0) --> i = 0 (aperto)
          # Non possibile          (trigger_in = 0, trigger_out = 1) --> XXXXXXXXXXXXX
          0 ~ ifelse(trigger_in == 1,
                     ifelse(trigger_out == 1, v, i), v)
      end
  end
#+end_src

** TODO [#A] Instabilità della sottorete                          :Problema:
Il sistema (la sottorete) non è stabile.  Faccio una lista dei
possibili responsabili.

* 30.11.23
** Lista possibili cause instabilità
- `trigger_out` e `trigger_in` sono variabili binarie, quindi hanno un
  andamento simile a quello di uno scalino.  Inoltre non sono
  perfettamente stabili (mi riferisco a trigger_out).  Riscrivo il
  codice dello switch rendendolo dipendente dall'integrale di
  corrente.  Si veda `[[file:src/test/test16a.jl][test16a.jl]]`
- Lo switch ad un certo punto commuta istantaneamente.

* 01.12.23
Il funzionamento dello switch è stato testato con più valori di
integrale di corrente e in funzione del tempo.  Non avevo ancora
considerato che l'equazione caratteristica dell'interruttore introduce
una discontinuità del problema, così ho generato una curva più
smussata (si veda `[[file:src/test/test16b.jl][test16b.jl]]`).  Testandola risultano ancora dei
warnings relativi alla stabilità della soluzione, per cui ho risolto
solo in parte il problema.

* 03.12.23
** Modelingtoolkit                        :Domande:Problema:Julia:Callbacks:
Quello che vorrei fare sarebbe implementare un sistema modulare simile
a quello che ho ora ma introducendo le Callbacks.  Il problema che
sussiste è che la sintassi obsoleta non permette una modularità,
garantita invece dalla nuova.
- Come funzionano le callbacks?  [[file:~/.julia/packages/ModelingToolkit/66mEN/docs/src/basics/Composition.md][Questo documento]], nella sezione
  "Components with discontinuous dynamics", accenna a degli esempi di
  utilizzo. Consulto la documentazione di ModelingToolkit.  Ci sono
  alcuni esempi di utilizzo ma con la vecchia sintassi.  Conviene
  davvero riscrivere l'esempio del diodo, switch e resistenza con la
  vecchia sintassi.

* 04.12.23
Scrivo un esempio di messaggio per discourse.

#+begin_example
Greetings.

I am new to `ModelingToolkit` and, more generally, to Julia programming language. In particular, I am using it in my M.Sc. thesis project to model a morphometric lung model (i.e. an electrical equivalent of lung mechanical model taking account of its geometrical properties as well). I am using ModelingToolkit new format with `@mtkmodel` and `@mtkbuild` macros.

One of the problems I am tackling is modeling an ideal Diode Component.
#+end_example

Sono alla ricerca su discourse di informazioni utili.  [[https://discourse.julialang.org/t/mtk-simple-case-with-mtkmodel-and-standard-library-doesnt-work/104807][Questo thread]]
mostra come inizializzare input e output dei moduli.  [[https://discourse.julialang.org/t/tool-for-composable-circuit-simulation/103449][Questo thread]]
mostra come implementare un IdealSwitch con modeling toolkit sia con
vecchio che nuovo formato (in teoria sempre in situazioni stazionarie
ma guarda anche `ControlledSwitch`).

* 05.12.23
Esiste una documentazione di `ModelingToolkit` in fase beta che va ad
elencare le funzioni in fase di sviluppo, non ancora disponibili.
`RealInput` e `RealOutput` sono dedicate a segnali generici e non
rappresentativi di tensioni o correnti.  Ho testato anche
ControlledSwitch ma non funziona correttamente.

* 06.12.23
Devo mandare una mail a Chiara per aggiornarla sullo stato dei lavori.

#+begin_example
Ciao Chiara,
Ti aggiorno su quello che ho fatto negli ultimi giorni.
L'interruttore che avevo implementato, e che ti avevo mostrato l'ultima volta, per ora funziona solo mantenendo l'integrale di corrente in un range che lo tiene sempre aperto oppure sempre chiuso durante la simulazione.
Facendo variare l'integrale di corrente consentendo il superamento della soglia, la simulazione risulta essere instabile.
Ho provato quindi a modificarne l'equazione caratteristica per fare in modo che la transizione della corrente e della tensione fosse più dolce di quella data da uno scalino: ho utilizzato la tangente iperbolica per modulare la resistenza interna dello switch.
Questo mi ha permesso di avere una simulazione che dura un po' di più ma comunque in fase di risoluzione risulta instabile.
Ho scoperto però che si possono scrivere delle callbacks, eventi che si attivano a seguito di una condizione dettata da una o più equazioni definite dall'utente,
Queste callbacks possono essere inserite in fase di risoluzione e dovrebbero limitare, se non addirittura risolvere, l'instabilità del sistema.
Quest'ultima soluzione però non l'ho ancora considerata del tutto perché per me significherebbe necessariamente cestinare il codice che ho scritto in precedenza in quanto le callbacks non sono compatibili con le macro implementate nell'ultima versione di `ModelingToolkit`.
Posso però comunque provare a creare il solito circuito diodo-resistenza-switch utilizzando le callbacks, accertarmi se l'instabilità è risolta e poi agire di conseguenza.
In alternativa scriverei un messaggio sul forum della community di Julia per capire se hanno implementato o hanno intenzione di implementare le callbacks all'interno delle macro che ho già utilizzato.
Ti scrivo di quest'ultima alternativa perché `ModelingToolkit` mi sembra un progetto ancora in attivo sviluppo e ogni mese all'incirca rilasciano nuovi aggiornamenti con delle nuove funzionalità.

Mi dispiace di non essere venuto oggi in laboratorio per aggiornarti di persona ma purtroppo non mi sento bene.
A presto,
Luca
#+end_example

* 11.12.23
Considero il circuito switch-resistenza, riscritto utilizzando il
non-DSL (aka non Domain-Specific Language).  In un esempio, si
utilizza `RealInput` come componente per gestire il segnale da
controllare.

La sintassi per descrivere un componente è la seguente:
#+begin_src julia
  @component function Switch
      # Equazioni, collegamenti ecc.
  end
#+end_src

* 12.12.23
** Switch                                       :Componenti:Julia:Callbacks:
Per comprendere come dichiarare il componente devo prima comprendere
dove verrebbe locata la callback.

#+begin_src julia
  using ModelingToolkit, OrdinaryDiffEq, Plots
  function UnitMassWithFriction(k; name)
      @variables t x(t)=0 v(t)=0
      D = Differential(t)
      eqs = [D(x) ~ v
             D(v) ~ sin(t) - k * sign(v)]
      # Locazione in ODESystem
      ODESystem(eqs, t; continuous_events = [v ~ 0], name) # when v = 0 there is a discontinuity
  end
  @named m = UnitMassWithFriction(0.7)
  prob = ODEProblem(m, Pair[], (0, 10pi))
  sol = solve(prob, Tsit5())
  plot(sol)
#+end_src

Ora posso istanziare il componente `Switch`.

#+begin_src julia
  @component function ControlledSwitch(; name)
      @named n = Pin()
      @named p = Pin()
      @named u = RealInput()
      eqs = [ 0 ~ ifelse(u.u > 0.5, n.v - p.v, n.i)
              0 ~ ifelse(u.u > 0.5, n.i + p.i, p.i)
              ]
      ODESystem(eqs, t, [], []; name,
                systems=[p, n, u], continuous_events=[u.u ~ 0.5])
  end
#+end_src

Purtroppo non funziona neanche in questo modo dato che non riconosce
la variabile `u.u`.
* 13.12.23
Non riesco a scrivere la callback per il diodo.  Devo contattare gli
sviluppatori di `ModelingToolkit` per chiedere come potrei risolvere
il problema.

** DONE [#A] Contattare gli sviluppatori su discourse
*** Definizione del problema
È relativo all'instabilità del modello.  L'instabilità è dovuta
principalmente alla presenza di componenti che creano uno scalino,
vedi l'interruttore.

*** Alcuni test
- [ ] Comprendere se centrano il problema oppure no.
- [X] Cosa succederebbe se inserissi solamente il diodo di Shockley
  nel circuito e poi simulassi? Non funzionerebbe comunque

*** DONE Scrivere il messaggio e poi inoltrarlo a Chiara

** Colloquio con Chiara
Posso discutere sul forum del componente ma prima invio a lei per
capire se, in tal modo, non rivelo nulla dell'eventuale contenuto.

Posso provare a testare anche la funzionalità, ancora in via di
sviluppo, che utilizza gli if sui componenti.

* 14.12.23

#+begin_example
Buongiorno,

Sono nuovo nella community di Julia e di `ModelingToolkit`, in particolare.  Vorrei implementare un componente `DiodoIdeale` che venga rimpiazzato da un corto circuito quando la variabile di controllo (in particolare l'integrale della corrente che lo attraversa) raggiunge uno dei due valori di soglia (0 oppure `Vin_th`).  Inizialmente ho pensato di implementare un modello di diodo ideale semplice ed un modello di switch ideale controllato, realizzando poi un parallelo tra i due nel circuito finale.

Ho riscontrato alcune difficoltà:
- Il componente diodo ideale genera un errore di instabilità dovuto (probabilmente) al fronte di salita troppo ripido, per cui mi sono orientato su un diodo di Shockley.
- Lo switch ideale rimane chiuso, così da escludere il diodo, fino a quando la variabile controllata rimane a zero, quando la variabile diventa positiva, lo switch si apre per poi ritornare chiuso quando la variabile controllata raggiunge un valore `Vin_th`

Questi stratagemmi purtroppo non funzionano in fase di simulazione utilizzando il circuito completo.  Ho letto in alcuni threads che è possibile sfruttare delle Callbacks ma utilizzando le macro `@mtkmodel` ed `@mtkbuild` non ho ben chiaro dove posso inserirle e come scriverle.  Un'altra strada sarebbe quella di utilizzare i condizionali per escludere/includere il diodo nel circuito.  Volevo chiedere dei consigli per evitare di aggirare i problemi dovuti all'instabilità ed affrontarli direttamente.
Fornisco di seguito il codice dei componenti che ho scritto e delle istruzioni che ho utilizzato per la risoluzione.
#+end_example

#+begin_example
Greetings,

I am new to Julia community and, in particular, to the use of `ModelingToolkit` package.  I would like to implement an `IdealDiode` component to be replaced by a short circuit when the controlled variable (i.e. integral of the current flowing into the Diode) has reached one of the two thresholds (being either 0 or `Vin_th`).

Initially, i had thought of implementing a model for a simple ideal diode and a model of an ideal controlled switch. Such devices would be connected in parallel in the final circuit.

I had faced some difficulties:
- Ideal Diode returns instability (dt < dtmin) probably dued to the rising edge. This is why I have decided to go for a Shockley Diode.
- Ideal Switch works this way: if controlled variable is <= 0 or >= `Vin_th`, the switch is closed, so that the diode is excluded. The switch is otherwise open. I am getting the very same error.  I decided to introduce a `tanh` function in the current equation of such device in order to reduce this behavior.

These workarounds seem not to have worked when simulating, considering the full circuit.  In some Threads on Discourse and in the Documentation, I've read about Callbacks but I haven't understood how to write them properly and where to insert them in the DSL code and if there exist some macro helping in this process.  Should I drop the usage of new macros (i.e. @mtkmodel, @mtkbuild ...) for the old format in order to add Callbacks?

Another possibility could be to use conditionals, in order to include/exclude the IdealDiode in the circuit but i don't think this will solve instability, in the end.  I write here to ask some suggestion to avoid workarounds and for some help facing these problems directly.

This is the code i used for modeling.  Forgive my English, it's not my first language.  Thanks in advance for any feedback.

Used libraries

```julia
using ModelingToolkit
using ModelingToolkitStandardLibrary.Blocks
using ModelingToolkitStandardLibrary.Electrical
using OrdinaryDiffEq
using Plots
```

Diode

```julia
@mtkmodel Diode begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        threshold = 0, [description = "Voltage Threshold"]
    end
    @components begin
        input = RealInput()
    end
    @equations begin
        0 ~ ifelse(input.u > 0, v, i)
    end
end
```

ver. 2

```julia
exlin(x, max_x) = ifelse(x > max_x,
                         exp(max_x)*(1 + x - max_x),
                         exp(x))
@mtkmodel Diode begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        Ids     = 1e-6,
        [description = "Reverse-bias current"]
        max_exp = 15,
        [description = "Value after which linearization is applied"]
        R       = 1e8,
        [description = "Diode Resistance"]
        Vth     = 1e-3,
        [description = "Threshold voltage"]
        k       = 1e3,
        [description = "Speed of exponential"]
    end
    @equations begin
        i ~ Ids * (exlin(k * (v - Vth) / Vth, max_exp) - 1) + (v / R)
    end
end
```

Switch:

```julia
@mtkmodel Switch begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        V_FRC, [description = "Airway Volume at FRC"]
    end
    @variables begin
        ∫i(t) = 0, [description = "Current integral"]
    end
    @equations begin
        0 ~ ifelse(∫i / V_FRC <= 0, v,
                   ifelse(∫i / V_FRC < 0.9, i, v))
    end
end
```

Switch ver. 2

```julia
@mtkmodel Switch begin
    @extend v, i = oneport = OnePort()
    @parameters begin
        V_FRC, [description = "Airway Volume at FRC"]
        Rclosed = 1e-12, [description = "Switch Resistance when Closed"]
        Ropen = 2.5e5, [description = "Switch Resistance when Open"]
        k = 1e3
    end
    @variables begin
        ∫i(t) = 0, [description = "Current integral"]
        R(t) = 0,  [description = "Switch Resistance"]
    end
    @equations begin
        R ~ Rclosed + (Ropen - Rclosed) * (1 / 2) * (tanh(k * (∫i / V_FRC) * (1 - (∫i / V_FRC))))
        v ~ R * i
    end
end
```

For performing the simulation I've used:

```julia
@mtkbuild system = System()
prob = ODEProblem(system, Pair[], (0, 2));
sol = solve(prob, Rodas4());
```
#+end_example

** DONE Riprendi da `CONTROLLA` il messaggio da scrivere

* 18.12.23
Ieri sera ho sviluppato una soluzione con l'utilizzo delle Callbacks, la riporto in `[[~/Thesis/src/test/test16c.jl][test16c.jl]]`. Non riesco ad indicizzare per «etichetta».

Colloquio con Chiara. Sistemare il componente Diodo.

* 19.12.23
Mi hanno risposto al post.  Ora sto elaborando un nuovo messaggio.

#+begin_example
Grazie a tutti per le risposte.  Non ho fornito dettagli per ragioni di brevità ma li posso descrivere meglio in questo post.

Devo realizzare un modello morfometrico di polmone umano: un equivalente elettico delle proprietà meccaniche del polmone che tiene conto anche di quelle geometriche a seconda del collegamento di moduli circuitali.

Esistono di due tipi di moduli nel modello morfometrico:
1. Airway: funge da linea di trasmissione.
2. Alveolous: nodo terminale.

Ciascuno di questi (50K) moduli è composto da Resistori, Condensatori, Induttanze e Diodi.  In particolare alcune Resistenze e Condensatori di un modulo sono dipendenti dall'integrale della Corrente entrante in quello specifico modulo.
La Corrente entrante viene sottoposta alla presenza del diodo (posto all'inizio di ciascun modulo) solamente se integrale di corrente è compreso tra 0 e `Vin_th`, altrimenti non ho tale componente.  Questo avviene per delle specifiche di progetto.

L'utilizzo del linguaggio Julia è data dall'esigenza di svincolarsi da licenze proprietarie e di utilizzare efficienti solver di equazioni differenziali come `DifferentialEquations`.

Per ora la mia codebase è stata scritta a partire da ModelingToolkit ma sono aperto a qualunque strumento mi consenta di:
- Creare le due tipologie di moduli
- Istanziare un così grande numero di moduli e, di conseguenza, di componenti
- Simulare il modello morfometrico risultante


#+end_example
* 21.12.23
** TODO [#B] Scrivere risposta su community Julia
** TODO [#A] Finire il resoconto

* 22.12.23
** TODO Leggere le mail nella cartella `Tesi magistrale`
Su thunderbird ho un nuovo progetto da portare avanti per la tesi.
** TODO [#A] Installare il software necessario (paper)
Il software va compilato da sorgente e si trova in `Repo/avatree`.
Il software girerebbe solo su windows, come scritto su readme.

* 04.01.24
Da ciò che è scritto sulle mail inoltratemi da Chiara, sembrerebbe che
il software non possa eseguire correttamente su Linux.  Devo eseguire
quel software utilizzando VisualStudio 2019.

** DONE Installa VisualStudio 2019
** TODO Compila AVATree da sorgente

* 11.01.24
In questi giorni è comparso un [[https://github.com/SciML/ModelingToolkit.jl/issues/2421][issue su Github]] che vuole introdurre
gli eventi continui e discreti nei componenti.  Spero che abbia
abbastanza visibilità da poter essere mergiato in main.  Sarebbe
fantastico.  Da tenere sotto controllo e da testare.

* 12.01.24
Quell'issue si è dimostrato utile perchè ha risolto il problema degli
eventi continui e discreti nella progettazione di componenti.  Ora
resta da capire come posso utilizzare questa feature nella
progettazione del diodo e dello switch.
