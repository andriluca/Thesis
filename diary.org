#+title: Diario dei Log del progetto
#+author: Luca Andriotto
#+STARTUP: overview

Raccolgo in questo file cosa è stato fatto/scoperto ogni giorno.

* 11.10.23
- [X] La funzione =squarewave= è buggata e non può essere utilizzata come input del sistema in Julia. Posso riscriverla semplicemente
- Il numero di threads utilizzabile è settabile all'avvio della REPL (-t auto).
- La repl, da Emacs, non produce correttamente i grafici quindi è sempre meglio avere un terminale sotto mano
- =test3.jl= fa il suo dovere

* 12.10.23
- ~test3.jl~ non permette di estrarre i flussi (aka le correnti) dalle soluzioni. Passo alla soluzione cosiddetta acausale (circuitale). La soluzione sarà riportata in ~test4.jl~.

* 16.10.23                                               :Modello:Componenti:
- La modularità del circuito è realizzata mediante dei modelli appositi, chiamati `Block`s:

#+begin_src julia
  @mtkmodel Block begin
      @components begin
          in = Pin()
          out = Pin()
          resistor = Resistor(R = 1.0)
          capacitor = Capacitor(C = 1.0)
          ground = Ground()
      end
      @equations begin
          connect(in, resistor.p)
          connect(resistor.n, capacitor.p)
          connect(out, capacitor.p)
          connect(capacitor.n, ground.g)
      end
  end
#+end_src

Questi blocchi hanno un punto d'ingresso ed uno di uscita, comodi per effettuare dei collegamenti più complessi con blocchi in cascata.

Il sistema quindi altro non è se non una composizione di blocchi:

#+begin_src julia
  @mtkmodel System begin
      @components begin
          block1 = Block(resistor.R = 2.0)
          block2 = Block(resistor.R = 2.0)
          constant = Constant(k = 1.0)
          source = Voltage()
          ground = Ground()
      end
      @equations begin
          connect(constant.output, source.V)
          connect(source.p, block1.in)
          connect(block1.out, block2.in)
          connect(source.n, ground.g)
      end
  end
#+end_src

Il codice completo è in ~test5.jl~.

- Vi sono altri due problemi ora:
  - [X] Generare diversi blocchi (airway e alveolo) con diverse strutture.
  - [ ] Rendere la resistenza `Rtube` variabile e dipendente dall'integrale della corrente.

- Nel file ~Albero.cir~, l'ultima riga rappresenta la trachea.  enable, IN sono due ingressi, NodeAA e TrigAB sono due uscite (stando a quello che dice Chiara).

* 17.10.23                                               :Modello:Componenti:
- Per entrambi gli schematici si vedano i fogli stampati.  Queste sono le versioni senza resistenza variabile.

#+begin_src julia
  @mtkmodel Airway begin
      @components begin
          in       = Pin()
          out      = Pin()
          r_tube   = Resistor(R = 1.0)
          i_tube   = Inductor(L = 1.0)
          c_g      = Capacitor(C = 1.0)
          r_sw     = Resistor(R = 1.0)
          i_sw     = Inductor(L = 1.0)
          c_sw     = Capacitor(C = 1.0)
          r_tube_1 = Resistor(R = 1.0)
          i_tube_1 = Inductor(L = 1.0)
          ground   = Ground()
      end
      @equations begin
          connect(in, r_tube.p)
          connect(r_tube.n, i_tube.p)
          connect(i_tube.n, c_g.p, i_sw.p, r_tube_1.p)
          connect(i_sw.n, r_sw.p)
          connect(r_sw.n, c_sw.p)
          connect(r_tube_1.n, i_tube_1.p)
          connect(out, i_tube_1.n)
          connect(c_g.n, c_sw.n, ground.g)
      end
  end
#+end_src

#+begin_src julia
  @mtkmodel Alveolo begin
      @components begin
          in     = Pin()
          out    = Pin()
          r_tube = Resistor(R = 1.0)
          i_tube = Inductor(L = 1.0)
          c_ga   = Capacitor(C = 1.0)
          i_t    = Inductor(L = 1.0)
          r_t    = Resistor(R = 1.0)
          c_t    = Capacitor(C = 1.0)
          r_s    = Resistor(R = 1.0)
          c_s    = Resistor(R = 1.0)
          ground   = Ground()
      end
      @equations begin
          connect(in, r_tube.p)
          connect(r_tube.n, i_tube.p)
          connect(i_tube.n, c_ga.p, i_t.p, out)
          connect(i_t.n, r_t.p)
          connect(r_t.n, c_t.p)
          connect(c_t.n, c_s.p, r_s.p)
          connect(c_ga.n, c_s.n, r_s.n, ground.g)
      end
  end
#+end_src

- [X] Lavorare sull'importazione di file CSV in cui ciascuna colonna corrisponde ad un array di variabili dello stesso tipo (tutte resistenze...).

* 18.10.23                                                            :Input:

Tramite questo codice posso importare un CSV come DataFrame.
#+begin_src julia
  # Read a DataFrame from CSV file
  df = CSV.read("data.csv", DataFrame)
  r = df.x1
#+end_src

- [X] Consulta il materiale fornito da Chiara per messaggio

* 20.10.23                              :Modello:Verilog:Parametri:Variabili:

Devo utilizzare IA{D, E, F, G, H, I}, IB{L, A, B} di `Albero.cir`


#+begin_example
IBB ( TrigBLB NodeBLA NodeBBA TrigBBB Vcharge ) alveolo_completo_luglio La= 5.896531e-03 Lb= 5.236159e+00 Ra= 2.282920e+02 Rb= 1.114955e+04 Chargeth= 5.185713e-07 Ccap= 2.463766e-07 Vin_th= 7.098371e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IBA ( TrigBLB NodeBLA NodeBAA TrigBAB Vcharge ) alveolo_completo_luglio La= 5.687354e-03 Lb= 5.050408e+00 Ra= 2.017423e+02 Rb= 9.852891e+03 Chargeth= 5.958497e-07 Ccap= 2.464514e-07 Vin_th= 6.794462e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IBL ( TrigAHB NodeAHA NodeBLA TrigBLB ) zwall_semplificato_veriloga La= 1.290849e-03 Lb= 1.159971e+00 Ra= 3.097440e+01 Rb= 1.512758e+03 Rws= 1.461035e+07 Lws= 9.016810e-01 Cws= 1.003855e-10 Chargeth= 5.910861e-07 Ccap= 5.722034e-10 Vin_th= 5.588244e+00 Vgravity= 0
IAH ( TrigAFB NodeAFA NodeAHA TrigAHB ) zwall_semplificato_veriloga La= 1.653093e-03 Lb= 1.485488e+00 Ra= 3.554331e+01 Rb= 1.735899e+03 Rws= 8.703449e+06 Lws= 5.994469e-01 Cws= 1.685156e-10 Chargeth= 9.427715e-07 Ccap= 9.126539e-10 Vin_th= 5.289833e+00 Vgravity= 0
IAF ( TrigADB NodeADA NodeAFA TrigAFB ) zwall_semplificato_veriloga La= 1.166141e-03 Lb= 1.047907e+00 Ra= 2.231464e+01 Rb= 1.089824e+03 Rws= 9.257208e+06 Lws= 7.164089e-01 Cws= 1.584351e-10 Chargeth= 8.396596e-07 Ccap= 8.128360e-10 Vin_th= 4.990351e+00 Vgravity= 0
IAD ( TrigACB NodeACA NodeADA TrigADB ) zwall_semplificato_veriloga La= 1.852803e-03 Lb= 1.664949e+00 Ra= 3.100029e+01 Rb= 1.514023e+03 Rws= 4.186147e+06 Lws= 3.705082e-01 Cws= 3.503620e-10 Chargeth= 1.744963e-06 Ccap= 1.689219e-09 Vin_th= 4.666378e+00 Vgravity= 0

[...]

IAE ( TrigADB NodeADA NodeAEA TrigAEB Vcharge ) alveolo_completo_luglio La= 6.440085e-03 Lb= 5.718839e+00 Ra= 3.109214e+02 Rb= 1.518509e+04 Chargeth= 3.642283e-07 Ccap= 2.462271e-07 Vin_th= 7.926677e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IAG ( TrigAFB NodeAFA NodeAGA TrigAGB Vcharge ) alveolo_completo_luglio La= 6.908560e-03 Lb= 6.134848e+00 Ra= 4.012746e+02 Rb= 1.959785e+04 Chargeth= 2.699475e-07 Ccap= 2.461359e-07 Vin_th= 8.694383e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
IAI ( TrigAHB NodeAHA NodeAIA TrigAIB Vcharge ) alveolo_completo_luglio La= 7.229610e-03 Lb= 6.419942e+00 Ra= 4.759710e+02 Rb= 2.324594e+04 Chargeth= 2.198790e-07 Ccap= 2.460874e-07 Vin_th= 9.256451e+00 Vgravity= 0 Lti= 5.795540e-04 Rti= 1200 Cti= 2.400000e-05 Rs= 80000 Cs= 2.100000e-05
#+end_example

** IAD ( TrigACB NodeACA NodeADA TrigADB ) zwall_semplificato_veriloga 

La= 1.852803e-03 -- sarebbe la I
Lb= 1.664949e+00
Ra= 3.100029e+01 -- resistenza in aria
Rb= 1.514023e+03 -- quello da aggiungere per avere quella in acqua (rl - ra)
Rws= 4.186147e+06
Lws= 3.705082e-01
Cws= 3.503620e-10
Chargeth= 1.744963e-06 -- V_FRC
Ccap= 1.689219e-09 -- C_g
Vin_th= 4.666378e+00 -- tensione su primo diodo
Vgravity= 0

** IAE ( TrigADB NodeADA NodeAEA TrigAEB Vcharge ) alveolo_completo_luglio

La= 6.440085e-03
Lb= 5.718839e+00 
Ra= 3.109214e+02 
Rb= 1.518509e+04 
Chargeth= 3.642283e-07 
Ccap= 2.462271e-07 
Vin_th= 7.926677e+00 
Vgravity= 0 
Lti= 5.795540e-04 
Rti= 1200 
Cti= 2.400000e-05 
Rs= 80000 
Cs= 2.100000e-05

** IAF ( TrigADB NodeADA NodeAFA TrigAFB ) zwall_semplificato_veriloga

La= 1.166141e-03
Lb= 1.047907e+00
Ra= 2.231464e+01
Rb= 1.089824e+03
Rws= 9.257208e+06
Lws= 7.164089e-01
Cws= 1.584351e-10
Chargeth= 8.396596e-07
Ccap= 8.128360e-10
Vin_th= 4.990351e+00
Vgravity= 0

** IAG ( TrigAFB NodeAFA NodeAGA TrigAGB Vcharge ) alveolo_completo_luglio

La= 6.908560e-03
Lb= 6.134848e+00
Ra= 4.012746e+02
Rb= 1.959785e+04
Chargeth= 2.699475e-07
Ccap= 2.461359e-07
Vin_th= 8.694383e+00
Vgravity= 0 
Lti= 5.795540e-04
Rti= 1200
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IAH ( TrigAFB NodeAFA NodeAHA TrigAHB ) zwall_semplificato_veriloga

La= 1.653093e-03
Lb= 1.485488e+00
Ra= 3.554331e+01
Rb= 1.735899e+03
Rws= 8.703449e+06
Lws= 5.994469e-01
Cws= 1.685156e-10
Chargeth= 9.427715e-07
Ccap= 9.126539e-10
Vin_th= 5.289833e+00
Vgravity= 0

** IAI ( TrigAHB NodeAHA NodeAIA TrigAIB Vcharge ) alveolo_completo_luglio

La= 7.229610e-03
Lb= 6.419942e+00
Ra= 4.759710e+02
Rb= 2.324594e+04
Chargeth= 2.198790e-07
Ccap= 2.460874e-07
Vin_th= 9.256451e+00
Vgravity= 0
Lti= 5.795540e-04
Rti= 1200 
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IBL ( TrigAHB NodeAHA NodeBLA TrigBLB ) zwall_semplificato_veriloga 
La= 1.290849e-03 
Lb= 1.159971e+00 
Ra= 3.097440e+01 
Rb= 1.512758e+03 
Rws= 1.461035e+07 
Lws= 9.016810e-01 
Cws= 1.003855e-10 
Chargeth= 5.910861e-07 
Ccap= 5.722034e-10 
Vin_th= 5.588244e+00 
Vgravity= 0

** IBB ( TrigBLB NodeBLA NodeBBA TrigBBB Vcharge ) alveolo_completo_luglio
La= 5.896531e-03
Lb= 5.236159e+00
Ra= 2.282920e+02
Rb= 1.114955e+04
Chargeth= 5.185713e-07
Ccap= 2.463766e-07
Vin_th= 7.098371e+00
Vgravity= 0
Lti= 5.795540e-04
Rti= 1200
Cti= 2.400000e-05
Rs= 80000
Cs= 2.100000e-05

** IBA ( TrigBLB NodeBLA NodeBAA TrigBAB Vcharge ) alveolo_completo_luglio 
La= 5.687354e-03 
Lb= 5.050408e+00 
Ra= 2.017423e+02 
Rb= 9.852891e+03 
Chargeth= 5.958497e-07 
Ccap= 2.464514e-07 
Vin_th= 6.794462e+00 
Vgravity= 0 
Lti= 5.795540e-04 
Rti= 1200 
Cti= 2.400000e-05 
Rs= 80000 
Cs= 2.100000e-05

Questi sono tutti i dati che ho trovato ma non so interpretare i nomi dei componenti nel file `Albero.cir` con i corrispettivi nel modello.

Penso sia necessario elencare i parametri e le variabili in gioco (dal documento cartaceo fornito da Chiara).

** Parametri
*** Non-terminal units (Airway)

| Parametro                     | Simbolo |   Valore | Unità             |
|-------------------------------+---------+----------+-------------------|
| Air density                   | \rho_a  | 1.132e-2 | cmH2O * s^2 / m^2 |
| Air viscosity                 | \mu_a   | 1.739e-7 | cmH2O * s         |
| Atmospheric pressure          | P_{at}  |     1033 | cmH2O             |
| Fetal fluid density           | \rho_l  |  1.006e1 | cmH2O * s^2 / m^2 |
| Fetal fluid viscosity         | \mu_l   | 8.667e-6 | cmH2O * s         |
| Radius at FRC                 | r_{FRC} |          | cm                |
| Surface tension               | \gamma  |      .04 | cm * cmH2O        |
| Young modulus of soft tissues | Y_s     |      600 | [N / m^2]         |
| (?) Density                   | \rho_s  |      .88 | [g / mL?]         |
| (?) Viscosity                 | \mu_s   |     1.06 | g / mL            |

Il valore di viscosità non mi convince (nemmeno nell'unità di misura).

*** Terminal units (Alveoli)

| Parametro                                      | Simbolo |        Valore | Unità                                  |
|------------------------------------------------+---------+---------------+----------------------------------------|
| Air density                                    | \rho_a  |      1.132e-2 | cmH2O*s^2/m^2                          |
| Air viscosity                                  | \mu_a   |      1.739e-7 | cmH2O*s                                |
| Atmospheric pressure                           | P_{at}  |          1033 | cmH2O                                  |
| Fetal fluid density                            | \rho_l  |       1.006e1 | cmH2O*s^2/m^2                          |
| Fetal fluid viscosity                          | \mu_l   |      8.667e-6 | cmH2O*s                                |
| Radius at FRC                                  | r_{FRC} |               | cm                                     |
| Surface tension                                | \gamma  |           .04 | cm*cmH2O                               |
| Young modulus soft tissues                     | Y_s     |           600 |                                        |
| Tissue compliance related to stress relaxation | C_s     |      7e-8 * 3 |                                        |
| Static tissue compliance                       | C_t     |      8e-8 * 3 | L / cmH2O                              |
| Tissue inertance                               | I_t     | .00069/300*NA | cmH2O * s^2 / L                        |
| Tissue resistance related to stress relaxation | R_s     |           8e6 | cmH2O * s / L                          |
| Newtonian tissue resistance                    | R_t     |          12e4 | cmH2O * s / L                          |
| (?) Density                                    | \rho_s  |           .88 |                                        |
| (?) Viscosity                                  | \mu_s   |          1.06 | [g/mL da documento ma non mi convince] |

** Variabili
*** Non-terminal units

| Variabili                                     | Simbolo  | Range              | Unità           | Formula                                                                                   |
|-----------------------------------------------+----------+--------------------+-----------------+-------------------------------------------------------------------------------------------|
| Capillary pressure due to air-fluid interface | V_{th}   | .2 - 9.1           | cmH2O           | \dfrac{\gamma}{r_{FRC}} in air, 0 otherwise.                                              |
| Airway Resistance                             | R_{tube} |                    | cmH2O * s / L   | R_a + (R_l - R_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})         |
| Resistance (air-filled)                       | R_{a}    | .64 - 4.50e4       | cmH2O * s / L   | \dfrac{8\mu_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                         |
| Resistance (liquid-filled)                    | R_{l}    | 32 - 2.24e6        | cmH2O * s / L   | \dfrac{8\mu_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                         |
| Volume at FRC                                 | V_{FRC}  |                    | L               | \pi\cdot {r_{FRC}}^2 \cdot l_{FRC}                                                        |
| Flow*                                         | \dot{V}  |                    | [L / s]         |                                                                                           |
| Airway inertance                              | I_{tube} |                    | cmH2O * s^2 / L | I_a + (I_l - I_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})         |
| Inertance (air-filled)                        | I_{a}    | .95e-2 - .91       | cmH2O * s^2 / L | \dfrac{8\rho_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                        |
| Inertance (liquid-filled)                     | I_{l}    | 8.58 - 816.22      | cmH2O * s^2 / L | \dfrac{8\rho_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                        |
| Shunt airway compliance due to gas            | C_g      |                    | L / cmH2O       | C_{FRC}\cdot (\dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}}) in air, 0 otherwise. |
| Airway compliance at FRC                      | C_{FRC}  | 2.27e-13 - 4.32e-7 | L / cmH2O       | \dfrac{\pi\cdot {r_{FRC}}^2 \cdot l_{FRC}}{P_{at}}                                        |
| Airway tissue shunt impedance                 | Z_w      |                    | cmH2O * s / L   | R_{ws} + j \cdot (\omega \cdot I_{ws} - \dfrac{1}{\omega \cdot C_{ws}})                   |
| Resistance of the soft tissues**              | R_{sw}   |                    | cmH2O * s / L   | \dfrac{h_k \cdot \mu_{s}}{2\pi {r_{FRC}}^3 \cdot l_{FRC}}                                 |
| Inertance of the soft tissues**               | I_{sw}   |                    | cmH2O * s^2 / L | \dfrac{h_k \cdot \rho_{s}}{2\pi r_{FRC} \cdot l_{FRC}}                                    |
| Compliance of the soft tissues**              | C_{sw}   |                    | L / cmH2O       | \dfrac{2\pi {r_{FRC}}^3 \cdot l_{FRC}}{h_k \cdot \Y_{s}}                                  |
|                                               | h_k      |                    | [cm?]           | \sqrt{{r_k}^2 + \dfrac{w_{ak}}{\pi}} - r_k                                                |
|                                               | w_{ak}   |                    | [?]             | .033(2\pi\cdot r_k \cdot 1000 - .08) + .056                                               |
| Resistance of airway soft tissues**           | R_{ws}   | 1.14e1 - 2.27e7    | cmH2O * s / L   | \dfrac{h_k \cdot \mu_{s}}{2\pi {r_{FRC}}^3 \cdot l_{FRC}}                                 |
| Inertance of airway soft tissues**            | I_{ws}   | 5.77e-4 - 1.13e-1  | cmH2O * s^2 / L | \dfrac{h_k \cdot \rho_{s}}{2\pi r_{FRC} \cdot l_{FRC}}                                    |
| Compliance of airway soft tissues**           | C_{ws}   | 5.64e-11 - 1.28e-4 | L / cmH2O       | \dfrac{2\pi {r_{FRC}}^3 \cdot l_{FRC}}{h_k \cdot \Y_{s}}                                  |


*: Quando facciamo l'integrale nel tempo, gli estremi temporali significano il tempo in cui l'interfaccia aria-liquido entra nella airway e il tempo in cui essa esce.
**: Sono la stessa cosa?? Assumo la loro uguaglianza nel mio ragionamento.

*** Terminal units

| Variabili                                                        | Simbolo    | Range         | Unità           | Formula                                                                                                                                               |
|------------------------------------------------------------------+------------+---------------+-----------------+-------------------------------------------------------------------------------------------------------------------------------------------------------|
| Capillary pressure due to air-fluid interface of the acinar unit | v_{thA}    | 1.2 - 10.3    | cmH2O           | \dfrac{2\gamma}{r_k} at the interface, 0 otherwise.                                                                                                   |
| Airway Resistance                                                | R_{tube}   |               | cmH2O * s / L   | \dfrac{R_a + (R_l - R_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}})}{\frac{V_0 + \int\limits_{t_0}^{t} {\dot{V} dt}}{V_{FRC,A}}} |
| Resistance (air-filled)                                          | R_a        | .64 - 4.50e4  | cmH2O * s / L   | \dfrac{8\mu_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                                                                                     |
| Resistance (liquid-filled)                                       | R_l        | 32 - 2.24e6   | cmH2O * s / L   | \dfrac{8\mu_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^4}                                                                                                     |
| Volume at FRC                                                    | V_{FRC}    |               | L               | \pi\cdot {r_{FRC}}^2 \cdot l_{FRC}                                                                                                                    |
| Volume at FRC [acinar?]                                          | V_{FRC,A}  |               | L               | \dfrac{FRC}{N_A}                                                                                                                                      |
|                                                                  | V_0        |               | L               | \dfrac{\text{initial liquid volume}}{N_A}                                                                                                             |
| Airway inertance                                                 | I_{tube}   |               | cmH2O * s^2 / L | I_a + (I_l - I_a)\cdot(1 - \dfrac{\int\limits_{t_i}^{t_f} {\dot{V} dt}}{V_{FRC}}) in air, 0 otherwise.                                                |
| Inertance (air-filled)                                           | I_a        | .95e-2 - .91  | cmH2O * s^2 / L | \dfrac{8\rho_a\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                                                                                    |
| Inertance (liquid-filled)                                        | I_l        | 8.58 - 816.22 | cmH2O * s^2 / L | \dfrac{8\rho_l\cdot l_{FRC}}{\pi\cdot {r_{FRC}}^2}                                                                                                    |
| Shunt terminal unit compliance due to gas                        | C_{gA}     |               | L / cmH2O       | C_{FRC,A}\cdot (\dfrac{\int\limits_{t_i}^{t_fA} {\dot{V} dt}}{V_{FRC,A}}) in air, 0 otherwise.                                                        |
|                                                                  | C_{FRC,A}  |               | L / cmH2O       | \dfrac{\text{FRC}}{P_{at} N_A} + \dfrac{\pi {r_FRC}^2 l_{FRC}}{P_{at}}                                                                                |
| Acinar tissue impedance                                          | Z_{tissue} |               | cmH2O * s / L   | R_t + j \cdot (\omega\cdot I_t - \dfrac{1}{\omega \cdot C_t}) + \dfrac{R_s}{1 + j\omega C_s R_s}                                                      |

** DONE Domande da fare
1. La resistenza `R_{tube}` ha diverse formule per i due modelli distinti (ossia per airway e alveolo)? yes
2. Nel parametro `I_t` il valore NA è il numero di Avogadro? boh

* 23.10.23                                                          :Verilog:
- Continuo il lavoro del 20.10 per sistemare le variabili ed i parametri del modello per capire di più.
- Rivedo il file in Verilog per comprendere le formule implementate.

** Unità non terminali
- [ ] Capire cosa significa `inout`
- [ ] Capire il ruolo di `through`
- [ ] Cosa sono nodeA e nodeC?
- [X] Cosa significa `cross` in Verilog? vedi [[https://verilogams.com/refman/modules/analog-procedural/timing.html#index-8][questa risorsa]]
- [ ] Non capisco perché non considero la caduta di potenziale sulla
  capacità ma quella tra il nodo `through` e `nodeC`.

Crea degli input (pin):
1. enable
2. IN

Crea degli output:
1. triggerOut

Vi sono una serie di variabili, istanziate come intere o reali.

*Intere*:
1. integration_en
2. sw_state: questa flag sembra controllare lo "stato" del programma.

*Reali*:
1. Lvalue
2. Rvalue
3. Cvalue
4. threshold
5. charge
6. trigout
7. thresholdb

Noto che ci sono i parametri "simili" a quelli del file `Albero.cir` (i.e. stessi nomi).

#+begin_src verilog
  // VerilogA for BIO, cella_zwall, veriloga

  `include "constants.vams"
  `include "disciplines.vams"

  module zwall_semplificato_veriloga_events(enable, IN, OUT, triggerOUT);

     // [Inputs]
     input enable;
     electrical enable;
     inout IN, OUT;
     electrical IN, OUT, through;
     electrical integration;
     // [Outputs]
     output triggerOUT;
     electrical triggerOUT;

     // [Nodi]
     electrical nodeA, nodeC; //, nodeB;

     ground gnd;

     // [Parametri simili ad `Albero.cir`]
     parameter La       = 1e-6;
     parameter Lb       = 10e-6;
     parameter Ra       = 1e-3;
     parameter Rb       = 10e-3;
     parameter Rws      = 1;
     parameter Lws      = 1e-3;
     parameter Cws      = 1e-6;
     parameter Chargeth = 10e-6;
     parameter Ccap     = 1e-6;

     parameter Vin_th   = 1;
     parameter Vgravity = 0;

     // Variabili (intere e reali)
     integer   integration_en = 0, sw_state=1;
     real	  Lvalue = 0, Rvalue = 0, Cvalue = 0;
     real	  threshold = 1, charge = 0, trigout = 0, thresholdb = 0.5;

     analog begin

        @(cross(V(enable, gnd) - 0.5, +1)) begin
           integration_en = 1;
        end

        V(integration, gnd) <+ idt(integration_en * I(through, OUT)) / Chargeth;
        charge = min(V(integration, gnd), 1);

        @(cross(charge - threshold, +1)) begin
           sw_state = 0;
           trigout  = 1;
        end

        V(triggerOUT, gnd) <+ transition(trigout, 0, 10n, 10n);

        // [A seconda del valore di `sw_state` associo diversi valori a {R, L, C}value].
        if (sw_state == 1)
          begin
             Lvalue = La + Lb * max(0, (1 - charge));
             Rvalue = Ra + Rb * max(0, (1 - charge));
             Cvalue = max(1e - 12, Ccap * charge);
          end
        else
          begin
             Lvalue = La;
             Rvalue = Ra;
             Cvalue = Ccap;
          end

        // [Per ora lascio stare]
        V(IN, nodeA)       <+ V(enable, gnd) * transition(sw_state*Vin_th, 0, 10u, 10u) + Vgravity; // *restricted
        // [Lvalue e Rvalue corrispondono a L_{tube}/2 e a R_{tube}/2 rispettivamente]
        V (nodeA, through) <+  Lvalue * ddt(I(nodeA, through)) + (Rvalue) * I(nodeA, through);

        I (through, nodeC) <+ Cws * ddt(V(through, nodeC));
        V (nodeC, gnd)     <+ Rws * I(nodeC, gnd) + Lws * ddt(I(nodeC, gnd));
        // [OUT probabilmente è l'ultimo nodo sulla destra.]
        V(through, OUT)    <+ Rvalue * I(through, OUT) + Lvalue * ddt(I(through, OUT));
        I(through, gnd)    <+ ddt(Cvalue * V(through, gnd));

     end

  endmodule
  #+end_src

** Unità terminali (alveoli)

#+begin_src verilog
  // VerilogA for BIO, alveolo_veriloga, veriloga

  `include "constants.vams"
  `include "disciplines.vams"

  module alveolo_completo_aprventitre(enable, IN, OUT, triggerOUT, Vcharge);

     // [Nodi di Input -- Pin]
     input enable;
     electrical enable;
     input  Vcharge;
     electrical Vcharge;

     // [Porte leggibili?]
     inout IN, OUT;
     electrical IN, OUT;

     // [Nodi di Output -- Port]
     output triggerOUT;
     electrical triggerOUT;

     // [Nodi]
     electrical nodeA, nodeB;

     ground gnd;

     // [Parametri simili ad `Albero.cir`]
     parameter La       = 1e-6;
     parameter Lb       = 10e-6;
     parameter Ra       = 1e-3;
     parameter Rb       = 10e-3;
     parameter Chargeth = 10e-6;
     parameter Ccap     = 1e-6;
     parameter Vin_th   = 1;
     parameter Vgravity = 0;
     parameter Lti      = 1e-3;
     parameter Rti      = 1e-3;
     parameter Cti      = 1e-3;
     parameter Rs       = 1;
     parameter Cs       = 1e-6;

     // [Variabili intere e reali]
     integer integration_en = 0;
     real	Lvalue = 0, Rvalue = 0, Cvalue = 0, Rvalb = 0;
     real	threshold = 1;
     real	Vinteg = 0;
     real	VintegARIA = 0;
     real	charge = 0;
     real	chargeb = 0;
     real	chargec = 0;
     real	aux = 0;
     real	trigout = 0;
     real	temp = 1;
     real	Ctival = Cti, Csval = Cs, mult = 1, sw_state = 1;
     real	Vin_th2 = 0;
     real	th_swap = 0; 

     analog begin
        // la `@` consiste in una tipologia di if specifica per gli eventi, praticamente.
        @(cross(V(enable, gnd) - 0.5, +1)) begin
           integration_en = 1;
        end

        // Faccio l'integrazione quando la tensione su enable ha attraversato lo 0 in rising.
        // Se supero la threshold in modalità rising.
        VintegARIA = idt(integration_en * I(nodeA, OUT));
        // Faccio l'integrazione in ogni caso.
        Vinteg     = idt(I(nodeA, OUT));

        // Prendo il minimo tra 1 e il massimo tra 0 e il rapporto tra
        // l'integrale della corrente con il volume massimo a FRC.
        // Charge rappresenta la percentuale di volume occupata
        // dall'aria.

        charge  = min(1, max(0, VintegARIA / Chargeth));  //serve per R, l e cambio Vin_th e Vin_th2
        // Uso una costante per V_FRC
        chargec = min(1, max(0, VintegARIA / (2.5399e-4)));

        // Uso altre costanti
        chargeb = max(0,((Vinteg - 1.27e-4) / (2.5399e-4 - 1.27e-4)));

        aux  = min(1, (0.06 + chargeb));
        temp = 1;  //modifica del 21 luglio

        @(cross(chargec - threshold, +1)) begin //fine dell'integrazione della carica
           trigout  = 1; 
           sw_state = 0;
        end

        @(cross((charge - 1), +1)) begin
           th_swap = 1;
        end

        V(triggerOUT, gnd) <+ transition (trigout, 0, 10n, 10n);

        Rvalb = (Ra / aux);

        Lvalue = La + Lb * max(0,(1 - charge));
        Rvalue = (Rb / aux) * max(0,(1 - charge));

        Ctival = Cti / (temp); // va da Cti a Cti/15 quando ho raggiunto chargeb/2
        Csval  = Cs / (temp);// come sopra
        Cvalue = max(1e-15, Ccap * chargec);

        Vin_th2 = 0.08 / (pow((3 * max(VintegARIA / 100, 1e-8)) / (12.56), 1/3));

        V(IN, nodeA)   <+ V(enable, gnd) * Vin_th * transition ((1-th_swap), 0, 10u, 10u);
        V (nodeA, OUT) <+ Lvalue * ddt(I(nodeA, OUT)) +(Rvalb + Rvalue) * I(nodeA, OUT) + Vin_th2 * transition (th_swap, 0, 10u, 10u);
        I(OUT, gnd)    <+ Cvalue * ddt(V(OUT, gnd));
        V(OUT, nodeB)  <+ Lti * ddt(I(OUT, nodeB)) + Rti * I(OUT, nodeB) + idt(I(OUT, nodeB)) / (transition(Ctival * mult, 0, 10u, 10u));
        I(nodeB, gnd)  <+ V(nodeB, gnd) / Rs + transition(Csval * mult, 0, 10u, 10u) * ddt(V(nodeB, gnd));

     end
  endmodule
#+end_src

* 24.10.23                                   :Modello:Parametri:Bibliografia:
Riprendo le domande che avevo ieri.
- `inout`: tipo una porta readable.

Considerazioni:
- Una buona risorsa dove iniziare ad imparare il Verilog è [[https://verilogams.com][questa]].

** Colloquio con Chiara
Dice che forse è meglio tentare un approccio iterativo dopo il quale
posso integrare la corrente nel tempo di simulazione per cambiare i
valori di resistenza.  Dice che posso andare avanti con Julia se posso
inserire dei componenti variabili (tempo varianti o in funzione di
altre variabili come V(out) o I(nodeA, out)).  Le faccio qualche
domanda. Ora so a cosa corrispondono i vari componenti nel modello, in
termini di simboli utilizzati nel file `Albero.cir`.

** Non terminali

| ".cir"   | Modello cartaceo                                                    |
|----------+---------------------------------------------------------------------|
| La       | Induttanza in aria                                                  |
| Lb       | Quello da aggiungere per avere l'induttanza nel liquido (I_l - I_a) |
| Ra       | Resistenza in aria                                                  |
| Rb       | Quello da aggiungere per avere la resistenza nel liquido (rl - ra)  |
| Rws      | Resistenza del ramo sotto                                           |
| Lws      | Induttanza del ramo sotto                                           |
| Cws      | capacità del ramo sotto                                             |
| Chargeth | V_{FRC}                                                             |
| Ccap     | C_g                                                                 |
| Vin_th   | Tensione sul primo diodo (aka V_{th})                               |
| Vgravity |                                                                     |

** Terminali

| ".cir"   | Modello cartaceo                                                    |
|----------+---------------------------------------------------------------------|
| La       | Induttanza in aria                                                  |
| Lb       | Quello da aggiungere per avere l'induttanza nel liquido (I_l - I_a) |
| Ra       | Resistenza in aria                                                  |
| Rb       | Quello da aggiungere per avere la resistenza nel liquido (rl - ra)  |
| Chargeth | V_{FRC}                                                             |
| Ccap     | C_g                                                                 |
| Vin_th   | Tensione sul primo diodo (aka V_{th})                               |
| Vgravity |                                                                     |
| Lti      | Vedi grafico                                                        |
| Rti      | Vedi grafico                                                        |
| Cti      | Vedi grafico                                                        |
| Rs       | Vedi grafico                                                        |
| Cs       | Vedi grafico                                                        |

* 25.10.23                                               :Modello:Componenti:
** DONE Esiste un componente "Diodo" in Julia                   :Componenti:
Non sembrerebbe esistere un componente "Diodo" nella libreria standard
di `ModelingToolkit`.
** Scrivo tutte le equazioni differenziali in Julia
NodeC non corrisponde alla sua definizione nel modello elettrico: è
come se l'induttanza e la resistenza sopra fossero scambiate di posto
con la capacità che sta sotto (il nodo non è così importante stando a
quello che dice Chiara).
** Quali sono le variabili in funzione del tempo di cui conosciamo l'andamento? :Variabili:
Probabilmente anche quest'informazione la posso ricavare dal Verilog.
Sicuramente la forma d'onda della tensione in ingresso.  Non so se
sappiamo qualcosa del flusso

** DONE Quali sono le equazioni differenziali che devo risolvere in ciascun modulo?
Sicuramente sono contenute nei file Verilog quindi ripartirei da lì.
Il Verilog contiene queste equazioni.

*** Non terminali
#+begin_src verilog
  // 1 -- [tensione tra Rvalue e Lvalue]
  V (nodeA, through) <+ Lvalue * ddt(I(nodeA, through)) + (Rvalue) * I(nodeA, through);
  // 2 -- [corrente attraverso Cws]
  I (through, nodeC) <+ Cws * ddt(V(through, nodeC));
  // 3 -- [tensione sul blocco Rws-Lws]
  V (nodeC, gnd)     <+ Rws * I(nodeC, gnd) + Lws * ddt(I(nodeC, gnd));
  // 4 -- [tensione su Cvalue]
  // [OUT probabilmente è l'ultimo nodo sulla destra.]
  V(through, OUT)    <+ Rvalue * I(through, OUT) + Lvalue * ddt(I(through, OUT));
  // 5 -- [Corrente attraverso Cvalue]
  I(through, gnd)    <+ ddt(Cvalue * V(through, gnd));
#+end_src
*** Terminali

#+begin_src verilog
  // 1 -- [tensione sul blocco vin_th2-Rvalue-Lvalue]
  V (nodeA, OUT) <+ Lvalue * ddt(I(nodeA, OUT)) +(Rvalb + Rvalue) * I(nodeA, OUT) + Vin_th2 * transition (th_swap, 0, 10u, 10u);
  // 2 -- [corrente attraverso Cvalue]
  I(OUT, gnd)    <+ Cvalue * ddt(V(OUT, gnd));
  // 3 -- [tensione sul blocco Lt-Rt-Ct?] [sembrerebbe esclusa la capacità]
  V(OUT, nodeB)  <+ Lti * ddt(I(OUT, nodeB)) + Rti * I(OUT, nodeB) + idt(I(OUT, nodeB)) / (transition(Ctival * mult, 0, 10u, 10u));
  // 4 -- [corrente attraverso il parallelo tra Cs e Rs] 
  I(nodeB, gnd)  <+ V(nodeB, gnd) / Rs + transition(Csval * mult, 0, 10u, 10u) * ddt(V(nodeB, gnd));
#+end_src

** DONE Cosa s'intende per `transition` in Verilog?
Stando a quanto scritto [[https://verilogams.com/refman/basics/expressions.html#transition][qui]]:

#+begin_example
Converts a piecewise constant waveform, operand, into a waveform that has controlled transitions. 
#+end_example

Quindi converte una forma d'onda costante a tratti (immagino una
"spezzata") in una forma d'onda con transizioni controllate.
** A cosa servono tutte le flag del Verilog?                       :Verilog:
Non penso sia per ora necessario
* 27.10.23                                          :Componenti:Bibliografia:
Ho guardato due video del canale di Julia:
- [[https://www.youtube.com/watch?v=q8SzFTtgA60][Cedar: un simulatore di circuito analogico accelerato]]
- [[https://www.youtube.com/watch?v=ZYkojUozeC4][Causal vs. Acausal Modeling]]: spiega la differenza tra i due stili di modeling e quanto sia più facile scalare il problema, in termini di componenti, in un modello acausale.  Da ciò deduco che l'approccio migliore per creare il modello sia quello acausale perché anche più efficiente in termine di risoluzione delle equazioni differenziali.
- [[https://www.youtube.com/watch?v=3DfVowNFI2c][Exploring audio circuits with `ModelingToolkit.jl`]]: Posso recuperare le equazioni del diodo da qui

#+begin_src julia
  function LinearContinuationShockleyDiode(;name, Is = 1.0e-15, eta = 1.0,
                                           Vt = 26.0e-3, Maxexp = 15.0)
      @named oneport = Oneport()
      @unpack v, i = oneport
      ps = @parameters Is = Is eta = eta, Vt = Vt, Maxexp = Maxexp
      eqs = [
          i ~ IfElse.ifelse(v/Vt > Maxexp,
                            Is ∗ (exp(Maxexp) ∗ (1 + v/Vt - Maxexp) - 1),
                            Is ∗ (exp(v/Vt) - 1))
      ]
      extend(ODESystem(eqs, t, [], ps, name=name), oneport)
  end
#+end_src

#+begin_src julia
  function Diode(;name, Ids=1e-6, Vt=0.04, max_exp=15, R=1e8)
      @named oneport = OnePort()
      @unpack v, i = oneport
      pars = @parameters Ids=Ids Vt=Vt max_exp=max_exp R=R
      eqs = [i ~ Ids*(exlin(v/Vt, max_exp) - 1) + (v/R)]
      extend(ODESystem(eqs, t, [], pars; name=name), oneport)
  end
#+end_src

Esiste una libreria di componenti elettrici/elettronici basata su
`ModelingToolkit.jl` diversa da quella standard? A quanto pare no.

* 28.10.23                                                       :Componenti:
Ho pensato di trasformare l'equazione contenente l'integrale in un
equazione differenziale che poi verrà introdotta all'interno di una
legge di Ohm leggermente modificata.

#+begin_example
Variazione di resistenza nel tempo
d/dt (R(t)) = alpha * I(t)
Legge di Ohm
V(t) = R(t) * I(t)
#+end_example

con:
1. alpha = - (Rl - Ra) / V_FRC

Penso a come tradurlo in Julia.

Riporto per continuità di ragionamento anche uno dei casi errati che
ho provato a risolvere.

#+begin_src julia
  # ERRATO, vedi sotto
  @parameters t
  D = Differential(t)

  @mtkmodel VariableResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra, [description = "Resistance when air-filled"]
          Rl, [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Ra, [description = "Variable resistance"]
      end
      @equations begin
          # Ho trasformato l'equazione integrale della resistenza in una differenziale
          D(R) ~ ((Rl - Ra) / V_FRC) * i
          v ~ R * i
      end
  end
#+end_src

Mi sono reso conto di aver sbagliato l'equazione caratteristica della resistenza variabile e la riscrivo.  La variazione della resistenza nel tempo è negativa, in quanto la resistenza diminuisce con l'integrale della corrente.

#+begin_src julia
  @parameters t
  D = Differential(t)

  @mtkmodel VariableResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra, [description = "Resistance when air-filled"]
          Rl, [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Rl, [description = "Variable resistance"]
      end
      @equations begin
          # Ho trasformato l'equazione integrale della resistenza in una
          # differenziale. In particolare ho considerato che i valori
          # estremi di resistenza siano Rl ed Ra, quindi ho limitato
          # l'incremento.
          D(R) ~ ifelse(R > Ra,
                        - ((Rl - Ra) / V_FRC) * i,
                        0)
          v ~ R * i
      end
  end
#+end_src

Mostro un semplice circuito con generatore di onda quadra (e nel caso costante) e resistenza
variabile a Chiara per capire se la forma d'onda può essere quella
corretta oppure no. (vedi `test7.jl`)

* 29.10.23                                                       :Componenti:
Noto che si verifica un problema: quando la resistenza variabile
raggiunge il valore minimo, questa indipendentemente dalla tensione
fornita non cambia.  Provo a modificare il codice modificando la legge
di Ohm.

#+begin_src julia
  @parameters t
  D = Differential(t)

  # CID: Current Integral-Dependent.
  @mtkmodel CIDResistor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ra,    [description = "Resistance when air-filled"]
          Rl,    [description = "Resistance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore d'inizializzazione del sistema.
          R(t) = Rl, [description = "Variable resistance"]
      end
      @equations begin
          # Trasformo l'equazione integrale della resistenza in una
          # differenziale che ne modella la variazione.
          D(R) ~ - ((Rl - Ra) / V_FRC) * i
          # Ra <= R <= Rl
          v ~ min(Rl, max(Ra, R)) * i
      end
  end
#+end_src

** Migliorare la tolleranza della soluzione
L'opzione `reltol` va inserita nella funzione `solve()`. Leggi la sezione "Controlling the Solver" di [[https://docs.sciml.ai/SciMLTutorialsOutput/html/introduction/01-ode_introduction.html][questa risorsa]].

#+begin_example
[...] However, a good rule of thumb is that the total solution accuracy is 1-2 digits less than the relative tolerances. [...]
#+end_example

** DONE Implementare induttore variabile
Ottenuto a partire dal codice di `CIDResistor`.  Da testare

#+begin_src julia
  @parameters t
  D = Differential(t)

  # CID: Current Integral-Dependent.
  @mtkmodel CIDInductor begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          Ia,    [description = "Inductance when air-filled"]
          Il,    [description = "Inductance when liquid-filled"]
          V_FRC, [description = "Airway Volume at FRC"]
      end
      @variables begin
          # Il valore di default altro non è che il valore
          # d'inizializzazione del sistema.
          I(t) = Il, [description = "Variable inductance"]
      end
      @equations begin
          # Trasformo l'equazione integrale dell'induttanza in una
          # differenziale che ne modella la variazione.
          D(I) ~ - ((Il - Ia) / V_FRC) * i
          # Ia <= I <= Il
          # d/dt (i(t)) = 1 / L * v(t), equazione dell'induttore
          D(i) ~ (1 / (min(Il, max(Ia, I)))) * v
         end
  end
#+end_src

* 30.10.23                                                       :Componenti:
In realtà non sono ancora totalmente convinto dalle soluzioni che ho
trovato in questi giorni e che riguardano la resistenza variabile.
Questo perché l'equazione caratteristica non è mai comparsa.  Voglio
presentare a Chiara due soluzioni: 
- Quella più corretta dal punto di vista matematico, con le equazioni
  riprese dal paper cartaceo da lei fornitomi.
  #+begin_src julia
    @mtkmodel VariableResistor begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ra,    [description = "Resistance when air-filled"]
            Rl,    [description = "Resistance when liquid-filled"]
            V_FRC, [description = "Airway Volume at FRC"]
        end
        @variables begin
            # Dopo l'uguale ho i valori di inizializzazione delle
            # variabili.
            ∫i(t) = 0, [description = "Current integral"]
            # Dichiaro come variabile d'interesse anche la resistenza.
            R(t) = Rl, [description = "Variable resistance"]
        end
        @equations begin
            # Ho trasformato l'equazione integrale della resistenza in una
            # differenziale. La notazione `∫i` indica il nome di una
            # variabile che rappresenta l'integrale della corrente.
            D(∫i) ~ i
            # Ra <= R <= Rl: suppongo che i valori Ra ed Rl siano estremi da non superare.
            R ~ min(Rl, max(Ra, (Ra + (Rl - Ra) * (1 - ∫i / V_FRC))))
            # R ~ Ra + (Rl - Ra) * (1 - ∫i / V_FRC) # --> non funziona in
            # questa forma.
            # Legge di Ohm per legare la corrente alla
            # tensione sulla resistenza.
            v ~ R * i
        end
    end
  #+end_src
  Fornisco delle immagini raffiguranti grafici delle simulazioni del
  componente (queste hanno nel titolo `*_not_approx`).
  
- Quella meno rigorosa dal punto di vista matematico (con però una forma
  d'onda migliore).

  #+begin_src julia
    @mtkmodel VariableResistor begin
        @extend v, i = oneport = OnePort()
        @parameters begin
            Ra, [description = "Resistance when air-filled"]
            Rl, [description = "Resistance when liquid-filled"]
            V_FRC, [description = "Airway Volume at FRC"]
        end
        @variables begin
            # Creo una variabile temporanea perché non riesco a salvare la
            # variabile "in place".
            # Dopo l'uguale ho i valori di inizializzazione delle
            # variabili.
            Rtemp(t) = Rl, [description = "Temporary resistance"]
            R(t) = Rl, [description = "Variable resistance"]
        end
        @equations begin
            # Facendo la derivata della resistenza ottengo questo:
            D(Rtemp) ~ - ((Rl - Ra) / V_FRC) * i
            # Ra <= R <= Rl
            # Limito la resistenza tra i due valori estremi.
            R ~ min(Rl, max(Ra, Rtemp))
            v ~ R * i
        end
    end
  #+end_src

  Fornisco delle immagini raffiguranti grafici delle simulazioni del
  componente (queste hanno nel titolo `*_approx`).

Per me la soluzione approssimata potrebbe essere migliore in quanto le
forme d'onda sono continue.

Un altro problema che ho è quello di non sapere quanto valga
l'ampiezza dell'onda quadra che si vuole utilizzare nelle simulazioni,
per cui mando più grafici.

* 31.10.23                                                          :Modello:
Chiara ha risposto dicendo che il componente si comporta come
dovrebbe, quindi inizio ad abbozzare il modello della sottorete.

Mi è stato chiesto di farlo prima con resistenze e condensatori fissi
e poi le rendo variabili in un altro test.

|                  |          IAD |          IAE |          IAF |          IAG |          IAH |          IAI |          IBL |          IBA |          IBB |
|------------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------+--------------|
| Tipo             |       Airway |     Alveolus |       Airway |     Alveolus |       Airway |     Alveolus |       Airway |     Alveolus |     Alveolus |
| Ra               | 3.100029e+01 | 3.109214e+02 | 2.231464e+01 | 4.012746e+02 | 3.554331e+01 | 4.759710e+02 | 3.097440e+01 | 2.017423e+02 | 2.282920e+02 |
| Rb               | 1.514023e+03 | 1.518509e+04 | 1.089824e+03 | 1.959785e+04 | 1.735899e+03 | 2.324594e+04 | 1.512758e+03 | 9.852891e+03 | 1.114955e+04 |
| La               | 1.852803e-03 | 6.440085e-03 | 1.166141e-03 | 6.908560e-03 | 1.653093e-03 | 7.229610e-03 | 1.290849e-03 | 5.687354e-03 | 5.896531e-03 |
| Lb               | 1.664949e+00 | 5.718839e+00 | 1.047907e+00 | 6.134848e+00 | 1.485488e+00 | 6.419942e+00 | 1.159971e+00 | 5.050408e+00 | 5.236159e+00 |
| Ccap (C_g)       | 1.689219e-09 | 2.462271e-07 | 8.128360e-10 | 2.461359e-07 | 9.126539e-10 | 2.460874e-07 | 5.722034e-10 | 2.464514e-07 | 2.463766e-07 |
| Rti              |            - |         1200 |            - |         1200 |            - |         1200 |            - |         1200 |         1200 |
| Lti              |            - | 5.795540e-04 |            - | 5.795540e-04 |            - | 5.795540e-04 |            - | 5.795540e-04 | 5.795540e-04 |
| Cti              |            - | 2.400000e-05 |            - | 2.400000e-05 |            - | 2.400000e-05 |            - | 2.400000e-05 | 2.400000e-05 |
| Rs               |            - |        80000 |            - |        80000 |            - |        80000 |            - |        80000 |        80000 |
| Cs               |            - | 2.100000e-05 |            - | 2.100000e-05 |            - | 2.100000e-05 |            - | 2.100000e-05 | 2.100000e-05 |
| Rws              | 4.186147e+06 |            - | 9.257208e+06 |            - | 8.703449e+06 |            - | 1.461035e+07 |            - |            - |
| Lws              | 3.705082e-01 |            - | 7.164089e-01 |            - | 5.994469e-01 |            - | 9.016810e-01 |            - |            - |
| Cws              | 3.503620e-10 |            - | 1.584351e-10 |            - | 1.685156e-10 |            - | 1.003855e-10 |            - |            - |
| Chargeth (V_FRC) | 1.744963e-06 | 3.642283e-07 | 8.396596e-07 | 2.699475e-07 | 9.427715e-07 | 2.198790e-07 | 5.910861e-07 | 5.958497e-07 | 5.185713e-07 |
| Vin_th           | 4.666378e+00 | 7.926677e+00 | 4.990351e+00 | 8.694383e+00 | 5.289833e+00 | 9.256451e+00 | 5.588244e+00 | 6.794462e+00 | 7.098371e+00 |
| Vgravity         |            0 |            0 |            0 |            0 |            0 |            0 |            0 |            0 |            0 |
| STATUS           |           OK |           OK |           OK |           OK |           OK |           OK |           OK |           OK |           OK |

Tutti i componenti instanziati nel modello sottostanti sono stati
ricontrollati con la precedente tabella riassuntiva.  Noto che alcuni
valori si ripetono ({R, L, C}ti, {R, C}s).

#+begin_src julia
  # Dichiaro la struttura circuitale (i.e. serie tra il generatore e la resistenza variabile).
  @mtkmodel System begin
      @components begin
          # Sorgenti del segnale e ground
          gen = Square(frequency = 0.5, amplitude = 1.0e-3, smooth = true)
          source = Voltage()
          ground = Ground()

          # IAD
          # Per ora ignoro questa parte.
          # Chargeth= 1.744963e-06 # -- V_FRC
          # Vin_th= 4.666378e+00 # -- tensione su primo diodo
          # Vgravity= 0
          IAD = Airway(
              r_tube.R = (3.100029e+01 + 1.514023e+03) / 2,
              i_tube.L = (1.852803e-03 + 1.664949e+00) / 2,
              c_g.C    = 1.689219e-09,
              r_sw.R   = 4.186147e+06,
              i_sw.L   = 3.705082e-01,
              c_sw.C   = 3.503620e-10,
              r_tube_1.R = (3.100029e+01 + 1.514023e+03) / 2,
              i_tube_1.L = (1.852803e-03 + 1.664949e+00) / 2
          )

          # IAE
          # Chargeth= 3.642283e-07 
          # Vin_th= 7.926677e+00 
          # Vgravity= 0 
          IAE = Alveolus(
              r_tube.R = 3.109214e+02 + 1.518509e+04,
              i_tube.L = 6.440085e-03 + 5.718839e+00,
              c_ga.C   = 2.462271e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IAF
          # Per ora ignoro questa parte.
          # Chargeth= 8.396596e-07
          # Vin_th= 4.990351e+00
          # Vgravity= 0 
          IAF = Airway(
              r_tube.R = (2.231464e+01 + 1.089824e+03) / 2,
              i_tube.L = (1.166141e-03 + 1.047907e+00) / 2,
              c_g.C    = 8.128360e-10,
              r_sw.R   = 9.257208e+06,
              i_sw.L   = 7.164089e-01,
              c_sw.C   = 1.584351e-10,
              r_tube_1.R = (2.231464e+01 + 1.089824e+03) / 2,
              i_tube_1.L = (2.231464e+01 + 1.089824e+03) / 2
          )

          # IAG
          # Chargeth= 2.699475e-07
          # Vin_th= 8.694383e+00
          # Vgravity= 0 
          IAG = Alveolus(
              r_tube.R = 4.012746e+02 + 1.959785e+04,
              i_tube.L = 6.908560e-03 + 6.134848e+00,
              c_ga.C   = 2.461359e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IAH
          # Per ora ignoro questa parte.
          # Chargeth= 9.427715e-07
          # Vin_th= 5.289833e+00
          # Vgravity= 0
          IAH = Airway(
              r_tube.R = (3.554331e+01 + 1.735899e+03) / 2,
              i_tube.L = (1.653093e-03 + 1.485488e+00) / 2,
              c_g.C    = 9.126539e-10,
              r_sw.R   = 8.703449e+06,
              i_sw.L   = 5.994469e-01,
              c_sw.C   = 1.685156e-10,
              r_tube_1.R = (3.554331e+01 + 1.735899e+03) / 2,
              i_tube_1.L = (1.653093e-03 + 1.485488e+00) / 2
          )

          # IAI
          # Chargeth= 2.198790e-07
          # Vin_th= 9.256451e+00
          # Vgravity= 0
          IAI = Alveolus(
              r_tube.R = 4.759710e+02 + 2.324594e+04,
              i_tube.L = 7.229610e-03 + 6.419942e+00,
              c_ga.C   = 2.460874e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )

          # IBL
          # Per ora ignoro questa parte.
          # Chargeth= 5.910861e-07 
          # Vin_th= 5.588244e+00 
          # Vgravity= 0
          IBL = Airway(
              r_tube.R = (3.097440e+01 + 1.512758e+03) / 2,
              i_tube.L = (1.290849e-03 + 1.159971e+00) / 2,
              c_g.C    = 5.722034e-10,
              r_sw.R   = 1.461035e+07,
              i_sw.L   = 9.016810e-01,
              c_sw.C   = 1.003855e-10,
              r_tube_1.R = (3.097440e+01 + 1.512758e+03) / 2,
              i_tube_1.L = (1.290849e-03 + 1.159971e+00) / 2
          )

          # IBA
          # Chargeth= 5.958497e-07 
          # Vin_th= 6.794462e+00 
          # Vgravity= 0 
          IBA = Alveolus(
              r_tube.R = 2.017423e+02 + 9.852891e+03,
              i_tube.L = 5.687354e-03 + 5.050408e+00,
              c_ga.C   = 2.464514e-07,
              r_t.R    = 1200 ,
              i_t.L    = 5.795540e-04 ,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000 ,
              c_s.C    = 2.100000e-05
          )

          # IBB        
          # Chargeth= 5.185713e-07
          # Vin_th= 7.098371e+00
          # Vgravity= 0
          IBB = Alveolus(
              r_tube.R = 2.282920e+02 + 1.114955e+04,
              i_tube.L = 5.896531e-03 + 5.236159e+00,
              c_ga.C   = 2.463766e-07,
              r_t.R    = 1200,
              i_t.L    = 5.795540e-04,
              c_t.C    = 2.400000e-05,
              r_s.R    = 80000,
              c_s.C    = 2.100000e-05
          )
      end

      @equations begin
          connect(gen.output, source.V)
          connect(source.p, IAD.in)
          connect(IAD.out, IAE.in, IAF.in)
          connect(IAF.out, IAH.in, IAG.in)
          connect(IAH.out, IBL.in, IAI.in)
          connect(IBL.out, IBA.in, IBB.in)
          connect(source.n, ground.g)
      end
  end
#+end_src

Noto che vi erano degli errori nella definizione della capacità `c_s`
nel modello alveolare.  Questi sono stati sistemati in `test8.jl`.

Ho sistemato il modello di stamattina isolando il parametri del
sistema per rendere il tutto maggiormente modificabile. (si veda
`test9.jl`).

** DONE Capire come graficare meglio i risultati
** DONE Implementare il modello con componenti variabili.          :Modello:

* 01.11.23                                                       :Componenti:
Implemento il diodo in Julia rimanipolando del codice trovato online il 27.10.

#+begin_src julia
  function Diode(;name, Ids=1e-6, Vt=0.04, max_exp=15, R=1e8)
      @named oneport = OnePort()
      @unpack v, i = oneport
      pars = @parameters Ids=Ids Vt=Vt max_exp=max_exp R=R
      eqs = [i ~ Ids*(exlin(v/Vt, max_exp) - 1) + (v/R)]
      extend(ODESystem(eqs, t, [], pars; name=name), oneport)
  end

  exlin(x, max_x) = ifelse(x > max_x, exp(max_x)*(1 + x - max_x), exp(x))

  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          # Parametri che costituiscono il componente.
          Ids, [description = "Current flowing in the component"]
          Vt, [description = "Threshold"]
          max_exp
          R
      end
      @equations begin
          i ~ Ids * (exlin(v / Vt, max_exp) - 1) + (v / R)
      end
  end

  function Diode(::Ideal; name)
      @named(p = Pin()); @named(n = Pin())
      @variables v(t) i(t)
      eqs = [
          v ~ p.v - n.v #Convenience
          0 ~ p.i + n.i #in = -out
          i ~ p.i #Positive current flows *into* p terminal
          0 ~ IfElse.ifelse(v<0, i, v)
      ]

      ODESystem(eqs, t, [v, i], [], systems=[p, n], defaults=Dict(), name=name)
  end

  @mtkmodel Diode begin
      @extend v, i = oneport = OnePort()
      @parameters begin
          # Parametri che costituiscono il componente.
          V_th, [description = "Resistance when liquid-filled"]
      end
      @equations begin
          0 ~ ifelse(v < v_th, i, v - v_th)
      end
  end

#+end_src

Ho provato un po' di alternative ma nessuna di queste è valida per il mio utilizzo.  Ho migliorato la leggibilità del codice di `test9.jl`.

* 02.11.23
** DONE Mostro `test9.jl` ed il grafico risultante.
Ok, va bene ma vedi sotto.

** DONE Domande da fare
- Per ora non riesco ad implementare un diodo.  Volevo chiedere quale
  equazione caratteristica posso utilizzare per implementarlo e come
  devo interpertare il valore `v_th` dei vari blocchi.
Il diodo compare solo nell'interfaccia aria/acqua. quando ho solo aria
o solo acqua questo non c'è.
- Il modello con componenti variabili deve considerare solo resistenze
  `Rtube` o anche altri componenti variabili?  Anche Ltube.
- Il modello di via respiratoria deve considerare solo `Rtube` come
  variabile, non `Rtube1`, giusto?
Le resistenze devono essere uguali, quindi variabile.

** DONE Implementare il modello con componenti variabili

** Colloquio con Chiara                                       :Suggerimenti:
L'integrale nella via aerea "media" (quindi via respiratoria ed
alveolo) non deve essere effettuato dall'inizio della simulazione ma
da quando arriva l'aria all'interno della via aerea.  Ho bisogno di
trovare un modo per passare una variabile da un modulo all'altro
(passerei l'integrale della corrente nel precedente modulo?).

** DONE Vedi come posso passare una variabile da un modulo all'altro :Componenti:

** DONE Modificare l'onda quadra così che abbia 40ns di rise e 400ns di HIGH.

* 03.11.23                                                 :Input:Componenti:
Inizierei considerando il problema più semplice: l'onda quadra.  Leggo
la sua implementazione per capire da quali parametri dipende.

Guardando in `.../Blocks/sources.jl`, noto delle funzioni
differenziabili per evitare il fenomeno di Gibbs.  L'equazione di
`Square` viene modificata dal parametro `smooth=true`.  In
particolare, se lo eguaglio ad un valore numerico, questo diventa lo
smoothing factor dell'onda quadra.

Cosa s'intende per smoothing factor?  Lo scoprirò empiricamente.  È
legato alla pendenza dell'onda quadra, la cui implementazione
"smoothed" è un'artan(x) (vedi `test11.jl`).

Mi dedico ora al diodo.  Credo che spostando la variabile `∫i` nei
modelli ad alto livello (i.e. `Airway` e `Alveolus`) dovrei avere modo
di calcolarla una volta sola e poi sfruttarla in ciascun componente.
Altre due variabili potrebbero essere interessanti da implementare:
trigger_in e trigger_out. La prima indica lo stato di riempimento
della via aerea in input a quella del modulo.  La seconda indica lo
stato di riempimento della via aerea del modulo corrente.  L'integrale
della corrente deve essere valutato a partire dal momento in cui
arriva l'aria nella via aerea corrente, quindi ipotizzo che lo stato
di `trigger_in` sarà true mentre quello di `trigger_out` sarà `false`.
Lo stato sarà mantenuto fino a quando l'integrale sarà uguale a
`V_FRC`, valore che rappresenta il volume massimo.  Quando `∫i / V_FRC
= 1`, cambio stato: trigger_in = 1, trigger_out = 1.

| trigger_in | trigger_out | stato      | integrazione     |
|------------+-------------+------------+------------------|
| false      | false       | Full water | no --> D(∫i) = 0 |
| false      | true        | ---        | ---              |
| true       | false       | Interface  | sì --> D(∫i) = i |
| true       | true        | Full air   | no --> D(∫i) = 0 |

#+begin_src julia
  # Nel modulo gestisco solo trigger_out.
  trigger_out = ifelse(∫i / V_FRC >= 1,
                       true,
                       false)
  # Integro solo quando sono nello stato "interface"
  D(∫i) = ifelse(trigger_in == true && trigger_out == false,
                 0,
                 i)
#+end_src

La variabile `∫i` dovrà esistere anche nei componenti variabili per
interagire con quella del modello ad alto livello.  Devo quindi
effettuare una connessione alto-basso livello.

#+begin_src julia
  r_tube.v.∫i   = ∫i
  i_tube.v.∫i   = ∫i
  r_tube_1.v.∫i = ∫i
  i_tube_1.v.∫i = ∫i
#+end_src

Devo riscrivere la configurazione dei parametri che non avrà più
sdoppiata la V_FRC.

* 04.11.23                                          :Modello:Parametri:Input:
Voglio semplificare la gestione dei parametri di sistema, in quanto vi
sono molti duplicati delle stesse variabili/parametri.

Ho scritto un semplice codice di prova per testare l'isolamento dei
parametri in un modello ad alto livello.

#+begin_src julia
  @mtkmodel System begin
      @parameters begin
          A
          R
          C
      end
      @components begin
          # Sorgenti del segnale e ground.
          gen = Square(amplitude = A,
                       frequency = 0.1,
                       smooth    = 1.0e-3)
          source = Voltage()
          ground = Ground()
          R1 = Resistor(R = R)
          C1 = Capacitor(C = C)
      end
      @equations begin
          connect(gen.output, source.V)
          connect(source.p, R1.p)
          connect(R1.n, C1.p)
          connect(C1.n, source.n, ground.g)
      end
  end

  # Istanzio il modello (parametri esclusi).
  @mtkbuild system = System()

  sys_ps = [
      system.A => 2
      system.R => 4.0
      system.C => 1.0e-1
  ]

#+end_src

- Alcuni parametri devono necessariamente essere scritti all'interno della funzione che genera quel componente (e.g. `frequency` e `smooth` per `Square()`).
- I nomi dei parametri nel modello superiore (alias per "ad alto livello") possono essere gli stessi di quelli dei modelli inferiori, senza interferire tra loro.

* 04.11.23                                          :Modello:Parametri:Input:
Ieri pomeriggio ho provato ad implementare un parametro ereditabile
all'interno del modello superiore ma a quanto pare non ha funzionato:
i parametri inferiori devono comunque essere inizializzati in qualche
modo.

Sto leggendo la documentazione di `ModelingToolkit.jl` per capirne
meglio il funzionamento, dato che molte delle cose che vorrei
implementare dipendono da ciò.

** TODO Associare unità di misura e input/output alle variabili :Componenti:

Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/ContextualVariables/#Variable-metadata][`Variable Metadata`]].
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Variable_metadata/#Input-or-output][`Input or output`]].

#+begin_src julia
  # Per esempio questo
  @variables x[1:2, 1:2] [connect = Flow; unit = u"m^3/s"]
#+end_src

** TODO Aiutare il futuro sviluppatore del sistema mediante `getdescription(var)` :Futuro:

Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Variable_metadata/#Variable-descriptions][`Variables descriptions`]].
** TODO Leggere manuale di `ModelingToolkit`                    :Julia:Must:
Vedi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#components][`Composing Models and Building Reusable Components`]].  
- [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#Numerics-with-Composed-Models][`Numerics with Composed Models`]] tratta di come estrarre le serie
  temporali dalla soluzione del sistema.

#+begin_src julia
  sol[x,1:5] # Dove x è variabile, 1..5 è l'intervallo d'interesse
#+end_src

- [[https://docs.sciml.ai/ModelingToolkit/stable/basics/Composition/#Variable-scope-and-parameter-expressions][`Variable scope and parameter expressions`]] tratta di come
  condividere i parametri appartenenti a sistemi a diversi livelli.
  (Per "comporre" i livelli, il codice d'esempio utilizza `\circ`).
  Esiste una funzione `ParentScope()` che dovrebbe permettere di avere
  la visibilità dei parametri del modello superiore ma per ora non
  funziona correttamente.

Leggi [[https://docs.sciml.ai/ModelingToolkit/stable/basics/MTKModel_Connector/#mtkmodel_connector][`Components and Connectors`]]: Include le informazioni essenziali
sulla gestione dei modelli costituiti da componenti.

* 05.11.23
** DONE Dubbi sulle unità di misura                                :Domande:
Le unità di misura di ciascuna variabile devono essere quelle elettriche oppure quelle meccaniche?

* 07.11.23                                            :Bash:Input:Repository:
** Conversione dati di input                             :Conversione:Input:
Sto lavorando su uno script per effettuare una conversione dei dati
contenuti in `Albero.cir` in un formato che sia leggibile dal main di
Julia.

L'idea sarebbe quella di convertire ciascuna riga nella dichiarazione
del componente superiore dell'apposito tipo.
*** DONE I parametri `C_g` e `C_ga` verranno chiamati entrambi `C_g` :Conversione:Parametri:
** Sistemazione del tree della repository              :Pulizia:Repository:
I file sorgenti erano troppo caotici nella directory, quindi ho deciso
di creare delle posizioni più sensate.

* 08.11.23
** DONE Sistemare nome parametri per corrispondere a quelli di `cir2jl` :Parametri:Julia:

C'è un problema che devo risolvere, ossia che il file del modello che voglio importare è troppo grande per essere importato da Julia...
** TODO Come posso importare un così gran numero di dati?          :Problema:
* 09.11.23                                                       :Componenti:
Il problema della gestione dell'input di 50k moduli è da risolversi
suddividendo, per forza di cose, in sottoreti minori.  Fosse esso
gestibile da diversi threads sarebbe ancora meglio.

Come potrei gestire queste sottoreti?

Ho parlato con Chiara: mi ha fornito dell'albero completo senza {R, C,
I}_sw per capire se lo StackOverflowError si può risolvere.  Devo per
forza di cose ora ritornare al problema del diodo, di `trigger_out` e
`trigger_in`.  Dice inoltre che si possono utilizzare le unità
elettriche per il nostro modello e non quelle fisiche/meccaniche.

** DONE Sistemare lo script per includere anche i trigger{in, out}    :Bash:
L'ho fatto in treno.  Basta un `echo` ed un `sed`.
* 10.11.23                                                       :Componenti:
Ho sistemato lo script e il `main.jl` così da calcolare l'integrale
della corrente a partire da quando arriva il flusso.  Ho aggiunto
`src/util/graphs_trigger.jl`: crea i grafici di quello che avviene a
livello di trigger_in, trigger_out e integrale della corrente nei vari
moduli.

** TODO Convenzioni delle correnti                                 :Domande:
La corrente negativa indica una corrente entrante nella via aerea?

